# 蓝桥杯 2013 省 B 翻硬币

## 题目背景
小明正在玩一个“翻硬币”的游戏。
## 题目描述
桌上放着排成一排的若干硬币。我们用 `*` 表示正面，用 `o` 表示反面（是小写字母，不是零），比如可能情形是 `**oo***oooo`，如果同时翻转左边的两个硬币，则变为 `oooo***oooo`。现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？
## 输入格式
两行等长字符串，分别表示初始状态和要达到的目标状态，每行长度小于 $1000$。
数据保证一定存在至少一种方案可以从初始状态和要达到的目标状态。
## 输出格式
一个整数，表示最小操作步数。
## 样例 #1
### 样例输入 #1
```
**********
o****o****
```
### 样例输出 #1
```
5
```
## 样例 #2
### 样例输入 #2
```
*o**o***o***
*o***o**o***
```
### 样例输出 #2
```
1
```

## 题解
贪心真是一个很奇妙的思想......不过这道题目也很奇妙。。。
一上来我就举了个找不到解的例子：
```
*o*o*
o*o*o
```
怎么算都找不到解法。。只能去看题解了，发现有人说这个不同硬币的数量奇偶性不同时是无解的。。。

那就简单来考虑
- 由于不会有无解的情况，我们可以从左至右依次循环遍历 $a$ 字符串的每一个字符，判断是不是与 $b$ 串相应的字符相等。
- 若不相等，翻转这枚和下一枚（他右边的）硬币。
- 并给翻转次数+1

```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
string a, b;  
int cnt = 0;  
  
int main (void){  
    cin >> a >> b;  
    int l = a.size();  
        for(int i = 0; i < l; i++){  
        if(a[i] != b[i]){  
            // 如果不同就翻转  
            if(a[i] == 'o') a[i] = '*';  
            else a[i] = 'o';  
                        if(a[i+1] == 'o') a[i+1] = '*';  
            else a[i+1] = 'o';  
                        // 等价于使用三目表达式  
//            a[i] = a[i] == 'o'? '*': 'o';  
//            a[i+1] = a[i+1] == 'o' ? '*' : 'o';  
            cnt++;  
        }  
    }  
        cout << cnt << endl;  
}
```

# USACO1.3 混合牛奶 Mixing Milk
## 题目描述
给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的**最小花费**。
注：每天所有奶农的总产量大于 Marry 乳业的需求量。
## 输入格式
第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。
接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。
## 输出格式
单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。
## 样例 #1
### 样例输入 #1
```
100 5
5 20
9 40
3 10
8 80
6 30
```
### 样例输出 1
```
630
```
### 题解
没什么特别好说的，贪心条件是找到单价最小的牛奶，然后买完后再往上买
但是这里很重要的是学会`vector`里面是`pair`类型时，排序是按照第一个元素大小进行排序的
```c++
#include<bits/stdc++.h>
using namespace std;

int n, m;
int p, a;
// 一定要typedef !!!
typedef pair<int, int> pii;
vector<pii>vec;

int main(void){
	cin >> n >> m;
	for(int i = 0; i < m; i++){
		cin >> p >> a;
		vec.push_back({p, a});
	}
	
	sort(vec.begin(), vec.end());
	long sum = 0;
	
	for(int i = 0; i < m; i++){
		if((n - vec[i].second) >= 0){
			sum += vec[i].first * vec[i].second;
			n -= vec[i].second;
		}
		else{
			sum += n * vec[i].first;
			break;
		}
	}
	cout << sum << endl;
	return 0;
}
```



