# 绪论

## 数据结构的概念与分类
### 为什么要学习数据结构
#### 计算机系统组成部分
硬件 + 用户 + 软件
#### 研究对象
**数据**
##### 如何组织
- 逻辑关系
- 存储关系
##### 如何处理
**算法**

顺序打印N个数
```c
#include <stdio.h>  
void f1(int n) {  
    for (int i = 0; i <= n; i++) {  
        printf("%d", i);  
    }  
    return;  
}  
  
void f2(int n) {  
    if (n) { // 不要忘记设置递归出口  
        f2(n - 1);  
        printf("%d", n);  
    }  
    return;  
}  
  
int main(void) {  
    int n;  
    scanf("%d", &n);  
    f1(n);  
    printf("\n");  
    f2(n);  
}
```

### 与数据结构相关术语
#### 数据
数据是*信息*在计算机程序中的*表示形式或编码形式*，是描述客观事物的数、字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合
#### 信息
有用的数据
#### 数据处理操作
- 收集、整理、编码
- 输入、存储
- 检索、分类、计算
#### 数据元素
- 元素、结点、顶点、记录
- 数据的基本单位
- 数据集合的一个个的客体
- *数据元素*可由*若干个数据项*组成
- 数据项是*数据的最小单位*
#### 数据对象
- 具有相同特性的数据元素的集合
- 整数、学生、课程
#### 数据结构
- 数据之间存在的*联系*
- 具有结构的*数据元素*的集合
#### 数据类型
- 一组*性质相同的值的集合*
- 以及定义于这个值集合上的*一组操作*的总称
- 内建数据类型
	- 基本数据类型：计算机中已经实现的数据结构
	- 构造数据类型：多个基本数据类型构成
#### 抽象数据类型
由用户定义，用以表示应用问题的数据模型

## 数据结构的分类
### 分解与抽象
### 逻辑结构
- 集合结构
- 线性结构
- 非线性结构
	- 树形结构
	- 图形结构
### 存储结构(物理结构)
#### 存储内容
- 存储各数据元素的内容和值
- 每个元素占据独立的存储空间
#### 四种存储结构（分类、方式）
##### (1) 顺序存储结构
 a. 逻辑上相邻的元素存储位置也相邻
 b. 元素的逻辑关系由存储单元的邻接位置关系来体现
 c. 用一片连续的存储单元
 d. 通常用数组来描述
##### (2) 链接存储结构
 a. 逻辑上相邻的元素，其存储位置不一定相邻
 b. 元素的逻辑关系由附加的链接指针指示
 c. 通常借助指针类型来描述
 d. 不必事先分配存储空间、动态分配
##### (3) 索引存储结构
 a. 给存储的数据元素建立索引表
 b. 索引项 = 关键码 + 地址
 c. 稠密索引、稀疏索引（索引项针对每个元素还是一组）
 d. 线性索引、多级索引（索引表是一层还是多层）
##### (4) 散列存储结构(hash)
 a. 根据散列函数
 b. 直接得到存储地址
#### 三类存取方法
##### (1) 直接存取结构
 a. 按照序号直接存取
 b. 如：向量、多维数组、散列表……
##### (2) 顺序存取结构
 a. 从头开始
 b. 按逻辑顺序逐个访问
 c. 链表结构：单链表、双向链表、循环链表、二叉链表、三叉链表、图的邻接表……
##### (3) 索引结构
 a. 通过关键码访问元素
 b. 如：线性索引、多叉查找树
#### 如何选择存储结构？
##### (1) 访问频率
 a. 经常访问、不频繁修改
 b. 存取速度快、存储利用率高
##### (2) 修改频率
 a. 经常需要修改
 b. 修改速度快、尽可能不移动元素
##### (3) 安全保密
 a. 安全保密要求高
 b. 采用面向对象方法
 c. 用类的继承方式
 d. 划定访问级别：公有public、私有private、保护protected
#### 定义在数据结构上的操作
- 创建
- 销毁
- 查找
- 插入
- 删除
- 排序
#### 好的数据结构
能通过某种“线性化”规则转化为线性结构

## 算法与算法设计
### 算法定义与特性
#### 定义
解决某一特定任务的有穷的运算序列(指令集)
#### 特性
##### 有输入
- 0个或多个输入
- 可没有输入
##### 有输出
- 有1个或多个输出
- 必须有输出
##### 确定性
- 无二义性
- 无歧义
*随机数不违反确定性*，而是用随机这个本身就是人为想好的
##### 有穷性/有限性
- 有限步骤内结束
- 不能死循环
##### 可行性
- 每一条运算足够基本
#### 算法和程序的区别
- 数据结构+算法=程序
- 程序可以不符合有穷性
- 操作系统的无休止运行
### 算法的设计步骤
#### 设计方法
- 自顶向下
- 逐步求精
#### 具体步骤
1. 理解需求
2. 设计思路
3. 算法框架
4. 程序实现
### 设计的基本方法
#### 穷举法
#### 迭代法
#### 递推法
#### 递归法
用递推与递归求斐波那契数列
```c++
#include <stdio.h>  
  
int Fibo1(int n) {  
    int f0 = 0, f1 = 1, f2;  
    if (n == 0 || n == 1) return n;  
    for (int i = 2; i <= n; i++) {  
        f2 = f0 + f1;  
        f0 = f1;  
        f1 = f2;  
    }  
    return f2;  
}  
  
int Fibo2(int n) {  
    if (n == 0 || n == 1) return n;  
    return Fibo2(n - 2) + Fibo2(n - 1);  
}  
int main() {  
    int n = 10;  
    printf("%d\n", Fibo1(n));  
    printf("%d\n", Fibo2(n));  
}
```

### 算法分析与度量
#### 算法的评价标准(和特性不一样)
##### 正确性
正确理解、正确描述、正确实现、正确输入
##### 健壮性
在不正确输入条件下能够自我保护，加入容错机制，能够检错、报错、纠错
##### 可读性
便于理解、测试与修改
逻辑清晰、简单和结构化
变量名、函数名的命名准确
添加注释
##### 高效性
良好的时空性能
##### 简单性
简单的数据结构和方法
算法简单、出错率低、可靠性高
#### 时空复杂度度量
##### 算法分析
- 后期测试
- 事前估计
	- 时间、空间复杂度度量
##### 复杂度度量与问题规模
- 程序运行时间/算法效率的影响因素
	1. 问题规模
	2. 机器执行速度
	3. 代码质量
	4. 语句执行次数
- 选择不受影响的度量参数——时间/空间复杂度
##### 时间复杂度度量

# 线性表

特点：
各个成员结点，不是连续存储的
最后一个成员的指针是NULL

链式表简单理解：
```c++
#include<stdio.h>
#include<stdlib>

struct node{
	int value; // 节点的值
	struct node *next; // 指向结构体本身的指针
};

int main(void){
	struct node a; // 是一个结点
	struct node b;
	
	struct node* list = NULL; // 空链表

	list = &a; // list链表，含有一个结点
	a.next = &b;
	b.next = NULL;
}
```
![[微信截图_20230825131827.png]]

### 链表类型
**有无头结点：**
	带头结点的单链表
	不带头结点的单链表
#### 不带头结点
![[微信截图_20230825135448.png]]
不浪费，每个成员(结点)都包含数据
也是最原始的链表方式

#### 带头结点
![[微信截图_20230825135542.png]]
带头结点链表至少有一个结点
每一个数据结点都有一个前驱

```c++
// 创建带有头结点的空链表
struct node* list_create(){
	struct node* list = (struct node*)malloc(sizeof(struct node)); // 分配node的内存
	if(list == NULL){
		return NULL; //防止内存不够分配 
	}
	list -> next = NULL; // 指向结构体的指针要加箭头
	return list;
}

// 使用数组来创建一个链表
struct node* list_create(int data[], int n){
	// 创建头结点
	struct node* list = (struct node*)malloc(sizeof(struct node));
	if(list == NULL){
		return NULL; //防止内存不够分配 
	}
	
	struct node *p = list;
	
	for(int i = 0; i < n; i++){
	// 创建新结点
	struct node *tmp =  (struct node*)malloc(sizeof(struct node));
	// 设置数据
	tmp -> value = data[i];
	// 链接
	p -> next = tmp;
	// 指针后移
	p = p -> next;
	}
	p -> next = NULL;
	return list;
}

void list_visit(struct node* list){
	if(list == NULL;){
		return;
	}
	
	for(struct node* p = list -> next; p; p = p->next){
		printf("%d", p -> value);
	}
}

int main(void){
	int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	struct node* list = list_create(data, 10);

	list_visit(list);

	return 0;
}
```
栈空间：函数调用结束就被清除
堆空间：从堆空间中分配内存，不会因为调用结束清除

**有几个方向：**
	单链表
	双向链表

**有没有环：**
	链表
	循环链表
