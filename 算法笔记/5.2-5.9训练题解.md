## 送分题
[P9651 SNCPC2019](https://www.luogu.com.cn/problem/P9651?contestId=133532)
### 题解
没什么好说的，发现只要$f(i)$中，$i$的位数里面包含0，那么$f(i)=0$，由于每十个必定会出现0，所以最多只有9个数相乘，其他情况结果都为0。
主要是不要忘记了要开`long long`，不然会因为`MOD`太大了，所以两个数相乘可能会爆`int`。。。
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
int t, l, r;  
long long res = 0;  
long long MOD = 1e9 + 7;  
  
long long calculate(int x){  
    long long ans = 1;  
    while(x != 0){  
        ans *= (x % 10);  
        x /= 10;  
    }  
    return ans;  
}  
  
int main(void){  
    cin >> t;  
    while(t--){  
        cin >> l >> r;  
        if(r - l + 1 >= 10) cout << 0 << endl;  
        else{  
            res = 1;  
            for(; l <= r; l++){  
                res = res * calculate(l) % MOD;  
            }  
            res %= MOD;  
            cout << res << endl;  
        }  
    }  
}
```

## 杂题？
[P9642 SNCPC2019](https://www.luogu.com.cn/problem/P9642)
### 题解
翻转字符串，但是这个不一定是单个字符翻转，还可能是一整个子串一起翻转。因此不满足最优子结构性质(感觉？因为没办法建dp表)，需要想其他的办法

注意到：
```
69  ->  66, 99 两种
96  ->  99, 66 两种

996 -> 966,666,999,696
969 -> 966,696,999,669
699 -> 999,666,669,696

008 -> 008,080,800
080 -> 008,080,800
800 同理
```
感觉有个隐秘的性质：旋转子串后的组合类型与数字的位置无关，只跟数字的种类有关
那么将原本的关于位置的讨论转换为关于`0,8,6,9`四个数字的出现次数讨论
这里可以设想将每个数排排队，就变成了0...08...86...69...9，这样方便后面去重的时候思考如何去重

假设每个位置都能翻转出新的串，那么总共有：
$$\frac{n(n-1)}{2}+1$$
个串的种类(找几个样例推一推，一开始没理解+1，直接debug，然后后面题解说要考虑自身...)

>[!note] 注意
>这个地方注意，如果s的长度为$10^6$，那么会爆`int`，所以要开`long long`

我们需要对这些进行去重：
重复的情况有：
1. 头尾都是`0`
2. 头尾都是`8`
3. 头尾一个为`6`一个为`9`
*Q：为什么要去重*
```
eg.8096908

翻转 09690，得到8069608
翻转 969，得到8069608
```
结果一样，即对于$[l,r]$，若 $l$ 和 $r$ 满足以上三种情况之一，那么翻转后的结果等价于翻转$[l+1,r+1]$

1. 首，尾均为 0 的子串。
统计 0 字符数量 $𝑠𝑢𝑚_0$，不合法子串数量为
$$\frac{𝑠𝑢𝑚_0×(𝑠𝑢𝑚_0+1)}{2}$$
2. 首，尾均为 8 的子串。
统计 8 字符数量 $𝑠𝑢𝑚_8$，不合法子串数量为
$$\frac{𝑠𝑢𝑚_8×(𝑠𝑢𝑚_8+1)}{2}$$

3. 首，尾为 6,9 的字串。
统计 6,9 字符数量 $𝑠𝑢𝑚_6$,$𝑠𝑢𝑚_9$，不合法子串数量为 $𝑠𝑢𝑚6×𝑠𝑢𝑚9$。

> 但是有一种特殊情况我们需要考虑，即 𝑆 全为 6 或者 𝑆 全为 9。这样不论如何挑选子串，翻转后一定会出现新串，这会使得不合法的方案数多 1，最后需要减去(当时直接debug了)
> 试试这个样例：`66666`，你会发现程序算的是 16，但你自己会算出 15，因为这个字符串整个翻转不会得到原字符串，所以最后还要 −1。

```c++
#include<bits/stdc++.h>
using namespace std;

string s;
long long int len, sum, err;
long long int c_0, c_6, c_9, c_8;
int t;

int main(void){
	cin >> t;
	while(t--){
		cin >> s;
		sum = 0, err = 0, c_0 = 0, c_6 = 0, c_9 = 0, c_8 = 0;
		
		len = s.size();
		for(int i = 0; i < len ; i++){
			if(s[i] == '0') c_0++;
			else if(s[i] == '6') c_6 ++;
			else if(s[i] == '9') c_9 ++;
			else c_8 ++;
		}
		
		sum = len * (len + 1) / 2;
		err += c_0 * (c_0 + 1) / 2;
		err += c_8 * (c_8 + 1) / 2;
		err += c_6 * c_9;
		
		if(len == c_6 || len == c_9) err++;	
		
		cout << sum - err + 1 << endl;
	}
	
	return 0;
}
```

## 数据结构？
[A-An Easy Problem_GDCPC广东省大学生程序设计竞赛（正式赛）](https://ac.nowcoder.com/acm/contest/17797/A)
一个 $n * m$ 矩形，每个点 $(i,j)$ 权值为 $i*j$（面积）。要求第 $k$ 大的点的权值。
### 题解
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240509192353.png)
使用**优先队列**存下权值，我们想办法每次取出最大的那一个，那么取$k$次就是结果。
对于矩阵$n* m$，假设$n$行$m$列，我们先存下**每行最后一个**即$i* n$，每次取出最大那个，比如第一次就是$n* m$，然后再往里存下$n* (m-1)$，由于是优先队列每次`pop`出来的都是最大的那个，又因为$n* m>n* (m-1)$，因此这种方法每次都能取出最大的那个，取k次，最后取出的那个就是答案。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long 1l;

ll n, m, k;
typedef pair<ll,11>PII;
priority queue<PII> pr;

int main(void){
	cin >> n >>m >> k;
	PII re;

	for(int i = 1; i<= n; i++){
		re = {i * m, i};
		pr.push(re);
	}
	// 执行k次，最后一次即找到第k大的点权值
	while(k--){
		re = pr.top();
		pr.pop();
		pr.push({re.first - re.second, re.second});
	}
	cout << re.first;
	return 0;
}
```

> 当然这道题也有人用二分做出来了(没看太懂)：
> 我们知道每个数$x=i* j$，定义$f(x)$，表示**小于等于**$x$有几个数，这里因为$n$和$m$的限制导致一些数不会出现。
> 因为总数是$n* m$，那么我们可以去二分$x$，定义二分函数大小为$f(x)$，先假设k是第k小（这样子方便理解，和第$k$大转化一下很简单），那么$f(mid)>k$时，说明$mid$的位置在$k$后边，否则在前边或重合，当我们不断二分至$l \ge r$，说明此时$f(l)=k$，这里考虑到有些不存在的数会占用 $f$，但这里 $f$ 记录的是**小于等于**，所以如果有多个 $x$ 使 $f(x)$ 相同，$l$ 一定会是**最左边**那个，而最左边那个一定是存在的数。因此**此二分是合理**的。
> 接下来考虑 $f$ 的实现，考虑到$1 \le i \le n，1 \le j \le m$，并且$i*j=x$。那么我们枚举 $i$ 从1到n，累加上当前 $i$ 对应 $j$ 的数量，即$\min(m, x/i)$。最后**累加**的结果就是$f(x)$。

```c++
#include<iostream>
#define ll long long 
using namespace std;
ll n,m,k;
ll check(ll x){  
    ll ans=0;                    
    for(ll i=1;i<=n;i++){        
        ans+=min(x/i,m);
    }
    return ans;
}
int main(){
    cin>>n>>m>>k;
	ll l=1,r=n*m;
    while(l<r){        
        ll mid = (l+r)>>1;
        if(check(mid)>n*m-k){  
            r=mid;
        }
        else l=mid+1;
    }
    cout<<l<<'\n';
    return 0;
}
```

## 伪计算几何？
[I-Industrial Nuclear Water_GDCPC广东省大学生程序设计竞赛](https://ac.nowcoder.com/acm/contest/17797/I)
两个点代表两个国家，三个曲面代表障碍。现在要连通两个国家并且不通过障碍，要求判断能否成功通过。

### 题解
。。标准题解和我想的一样，把一个面拆成两个面，然后就直接判断，只有所有障碍均未经过才能成功通过
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240509195041.png)
```c++
#include<bits/stdc++.h>

typedef long long ll;

bool check(ll a, ll b, ll p){return 1000 * p < a * a + b * b;}
void solve(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2)
{
    bool flag = true;
    if(check(x1,y1,z1)!=check(x2,y2,z2))flag=0;
	if(check(x1,y1,-z1)!=check(x2,y2,-z2))flag=0;
	if(check(x1,z1,y1)!=check(x2,z2,y2))flag=0;
	if(check(x1,z1,-y1)!=check(x2,z2,-y2))flag=0;
	if(check(z1,y1,x1)!=check(z2,y2,x2))flag=0;
	if(check(z1,y1,-x1)!=check(z2,y2,-x2))flag=0;
	
	if(flag) std::cout<<"Yes\n";
	else std::cout<<"No\n";
}
int main()
{
    ll n;cin>>n;
    while(n--){
        ll x1,x2,y1,y2,z1,z2;
        cin>>x1>>y1>>z1>>x2>>y2>>z2;
        solve(x1,y1,z1,x2,y2,z2);
    }
    return 0;
}
```

