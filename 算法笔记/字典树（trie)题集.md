# [TJOI2010] 阅读理解
## 题目描述
英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。
## 输入格式
第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。
按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。
然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。
## 输出格式
对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。
## 样例 #1
### 样例输入 #1
```
3
9 you are a good boy ha ha o yeah
13 o my god you like bleach naruto one piece and so do i
11 but i do not think you will get all the points
5
you
i
o
all
naruto
```
### 样例输出 #1
```
1 2 3
2 3
1 2
3
2
```
## 提示
对于 $30\%$ 的数据， $1\le M\le 10^3$ 。
对于 $100\%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。
每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。
每个测试点时限 $2$ 秒。

【题解】
这题做崩溃了....卡了一个多小时...一直因为空间问题报错..
字典树的问题就是空间复杂度太大，如果直接根据每篇短文构造一棵trie树的话，那么就是$10000 \times 5000 \times 26 \times 4 \div 1024\div 1024 = 5000MB$，内存直接爆炸（这里崩溃了，开了三维数组，爆了一堆没见过的错误）

第二个大坑是没找到对应的单词的话也要输出一个空行....阿西吧我太蠢了，没有注意到这个问题

那么要怎么求解呢，这里一开始我想到了可以降维，没必要对`son`开个三维的数组（结果又因为开小了爆错...orz），只要对`cnt`这部分进行标记就可以了，如果有标记就代表这句话中有这个单词，但结果发现数组还是太大啊啊啊啊啊。于是只能去求助洛谷...发现有个布尔类型的数组`bitset`，可以大大压缩空间

`bitset`用法：[bitset用法小结](https://www.cnblogs.com/zwfymqz/p/8696631.html)

>`bitset<1001> cnt[500007];` 是一个数组的定义，其中每个元素是一个 `bitset<1001>` 对象。

>具体来说：
> - `bitset<1001>` 表示一个包含1001位的位集。
> - `cnt` 是数组的名字。
> - `[500007]` 指定了数组的大小，即该数组包含500007个元素。
> 因此，`bitset<1001> cnt[500007];` 定义了一个包含500,007个 `bitset<1001>` 对象的数组。你可以使用 `cnt[i]` 来访问第 i 个 `bitset<1001>` 对象（其中 $0 ≤ i < 500,007$）。每个 `cnt[i]` 都可以独立地进行位操作。

对应代码：
```c++
#include <bits/stdc++.h>  
#include <bitset>  
  
using namespace std;  

const int M = 300007;  
// 这里的数组必须要开大一些，不然会报RE，但是不知道为啥只开500007
int son[M][26], idx = 0;  
int n, m, l;  
char str[30];  
bitset<1001> cnt[500007];  
  
void insert(char str[], int i) {  
    int p = 0;  
    for (int i = 0; str[i]; i++) {  
        int u = str[i] - 'a';  // 将字母映射为数字
        if (!son[p][u]) son[p][u] = ++ idx;  // 对应位置为其id
        p = son[p][u];  // 给p记录id
    }  
    cnt[p][i] = 1;  
    // 这里用二维数组模拟一维数组的操作，因为二维转一维是(行-1)*列+列，  
    // 所以这里做了调整，先找p行，再找i列  
}  
  
void query(char str[]) {  
    int p = 0;  
    for (int j = 0; str[j]; j++) {  
        int u = str[j] - 'a';  
        if (!son[p][u]){            
	        cout << ' ' << endl;  // 题目要求没有找到也要空行！！！  
            return;  
        }  
        p = son[p][u];  // 不断往下找，直到找到p的结尾对应id
    }  
    for (int i = 1; i <= n; i++) {  
        if (cnt[p][i] == 1) {  // 如果这个id对应的第i棵trie树上面有标记，就将i输出
	        cout << i << ' ';  
        }  
    }  
    cout << endl;  
}  
  
int main(void) {  
    std::ios::sync_with_stdio(false);  // 减小读取时间
    cin >> n;  // 读取有多少篇短文
    for (int i = 1; i <= n; i++) {  
        cin >> l;  // 每篇短文单词数量
        while (l --) {  
            cin >> str;  // cin读不会读到空格，很适合字符串
            insert(str, i);  
        }  
    }  
    cin >> m;  
    while (m--) {  
        cin >> str;  
        query(str);  
    }  
}
```
