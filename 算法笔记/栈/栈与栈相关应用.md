对于栈这一简单的数据结构，为了提高效率，常常采用静态数组进行模拟，对于数据量较小的题目，也可以直接使用STL库中的`stack<type>`进行模拟：

# 相关代码
**简单的伪代码：**
```c++
#include<iostream>
using namespace std;

const int N = 100010;

int stk[N], tt;
// 插入
stk[tt++] = x;
// 弹出
tt--;

// 判断栈是否为空
if(tt > 0) not empty;
else empty;

// 栈顶
stk[tt];
```

完整代码：
```c++
#include<iostream>
using namespace std;

const int N = 100010;
int M, x;
int stk[N];
string s; 

int main(void){
    int bottom = 0, top = -1; // 这个地方top = -1的原因是top始终指向栈顶，而非栈顶下一个元素
    cin >> M;  
    while(M--){
        cin >> s;  // cin 可以直接读入字符串哎
        if(s == "push") {
            cin >> x;
            stk[++top] = x;
        }else if(s == "query") printf("%d\n", stk[top]);
        else if(s == "pop") stk[top--];
        else{
            if(bottom > top) printf("YES\n");
            else printf("NO\n");
        }
    }
}
```

## 例题
### Acwing 3302 表达式求值
【题目描述】给定一个表达式，其中运算符仅包含 `+,-,*,/`（加、减、乘、整除），可能包含括号，请你求出表达式的最终值。
**输入样例：** 
`(2+2)*(1+1)`
**输出样例：**
`8`

【题解】
*两个核心关键点：*
（1）**双栈**，一个操作数栈，一个运算符栈；
（2）**运算符优先级**，*栈顶运算符* 和 *即将入栈的运算符*的优先级比较：
	1. 如果栈顶的运算符优先级低，新运算符直接入栈
	2. 如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈
对于各运算符优先级，可以使用`unordered_map`进行存储
***注意：需要考虑到输入的数字可能不为个位数，需要对输入数字的位数进行判断***

【参考代码】
```c++
#include <bits/stdc++.h>  
using namespace std;  
  
stack<int>num;  // 构造数字栈  
stack<char>op;  // 构造运算符栈  
  
unordered_map<char, int> h{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};  
// 使用unordered_map记录各个运算符的优先级  
// 对于为定义的'('符号，unordered_map会自动设置其对应的value为0  
  
void compute() {  
    int b = num.top(); // 第二个运算数  
    num.pop();  
  
    int a = num.top(); // 第一个运算数  
    num.pop();  
  
    char op1 = op.top();  // 运算符号  
    op.pop();  
  
    if (op1 == '+') a += b;  
    if (op1 == '-') a -= b;  
    if (op1 == '*') a *= b;  
    if (op1 == '/') a /= b;  
  
    num.push(a);  
}  
  
int main(void) {  
    string s;  // 读入整个字符串  
    cin >> s;  
    for (int i = 0; i < s.size(); i++) {  
        if (isdigit(s[i])) {  
            int x = 0, j = i;  
            while (j < s.size() && isdigit(s[j])) {  
                x = (x * 10) + (s[j] - '0');  // 注意这里'\0'和'0'是不一样的！'\0'对应ascii码第0位！  
                j++; // 内层循环到最后时，会让j多一位，所以这个地方要退后一位  
            }  
            num.push(x);  // 将含有超过个位数的数字入栈  
            i = j - 1; // 这里因为 j 前进了，所以i也要跟着换位置  
        } else if (s[i] == '(') op.push(s[i]); // 将左括号入栈  
        else if (s[i] == ')') {  
            while (op.top() != '(') compute(); // 没到左括号，则一直令运算符出栈  
            op.pop();  // 左括号出栈  
        } else {  
            while (op.size() && h[op.top()] >= h[s[i]]) compute();  
            op.push(s[i]);  // 新的操作符入栈  
        }  
    }  
    while (op.size() != 0) compute();  
    cout << num.top() << endl;  
}
```

对应习题：
![[栈刷题#[NOIP2013 普及组] 表达式求值]]
# 单调栈
![[算法基础课#单调栈]]

对应习题：
![[栈刷题#[USACO09MAR] Look Up S]]

