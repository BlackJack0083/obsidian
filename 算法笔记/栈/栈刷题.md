# [USACO09MAR] Look Up S

## 题目描述
约翰的 $N(1\le N\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\le H_i\le10^6)$。现在，每只奶牛都在向右看齐。对于奶牛 $i$，如果奶牛 $j$ 满足 $i<j$ 且 $H_i<H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。
## 输入格式
第 $1$ 行输入 $N$，之后每行输入一个身高 $H_i$。

## 输出格式
共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。

## 样例 #1
### 样例输入 #1
```
6 
3 
2 
6 
1 
1 
2
```
### 样例输出 #1
```
3 
3 
0 
6 
6 
0
```

## 提示
【输入说明】$6$ 头奶牛的身高分别为 3,2,6,1,1,2。
【输出说明】奶牛 #1,#2 仰望奶牛 \#3，奶牛 #4,#5 仰望奶牛 # 6， #3 和 #6 没有仰望对象。
【数据规模】
对于 $20\%$ 的数据：$1\le N\le10$；
对于 $50\%$ 的数据：$1\le N\le10^3$；
对于 $100\%$ 的数据：$1\le N\le10^5,1\le H_i\le10^6$。

【题解】

本题采用可**采用单调栈**进行求解，对数组从后向前遍历，栈顶的奶牛最矮，栈底的最高
首先，最后一个人必然没有向右看齐的人的编号 ，故ans = 0
先将最右边的人加入栈 
接着，我们发现1，1比2小，先加入栈，当前ans值为6  
接着，又来了一个1，发现1=1，弹出1，接着发现1<2,则将1加进栈，当前ans值为6  
接着，来了一个6，6>1，弹出1，6>2, 弹出2，当前栈空，ans值为0 ，将6压入
接着，来了一个2，2<6，加入2，当前ans值为3  
最后，来了一个3，3>2，弹出2，3<6，将3加入栈，当前ans值为3  
最后的栈中有3和6  
最后的答案就是3 3 0 6 6 0  
每次只在栈中存数字标号，进来一个数，就把小于等于他的数全部弹出，若剩下有数，则答案是剩下的数，否则答案是0

```c++
#include <bits/stdc++.h>

using namespace std;

int stk[1000100], a[1000100], ans[1000100], n, tt;

int main(void) {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = n ; i >= 1; i--) { // 从后向前遍历数组
		while (tt && a[stk[tt]] <= a[i]) tt--;  // 这里用while循环不断弹栈
		if (tt) ans[i] = stk[tt];  // 栈非空则ans为当前值
		else ans[i] = 0;  // 否则找不到
		stk[++tt] = i;  // 最后将当前值压入栈中
	}
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << endl;
	}
}
```

# [NOIP2013 普及组] 表达式求值
## 题目描述
给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。
## 输入格式
一行，为需要你计算的表达式，表达式中只包含数字、加法运算符 “$+$” 和乘法运算符 “$\times$”，且没有括号，所有参与运算的数字均为 $0$ 到   $2^{31}-1$ 之间的整数。  
输入数据保证这一行只有 $0\sim 9$、$+$、$\times$ 这 $12$种字符。
## 输出格式
一个整数，表示这个表达式的值。  
注意：当答案长度多于 $4$ 位时，请只输出最后 $4$ 位，前导 $0$ 不输出。
## 样例 #1
### 样例输入 #1
```
1+1*3+4
```
### 样例输出 #1
```
8
```
## 样例 #2
### 样例输入 #2
```
1+1234567890*1
```
### 样例输出 #2
```
7891
```
## 样例 #3
### 样例输入 #3
```
1+1000000003*1
```
### 样例输出 #3
```
4
```
## 提示
对于 $30\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100$。
对于 $80\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤1000$。
对于 $100\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100000$。

【题解】
唔对于这种题目，最容易想到的可能就是用栈解决(数据结构习惯了)，不过这里有个两个限制条件，第一个是数据范围，$2^{31}-1$，需要使用`long long int` 类型存储；第二个是只输出最后四位，说明要对数据进行处理，这里直接对$10000$取模即可，但是注意要在*每次计算和读入都要取模*，不然很容易爆数据范围....因为这个问题RE了好多次....
读入数据这个地方感觉还是很多学问....这里的读入是模仿AcWing大佬题解写的，不过看到cin好像可以直接读数字和字符...因为这里没有括号，除了第一次是`数字+字符+数字`，后面都是`字符+数字`的形式，所以可以对读入过程进行优化，先读入第一个数字，然后后面用`while`循环读入即可
```c++
#include <bits/stdc++.h>  
using namespace std;  
  
long long int num[1000010];  
char op[100010];  
int tt1, tt2;  
  
unordered_map<char, int > h{{'+', 1}, {'*', 2}};  // 用一个mao存放优先级匹配
  
void compute() {  
    long long int b = num[tt1--];  
    long long int a = num[tt1--];  
    char op1 = op[tt2--];  
    
    if (op1 == '+') num[++tt1] = (a + b) % 10000;  // 每次计算都要取模，不然会爆 
    if (op1 == '*') num[++tt1] = (a * b) % 10000;  
}  
  
int main(void) {  
    string s;  
    cin >> s;  
    for (int i = 0; i < s.size(); i++) {  
        if (isdigit(s[i])) {  
            int j = i;  
            unsigned long long int x = 0;  
            while (j < s.size() && isdigit(s[j])) {  
                x = x * 10 + s[j] - '0';  
                j++;  
            }  
            num[++tt1] = x % 10000;  
            i = j - 1;  // 注意要调整 i 的位置
        } else {  
            while (tt2 && h[op[tt2]] >= h[s[i]]) compute();  
            op[++tt2] = s[i];  
        }  
    }  
    while (tt2) compute();  // 对剩余运算符进行计算 
    printf("%lld", num[tt1]);  // 最后只剩下一个结果，直接输出
}
```

【补充】
在洛谷上看见了佬的回答，感觉很牛，用刚刚提到的`字符+数字`方式循环读入，然后对于含有一段连续的乘积运算(比如`++***++`这种形式)，用一个独立的变量`cj`进行存储，用`xg`和`ch`的次序关系解决优先级问题，不过不是很直观...
![[微信图片_20231117121341.jpg|500]]
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    long long shu, sum=0, cj;
    //记得sum初始值赋为0；cj为其中一段运算（即一段连续的乘积）的值
    char ch = 0, xg;  //ch存储上一个运算符，xg为新读入的运算符
    bool tf = true;
    while(tf)
    {
        scanf("%lld", &shu);
        tf = scanf("%c", &xg) == 1 ? true : false;
        //如果下一个没有运算符了，则tf=false，既保证了此次循环的正常运行，又能在下一遍循环跳出
        if(ch == 0) cj = shu;  //如果是刚开始读入，则直接赋值
        else if(ch == '+') sum = (sum + cj) % 10000, cj = shu;
        //如果上一个操作是加法，则将前一段的值加入到sum中，然后再更新此新段的值
        else if(ch == '*') cj = (cj * shu) % 10000;
        //如果上一个运算仍是乘法，则将此数乘入本段的值中
        if(!tf) sum = (sum + cj) % 10000;
        //如果是最后一个元素，则进行最后的更新
        ch = xg;//将下一个读入的运算符作为新的一个循环的上一个运算符，并继续循环
    }
    printf("%lld", sum);//输出
    return 0;
}
```

# 后缀表达式(洛谷P1449，非常简单)
## 题目描述
所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。
如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。
## 输入格式
输入一行一个字符串 $s$，表示后缀表达式。
## 输出格式
输出一个整数，表示表达式的值。
### 样例输入 #1
```
3.5.2.-*7.+@
```
### 样例输出 #1
```
16
```
## 提示
数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。
【题解】
这道题明显简单很多，因为这个后缀表达式只有 `+ - * /`操作(甚至没有括号)，比pta作业还简单，这道题就不需要再用栈存运算符了，可以边把数存入栈中一边计算
```c++
#include <bits/stdc++.h>  
using namespace std;  
  
int num[100010], tt;  
  
void compute(char ch) {  
    int b = num[tt--];  
    int a = num[tt--];  
    int x;  
    if (ch == '+') x = a + b;  
    else if (ch == '-') x = a - b;  
    else if (ch == '*') x = a * b;  
    else if (ch == '/') x = a / b;  
    num[++tt] = x;  
}  
  
int main(void) {  
    char ch;  
    ch = getchar();  
    while (ch != '@' && ch != '\n' && ch != EOF) {  
        if (isdigit(ch)) {  
            int x = 0;  
            while (ch != '.') {  
                x = x * 10 + ch - '0';  
                ch = getchar();  
            }  
            num[++tt] = x;  
        } else compute(ch);  
        ch = getchar();  
    }  
    printf("%d", num[tt]);  
}
```

