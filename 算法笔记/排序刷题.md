### 求逆序对数量（唔感觉就是求逆序数）
![[微信截图_20230712084951.png]]
学习下大佬的思路：

#### 题解
解决一个问题的第一步是**定义清楚问题**。

首先我们给出**逆序对的定义**：
对于数列的第 i 个和第 j 个元素，如果满足 i < j 且 a[i] > a[j]，则其为一个逆序对。
重要的地方在于，**一个元素可以不只是在一个逆序对中存在**。如果 k > j > i 且 a[i] > a[j] > a[k]，那么这里
有两个含 a[i] 的逆序对，分别是 (a[i], a[j]) 和 (a[i], a[k]), a[i]是可以使用多次的。

那么第二步是分析问题，这里我们可以**使用分治法**解决问题。

我们将序列从中间分开，将逆序对分成三类：

两个元素都在左边；
两个元素都在右边；
两个元素一个在左一个在右；
因此这就是我们算法的大致框架：

计算逆序对的数量（序列）：
1. 递归算左边的；
2. 递归算右边的；
3. 算一个左一个右的；
4. 把他们加到到一起。

这个时候我们注意到一个很重要的性质，**左右半边的元素在各自任意调换顺序，是不影响第三步计数的**，因此我们可以**数完就给它排序**。这么做的好处在于，如果序列是有序的，会让第三步计数很容易。
如果无序暴力数的话这一步是O(n^2)的。

比如序列是这样的
4 5 6 | 1 2 3

当你发现 4 比 3 大的时候，也就是说**右边最大的元素都小于左边最小的元素**，那么**左边剩下的5和6都必然比右边的所有元素大**，因此就可以不用数5和6的情形了，**直接分别加上右半边的元素个数就可以了**，这一步就降低到了
O(n), 我们知道递归式 $T(n) = 2T(n/2)+O(n) = O(nlogn)$的，所以排序的成本是可以接受的，并且这一问题下，
可以很自然地使用归并排序。

这里还要注意下数据结构的问题，要用long long 不然会因为数据量过大报错
```c++
#include <stdio.h>

const int  N = 100001;
long long int temp[N];
long long int count = 0;

void merge_sort(long long int a[], long long int l, long long int r){
    if(l >= r) return;
    
    // 这里j=mid+1!! 不要搞错了
    long long int mid = l + r >> 1, k = 0, i = l , j = mid + 1;
    
    merge_sort(a, l, mid);
    merge_sort(a, mid+1, r);
    
    while(i <= mid && j <= r){
        if(a[i] <= a[j]) temp[k++] = a[i++];
        else {
            temp[k++] = a[j++];
            // 注意这里，是直接加的，后面的不需要比较了
            count += (mid - i + 1);
        }
    }
    
    while(i <= mid) temp[k++] = a[i++];
    while(j <= r) temp[k++] = a[j++];
    
    k = 0;
    while(l <= r) a[l++] = temp[k++];
    
}

int main(void){
    int n;
    scanf("%d", &n);
    long long int a[n];
    for(int i = 0; i < n; i++)
        scanf("%lld", a + i);
    merge_sort(a, 0, n-1);
    printf("%lld", count);
}
```