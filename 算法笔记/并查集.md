# 蓝桥杯 2017 国 C 合根植物
## 题目描述
w 星球的一个种植园，被分成 $m \times n$ 个小格子（东西方向 $m$ 行，南北方向 $n$ 列）。每个格子里种了一株合根植物。
这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。
如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？
## 输入格式
第一行，两个整数 $m$，$n$，用空格分开，表示格子的行数、列数（$1<m,n<1000$）。
接下来一行，一个整数 $k$，表示下面还有 $k$ 行数据 $(0<k<10^5)$。
接下来 $k$ 行，每行两个整数 $a$，$b$，表示编号为 $a$ 的小格子和编号为 $b$ 的小格子合根了。
格子的编号一行一行，从上到下，从左到右编号。
比如：$5 \times 4$ 的小格子，编号：
```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
17 18 19 20
```
## 输出格式
一行一个整数，表示答案
## 样例 #

### 样例输入 #1
```
5 4
16
2 3
1 5
5 9
4 8
7 8
9 10
10 11
11 12
10 14
12 16
14 18
17 18
15 19
19 20
9 13
13 17
```
### 样例输出 #1
```
5
```
## 样例解释

![](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/9q0xulxh.png)

### 题解
很模板的并查集，呃但是太久没写不记得了...得要记得背板子！！！
注意并查函数怎么写！！
查看有多少个并查集只需要遍历一次，如果父亲节点为本身就代表这是一个块
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1000010;

int p[N];
int n, m, k, a, b, ans;

// 并查集
int find(int x){
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}

int main(void){
	cin >> n >> m;
	n = n * m;
	for(int i = 1; i <= n; i++) p[i] = i;
	
	cin >> k;
	while(k--){
		cin >> a >> b;
		p[find(a)] = find(b);
	}
	
	// 最后查个数
	// 由于一开始设置 p[i] = i，因此最后如果循环时仍然p[i]=i，那么说明根为自己，那么就是一个块
	for(int i = 1; i <= n; i++)
		if(p[i] == i) ans++;
	
	cout << ans << endl;
	return 0;
}
```

