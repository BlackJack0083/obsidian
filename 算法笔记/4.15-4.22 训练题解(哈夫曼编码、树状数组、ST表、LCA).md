- [哈夫曼编码](#哈夫曼编码)
- [ST表 P3865](#ST表 P3865)
[[4.15-4.22 训练题解(哈夫曼编码、树状数组、ST表、LCA)#树状数组|树状数组]]
[[4.15-4.22 训练题解(哈夫曼编码、树状数组、ST表、LCA)#LCA|倍增法求LCA]]
# 哈夫曼编码

## poj 1521 Entropy
输入：一个字符串，分别用ASCII和哈夫曼编码
输出：两种编码的长度，以及它们的压缩比
### 输入样例
```
AAAAABCD
THE_CAT_IN_THE_HAT
END
```
### 输出样例
```
64 13 4.9
144 51 2.8
```
### 题解
吐槽：
阿西吧受不了poj了，怎么会有不支持万能头文件的oj啊啊啊
它究竟是C++多少版本的啊啊啊，为什么连字符的`!=`都会报错啊

这道题难度不大，就是有点难绷，要注意的是：
1. 下划线也算字符.....
2. 如何一次读入一行字符串(记不住...)
3. 优先队列没有`clear()`方法，需要在每次计算完`ans2`后通过`pop()`手动清空
4. 当字符串中均为同一字符时，哈夫曼编码长度就是该字符的频次
5. 里面最妙的是如何**计算哈夫曼编码的长度**，以前因为都是手画所以没有注意过这个性质:
	哈夫曼编码长度$$length=\sum_i p_i \times i.length$$
	其中，$p_i$为该字符出现的频次，$i.length$为该字符的哈夫曼编码长度
	但是，实际上这个可以化成另一种形式：
	如样例1: A=5, B=C=D=1
	可以画出对应的哈夫曼树![bcbe526fc2d200cf55bf314f5d0fd20.jpg|225](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/bcbe526fc2d200cf55bf314f5d0fd20.jpg)
	发现$length$恰好为所有父节点的权值之和。于是可以得到以下结论$$length(WPL)=\sum_i 字母出现次数 \times 该字母所在的树的深度 = \sum 叶节点的父节点的值总和$$
	叶节点的父节点的值的总和即为每次`pop`时得到的`a+b`进行求和
	由此反推，该字符的编码长度即为进入队列的次数，每进入一次队列就需要进行一次`pop`得到`a+b`这一父节点的权值
```c++
#include<bits/stdc++.h>

using namespace std;

priority_queue<int, vector<int>, greater<int>> pr;
string s;
int ct[27];
int ans1, ans2;

int main(void){
	// 又卡输入方式...
	while(getline(cin, s) && s != "END"){
		// 给数组清空
		memset(ct, 0, sizeof ct);
		ans1 = 0;
		ans2 = 0;
		// pr.clear(); 难绷，优先队列不能直接清空
		
		for(int i = 0; i < s.size(); i++){
			// 难绷，下划线也算字符
			if(s[i] == '_') ct[26] ++;
			else{
				// 统计频次
				ct[s[i] - 'A'] ++;
			}
			// 在这里进行ascii码计数
			ans1 += 8;
		}
		
		for(int i = 0; i < 27; i++)
			if(ct[i] != 0) pr.push(ct[i]);

		/* 题解的简单处理方法：
		for(int i = 1; i <= s.length(); i++){
			if(s[i] != s[i-1]) {q.push(num); num = 1;}
			else num ++;
		}
		*/
			
		if(pr.size() == 1) ans2 = pr.top();
		
		// 最后会剩下1个节点
		while(pr.size() > 1){
			// 将权值最小的合并
			int a = pr.top(); pr.pop();
			int b = pr.top(); pr.pop();
			pr.push(a + b);
			// 妙手：一个字符入几次队列，就累加几次。入一次队列，表示它在二叉树上深了一层，编码长度+1
			// 之前确实没有考虑过编码长度与进入队列次数的关系
			ans2 += a + b;
		}
		// 最后把这个节点pop掉作为清空
		pr.pop();
		
		printf("%d %d %.1f\n", ans1, ans2, (double)ans1 / (double)ans2);
		
	}
	return 0;
}
```

# 荷马史诗(k叉哈夫曼编码) P2168
输入：
- 第一行 $n, k$ 表示有$n$种单词，$k$进制进行转换
- 后面$n$行输入单词的频次
输出：
- 第一行输出《荷马史诗》经过重新编码以后的最短长度
- 第二行输出保证最短总长度的情况下，最长字符串 $s_i$​ 的最短长度。
### 样例输入 #1
```
4 2
1
1
2
2
```
### 样例输出 #1
```
12
2
```
### 样例输入 #2
```
6 3
1
1
3
3
9
9
```
### 样例输出 #2
```
36
3
```
#### 样例 1解释
用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。
一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：
$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$
最长字符串 $s_i$ 的长度为 $2$ 。
一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：
$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$
最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。
#### 样例 2 解释
一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

### 问题
- 乍一看好像是二叉哈夫曼的进阶，但是又出现了问题：$k$叉的话要怎么编码？
- $s_i$的最短长度是什么？

### 题解
k叉的问题一开始想着很简单，就是跟二叉差不多，只是多`pop`几次。但是发现当节点数量少于`k`的时候就没办法再进行`pop`了，处理起来会比较困难。
一开始没什么头绪(设了两个`while`调了半天没有好的结果...)，看了题解才明白可以用权值为0的点来补。
#### 补点
**定理**：一棵不满的k叉树不可能对应一个最优前缀码(证明见《算法导论》练习16.3-2 答案)
> 介绍一下「补点」：
> 首先，我们每次合并用掉$k$个值又合并出$1$个值，那么按每次合并来算，我们每次用掉了$k−1$个值。
> 然后，我们最终需要只剩$1$个值，即需要合并$n−1$个值。那么我们只需要让$(n−1)\%(k−1)=0$成立不就行了吗？
> 但要使$(n−1)\%(k−1)=0$成立，我们还需要补$(k−1)−((n−1)\%(k−1))$个点。
> 要使答案不受影响，我们就用权值为0的点来补

这里其实暗含了点意味，就是要把这个哈夫曼树给补满
一开始我的两个`while`的问题就是当`size < k`时候`pop`的值可能不是最优的
苦逼代码:
```c++
while(tree.size() >= k){
	sum1 = 0;
	maxh = -1;
	
	for(int i = 1; i <= k; i++){
		sum1 += tree.top().w;
		// 找最大编码长度
		maxh = max(maxh, tree.top().h);
		tree.pop();
	}
	
	tree.push((node){sum1, maxh + 1});
	
	ans1 += sum1;
	ans2 = max(maxh, ans2);
}

ll s = tree.size();
// 当时想的是如果没超就都pop出来嘛，但是会WA
while(tree.size() > 1){
	sum1 = 0;
	maxh = -1;
	
	for(ll i = 1; i <= s; i++){
		sum1 += tree.top().w;
		// 找最大编码长度
		maxh = max(maxh, tree.top().h);
		tree.pop();
	}
	
	tree.push((node){sum1, maxh + 1});
	
	ans1 += sum1;
	ans2 = max(maxh, ans2);
}
```
正确代码：
```c++
if((n - 1) % (k - 1) != 0){  
	x = (k - 1) - ((n - 1) % (k - 1));  
	for(int i = 1; i <= x; i++)  
		tree.push((node){0, 1});  
}  
	ll sum1, maxh;  
while(tree.size() > 1){  
	sum1 = 0;  
	maxh = -1;  
			for(int i = 1; i <= k; i++){  
		sum1 += tree.top().w;  
		// 找最大编码长度  
		maxh = max(maxh, tree.top().h);  
		tree.pop();  
	}  
			tree.push((node){sum1, maxh + 1});  
			ans1 += sum1;  
	ans2 = max(maxh, ans2);  
}
```

$s_i$的最短长度：实际上哈夫曼编码后得到的长度就是最短的，因此只需要在进行编码的时候补充上高度或者长度的记录信息即可在编码过程中存储下来对应的长度，最后取`max`，得到的就是最长的字符串的最短长度

代码：
```c++
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
// 这里因为需要同时得到全文编码后最短长度和最长字符串的最短长度，  
// 所以需要用结构体进行存储
typedef struct node{
    // w为权值，h为高度(由上一题知就是字符串长度)
	ll w, h;
    // 运算符重载，先比较权值，再比较高度
	bool operator < (const node &x) const{
		if(w != x.w) return w > x.w;
		return h > x.h;
	}
}node;

priority_queue<node>tree;

ll n, k, ans1, ans2, x;

int main(void){
	cin.tie(0); // 提高读入速度
	cout.tie(0);
	ios::sync_with_stdio(false); //提高读入速度
	
	cin >> n >> k;
	
	for(int i = 0; i < n; i++){
		cin >> x;
		tree.push((node){x, 1});
		//默认高度为1（这里的强制类型转换有点麻烦）
	}
	//先检测，如果不是0才进入判断
	if((n - 1) % (k - 1) != 0){
		// 求出要补的结点个数
		x = (k - 1) - ((n - 1) % (k - 1));
		// 妙手：补权值为0点
		for(int i = 1; i <= x; i++)
			tree.push((node){0, 1});
	}
	
	ll sum1, maxh;
	//因为不可能是负数，所以只要大于1个点就跑
	while(tree.size() > 1){
		sum1 = 0;
		maxh = -1;
		//每次选出k个值
		for(int i = 1; i <= k; i++){
			sum1 += tree.top().w;
			// 找最大编码长度
			maxh = max(maxh, tree.top().h);
			tree.pop();
		}
		
		tree.push((node){sum1, maxh + 1});
		//加上合并的值，这里不直接用ans1、ans2的好处就体现出来了
		ans1 += sum1;
		ans2 = max(maxh, ans2);
	}

    cout << ans1 << endl << ans2 << endl;  
    return 0;  
}
```
# ST表 P3865
ST 表是用于解决 **可重复贡献问题** 的数据结构
>[!note] 可重复贡献问题 
>是指对于运算 $\operatorname{opt}$，满足 $x\operatorname{opt} x=x$，则对应的区间询问就是一个可重复贡献问题。例如，最大值有 $\max(x,x)=x$，gcd 有 $\operatorname{gcd}(x,x)=x$，所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外，$\operatorname{opt}$ 还必须满足结合律才能使用 ST 表求解。

题目大意：给定 $n$ 个数，有 $m$ 个询问，对于每个询问，你需要回答区间$[l,r]$ 中的最大值。
考虑暴力做法。每次都对区间 $[l,r]$ 扫描一遍，求出最大值。
显然，这个算法会**超时**。

## ST 表
>ST 表基于 **倍增** 思想，可以做到 $\Theta(n\log n)$ 预处理，$\Theta(1)$ 回答每个询问。但是**不支持修改**操作。
>基于倍增思想，我们考虑如何求出区间最大值。可以发现，如果按照一般的倍增流程，每次跳 $2^i$步的话，询问时的复杂度仍旧是 $\Theta(\log n)$，并没有比线段树更优，反而预处理一步还比线段树慢。
>我们发现 $\max(x,x)=x$，也就是说，区间最大值是一个具有「可重复贡献」性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。
>如果手动模拟一下，可以发现我们能使用**至多两个**预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至 $\Theta(1)$，在处理有大量询问的题目时十分有效。

总体思想：
1. 数列按倍增分为小区间
2. 查询任意区间的最值

**具体实现**如下：
令 $f(i,j)$ 表示区间 $[i,\ i+2^j-1]$ 的最大值。
显然 $f(i,0)=a_i$
这样子就将数列的每个元素按照从它开始的数列分成了长度为1，2，4，8...的小区间
![340ac2dd5402b35533a2e5988ca73e4.jpg](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/340ac2dd5402b35533a2e5988ca73e4.jpg)

根据定义式，第二维就相当于倍增的时候「跳了 $2^j-1$ 步」，依据倍增的思路，写出状态转移方程：$f(i,j)=\max(f(i,j-1),f(i+2^{j-1},j-1))$，可以通过移位表示为$f(i,j) = \max(f(i,j-1),f(i+ 1 <<(j-1),(j-1))$
![image.png|475](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240417180224.png)

以上就是预处理部分。
而对于查询，可以简单实现如下：
对于每个询问 $[l,r]$，我们把它分成长度相等的两部分：$[l,l+2^s-1]$ 与 $[r-2^s+1,r]$，其中$s=\left\lfloor\log_2(r-l+1)\right\rfloor$，$r-l+1$即为区间长度，$s$即为取$log$后得到的对应的$f$层数。两部分的结果的最大值就是回答。这样子的结果即为$\max(f(l,s),f(r-(1<<s)+1,s))$
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240417180911.png)
根据上面对于「可重复贡献问题」的论证，由于最大值是「可重复贡献问题」，重叠并不会对区间最大值产生影响。又因为这两个区间完全覆盖了 $[l,r]$，可以保证答案的正确性。

注意，对于$log$的倍增，一般常用提前算出的数组，可以减少调用函数次数
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+5;
int n, m;
// a用于存初始值，dp用于存经处理后得到的区间最大值
// 22 是因为2^21 非常大，这样无论怎样都不会
int a[N], dp[N][22];
int LOG2[N];

void st_init(){
	LOG2[0] = -1;
	// 手写 log2数组
	for(int i = 1; i<= N; i++) LOG2[i] = LOG2[i >> 1] + 1;
	// 初始化区间长度为1的值
	for(int i = 1; i <= n; i++) dp[i][0] = a[i];

	int p = LOG2[n];
	//int p = log2(n);
	// 构造dp
	for(int k = 1; k <= p; k++){
		for(int s = 1; s + (1 << k) <= n + 1; s++){
			// 对两个长度一样，可以将整个查询范围包括的子数组进行查询，找到里面的最大值
			dp[s][k] = max(dp[s][k-1], dp[s + (1 << (k-1))][k - 1]);
		}
	}
}

int st_query(int l, int r){
	// 通过长度转换到对应的k需要多长
	int k = LOG2[r - l + 1];
	//int k = log2(r - l + 1);
	// 这样就变成了两个数之间的比较
	int x = max(dp[l][k], dp[r - (1 << k) + 1][k]);
	return x;
}

int main(void){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	st_init();
	
	int l, r;
	while(m--){
		scanf("%d%d", &l, &r);
		printf("%d\n", st_query(l, r));
	}
	
	return 0;
}
```

# 树状数组
> 本节介绍摘自 oi wiki

树状数组是一种支持 **单点修改** 和 **区间查询** 的，代码量小的数据结构。

普通树状数组维护的信息及运算要满足 **结合律** 且 **可差分**，如加法（和）、乘法（积）、异或等。
结合律：$(x \circ y) \circ z = x \circ (y \circ z)$，其中 $\circ$是一个二元运算符。
可差分：具有逆运算的运算，即已知 $x \circ y$ 和 $x$可以求出 $y$。

事实上，树状数组能解决的问题是线段树能解决的问题的子集：树状数组能做的，线段树一定能做；线段树能做的，树状数组不一定可以。然而，树状数组的代码要远比线段树短，时间效率常数也更小，因此仍有学习价值。

有时，在差分数组和辅助数组的帮助下，树状数组还可解决更强的 **区间加单点值** 和 **区间加区间和** 问题。

### 初步感受
先来举个例子：我们想知道 $a[1 \ldots 7]$ 的前缀和，怎么做？
一种做法是：$a_1 + a_2 + a_3 + a_4 + a_5 + a_6 + a_7$，需要求 **7 个数的和**。
但是如果已知三个数 A，B，C，$A = a[1 \ldots 4]$ 的和，$B = a[5 \ldots 6]$ 的总和，$C = a[7 \ldots 7]$ 的总和（其实就是 $a[7]$ 自己）。你会怎么算？你一定会回答：$A + B + C$，只需要求 3 个数的和。

这就是树状数组能快速求解信息的原因：我们总能将一段前缀 $[1, n]$ 拆成 **不多于** $\boldsymbol{\log n}$ 段区间，使得这 $\log n$ 段区间的信息是 **已知的**。

于是，我们只需合并这 $\log n$ 段区间的信息，就可以得到答案。相比于原来直接合并 n 个信息，效率有了很大的提高。
不难发现信息必须满足结合律，否则就不能像上面这样合并了。
下面这张图展示了树状数组的工作原理：
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240418161104.png)
最下面的八个方块代表原始数据数组 a。上面参差不齐的方块（与最上面的八个方块是同一个数组）代表数组 $a$ 的上级——$c$ 数组(《算法竞赛》一书写为`tree`数组)。

$c$ 数组就是用来储存原始数组 $a$ **某段区间的和**的，也就是说，这些区间的信息是已知的，我们的目标就是把**查询前缀拆成这些小区间**。

例如，从图中可以看出：
$c_2$ 管辖的是 $a[1 \ldots 2]$；
$c_4$ 管辖的是 $a[1 \ldots 4]$；
$c_6$ 管辖的是 $a[5 \ldots 6]$；
$c_8$ 管辖的是 $a[1 \ldots 8]$；
剩下的 $c[x]$ 管辖的都是 $a[x]$自己（可以看做 $a[x \ldots x]$ 的长度为 1 的小区间）。
不难发现，$c[x]$ 管辖的一定是一段**右边界**是 $x$ 的区间总信息。我们先不关心左边界，先来感受一下树状数组是如何查询的。

举例：计算 $a[1 \ldots 7]$ 的和。
过程：从 $c_{7}$ 开始往前跳，发现 $c_{7}$ 只管辖 $a_{7}$ 这个元素；然后找 $c_{6}$，发现 $c_{6}$ 管辖的是 $a[5 \ldots 6]$，然后跳到 $c_{4}$，发现 $c_{4}$ 管辖的是 $a[1 \ldots 4]$ 这些元素，然后再试图跳到 $c_0$，但事实上 $c_0$不存在，不跳了。

我们刚刚找到的 $c$ 是 $c_7, c_6, c_4$，事实上这就是 $a[1 \ldots 7]$拆分出的三个小区间，合并得到答案是 $c_7 + c_6 + c_4$。

举例：计算 $a[4 \ldots 7]$ 的和。

我们还是从 $c_7$ 开始跳，跳到 $c_6$ 再跳到 $c_4$。此时我们发现它管理了 $a[1 \ldots 4]$ 的和，但是我们不想要 $a[1 \ldots 3]$ 这一部分，怎么办呢？很简单，减去 $a[1 \ldots 3]$ 的和就行了。

那不妨考虑最开始，就将查询 $a[4 \ldots 7]$ 的和转化为查询 $a[1 \ldots 7]$ 的和，以及查询 $a[1 \ldots 3]$ 的和，最终将两个结果作差。
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240418161759.png)

### 管辖区间
那么问题来了，$c[x](x \ge 1)$ 管辖的区间到底往左延伸多少？也就是说，区间长度是多少？

树状数组中，规定 $c[x]$ 管辖的区间长度为 $2^{k}$，其中：

设二进制最低位为第 0 位，则 k 恰好为 x 二进制表示中，最低位的 1 所在的二进制位数；
$2^k$（$c[x]$ 的管辖区间长度）恰好为 x 二进制表示中，最低位的 1 以及后面所有 0 组成的数。

举个例子，$c_{88}$ 管辖的是哪个区间？
因为 $88_{(10)}=01011000_{(2)}$，其二进制最低位的 1 以及后面的 0 组成的二进制是 1000，即 8，所以 $c_{88}$ 管辖 8 个 a 数组中的元素。
因此，$c_{88}$ 代表 $a[81 \ldots 88]$ 的区间信息。

我们记 x 二进制最低位 1 以及后面的 0 组成的数为 $\operatorname{lowbit}(x)$，那么 $c[x]$ 管辖的区间就是 $[x-\operatorname{lowbit}(x)+1, x]$。

这里注意：$\boldsymbol{\operatorname{lowbit}}$ 指的不是最低位 1 所在的位数 $\boldsymbol{k}$，而是这个 1 和后面所有 0 组成的$\boldsymbol{2^k}$。

怎么计算 lowbit？根据位运算知识，可以得到 `lowbit(x) = x & -x`。

### 区间查询
接下来我们来看树状数组具体的操作实现，先来看**区间查询**。

回顾查询 $a[4 \ldots 7]$ 的过程，我们是将它**转化为两个子过程**：查询 $a[1 \ldots 7]$ 和查询 $a[1 \ldots 3]$ 的和，最终作差。

其实任何一个区间查询都可以这么做：查询 $a[l \ldots r]$ 的和，就是 $a[1 \ldots r]$ 的和减去 $a[1 \ldots l - 1]$ 的和，从而把区间问题转化为前缀问题，更方便处理。

每次往前跳，一定是跳到现区间的**左端点的左一位**，作为新区间的右端点，这样才能将前缀不重不漏地拆分。比如现在 $c_6$ 管的是 $a[5 \ldots 6]$，下一次就跳到 5 - 1 = 4，即访问 $c_4$。

我们可以写出查询 $a[1 \ldots x]$ 的过程：
- 从 $c[x]$ 开始往前跳，有 $c[x]$ 管辖 $a[x-\operatorname{lowbit}(x)+1 \ldots x]$；
- 令 $x \gets x - \operatorname{lowbit}(x)$，如果 $x = 0$ 说明已经跳到尽头了，终止循环；否则回到第一步。
- 将跳到的 $c$ 合并。
实现时，我们不一定要先把 $c$ 都跳出来然后一起合并，可以边跳边合并。

比如我们要维护的信息是和，直接令初始 $\mathrm{ans} = 0$，然后每跳到一个 $c[x]$ 就 $\mathrm{ans} \gets \mathrm{ans} + c[x]$，最终 $\mathrm{ans}$ 就是所有合并的结果。

### 单点修改
现在来考虑如何单点修改 $a[x]$。

我们的目标是快速正确地维护 $c$ 数组。为保证效率，我们只需遍历并修改管辖了 $a[x]$ 的所有 $c[y]$，因为其他的 $c$ 显然没有发生变化。

管辖 $a[x]$ 的 $c[y]$ 一定包含 $c[x]$，所以 $y$ 在树状数组树形态上是 x 的祖先。因此我们从 x 开始不断跳父亲，直到跳得超过了原数组长度为止。

设 $n$ 表示 $a$ 的大小，不难写出单点修改 $a[x]$ 的过程：
- 初始令 $x' = x$
- 修改 $c[x']$
- 令 $x' \gets x' + \operatorname{lowbit}(x')$，如果 $x' > n$ 说明已经跳到尽头了，终止循环；否则回到第二步。

区间信息和单点修改的种类，共同决定 $c[x']$ 的修改方式。下面给几个例子：
- 若 $c[x']$ 维护区间和，修改种类是将 $a[x]$ 加上 $p$，则修改方式则是将所有 $c[x']$ 也加上 $p$。
- 若 $c[x']$ 维护区间积，修改种类是将 $a[x]$ 乘上 $p$，则修改方式则是将所有 $c[x']$ 也乘上 $p$。

然而，单点修改的自由性使得修改的种类和维护的信息不一定是同种运算，比如，若 $c[x']$ 维护区间和，修改种类是将 $a[x]$ 赋值为 $p$，可以考虑转化为将 $a[x]$ 加上 $p - a[x]$。如果是将 $a[x]$ 乘上 $p$，就考虑转化为 $a[x]$ 加上 $a[x] \times p - a[x]$。

### 模板1 单点修改+区间查询
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
// 神奇的lowbit操作  
#define lowbit(x) ((x) & -(x))  
  
const int N = 5e5 + 5;  
int tree[N], a[N];  
int n, m, x, y, opt;  
  
// update用于单点更新，给所有tree[x]及其父节点均进行更新]  
void update(int x, int d){  
    while(x <= N){  
        tree[x] += d;  
        // 每次在二进制的最后一位1上加上1  
        x += lowbit(x);  
    }  
}  
  
// sum函数模拟前缀和  
int sum(int x){  
    int ans = 0;  
    while(x > 0){  
        ans += tree[x];  
        // 每次在二进制的最后一位1上减去1  
        x -= lowbit(x);  
    }  
    return ans;  
}  
  
int main(void){  
    cin >> n >> m;  
    // 一般从1开始，这样才能正常进行位运算  
    for(int i = 1; i <= n; i++) cin >> a[i];  
        // 初始化tree数组  
    for(int i = 1; i <= n; i++) update(i, a[i]);  
        // 开始执行操作  
    while(m--){  
        cin >> opt >> x >> y;  
        if(opt == 1) update(x, y);  
        else cout << sum(y) - sum(x - 1) << endl;  
    }  
        return 0;  
}
```

### 模板2 ：区间修改+单点查询
提到区间修改，一般都会想到用差分数组。但是差分数组没办法应对大规模的单点查询。基于此，可以用树状数组结合差分，实现单点查询功能
```c++
// 前面内容均保持一致

int main(void){  
    cin >> n >> m;  
    // 一般从1开始，这样才能正常进行位运算  
    for(int i = 1; i <= n; i++) cin >> a[i];  
//  不需要初始化tree数组，因为只是用tree实现差分 
//  for(int i = 1; i <= n; i++) update(i, a[i]);  
    
    // 开始执行操作  
    while(m--){  
        cin >> opt;  
        if(opt == 1) {  
        // 构造差分，实现区间修改
            cin >> x >> y >> z;  
            update(x, z);  
            update(y + 1, -z);  
        }  
        else{  
        // 单点查询，对应位置 = 差分的前缀和 + a[i]
            cin >> x;  
            cout << sum(x) + a[x] << endl;  
        }  
    }  
        return 0;  
}
```

### 模板3：区间修改+区间查询
这里正解应该是线段树，但是用改造后的树状数组也能求解。
这里使用了数学推导，成功将差分和前缀和连接起来
定义一个差分数组，它和原数组$a$的关系仍然为
$D[k]=a[k]-a[k-1]$，有$a[k] = D[1] + D[2] + ...+D[k]$
那么$$\begin{equation}\begin{aligned} &a_1+a_2+\dots+a_k\\=&D_1+(D_1+D_2)+\dots+(D_1+D_2+\dots+D_k)\\=&k(D_1+D_2+\dots+D_k)-(D_2+2D_3+\dots+(k-1)D_k)\\=&k\sum_{i=1}^kD_i-\sum_{i=1}^k(i-1)D_i\end{aligned}\end{equation}$$
这样就变成了一个$D_i$的差分，一个$(i-1)D_i$的差分

对于$(i-1)D_i$ 的差分，实际上更新的时候增加的是$k \times (i-1)$，所以，对于左边界，`update(x, d * (L-1))`，对于右边界，`update(y + 1, -d * (R + 1 - 1)) == update(y + 1, -d * R)`

```c++
#include<bits/stdc++.h>  
using namespace std;  
  
#define lowbit(x) (x & -(x))  
  
typedef long long ll;  
  
const int N = 100010;  
  
ll tree1[N], tree2[N], a[N];  
int n, m, x, d, opt, y;  
  
void update1(ll x, ll d){  
    while(x <= N){  
        tree1[x] += d;  
        x += lowbit(x);  
    }  
}  
void update2(ll x, ll d){  
    while(x <= N){  
        tree2[x] += d;  
        x += lowbit(x);  
    }  
}  
  
ll sum1(ll x){  
    ll ans = 0;  
    while(x > 0){  
        ans += tree1[x];  
        x -= lowbit(x);  
    }  
    return ans;  
}  
ll sum2(ll x){  
    ll ans = 0;  
    while(x > 0){  
        ans += tree2[x];  
        x -= lowbit(x);  
    }  
    return ans;  
}  
  
int main(void){  
    cin >> n >> m;  
	for(int i = 1; i <= n; i++) {  
		cin >> a[i];  
		update1(i, a[i] - a[i-1]);  
		update2(i, (i - 1) * (a[i] - a[i-1]));  // 差分数组初始化  
	}  
	while(m--){  
		cin >> opt;  
		if(opt == 1){  
			cin >> x >> y >> d;  
			// 更新第一个树状数组  
			update1(x, d);  
			update1(y + 1, -d);  
			// 更新第二个树状数组  
			update2(x, d * (x - 1));  
			update2((y + 1), -d * y);         
		}else{  
			cin >> x >> y;  
			// 前缀和输出  
			cout << y * sum1(y) - sum2(y) - (x-1) * sum1(x-1) + sum2(x-1) << endl;  
		}  
	}  
    return 0;  
}
```

### 逆序数问题
[P1774 最接近神的人 - 洛谷](https://www.luogu.com.cn/problem/P1774)

两种解法：归并排序和树状数组
归并排序只需要在合并的时候加一句`if(a[i] > a[j]) ans += mid - i + 1`即可，此处阐述树状数组解法：

Q1: 我们需要知道，怎么统计第 $𝑖$ 个数会与第$1 \sim 𝑖−1$个数构成多少个逆序对呢?

Ans1: 考虑**根据值来建树状数组** , 初始树状数组为全 0。现在按照序列**从左到右**将数据的值对**应的位置的数加一**，代表**又有一个数**出现。因此，在循环到第 $i$ 项时，前 $𝑖−1$ 项已经加入到树状数组内了 , 树状数组内比 $a_i​$大的都会与 $𝑎_𝑖$ ​构成逆序对，因为它们一定**出现的更早**，所以产生的逆序对数量为$i−query(a_i​)$

```
5,4,6,2,3,1

a[5], a[4], a[6], a[2], a[3], a[1]

倒序处理：
当前数字的前一个数的前缀和即为以该数为较大数的逆序对的个数

a[1] + 1
sum0 
ans += sum(0) = 0

a[3] + 1
sum2
ans += sum(2) = 1

```

注:$query(a_i​)$ 代表在树状数组内询问 $1 \sim 𝑎_𝑖$ 项的前缀和

𝑄2:根据 $𝑎_𝑖​$ 来建树状数组空间不够啊？

𝐴𝑛𝑠2: 确实不够。但是我们需要的只是数据之间的相对大小，只需要满足大于或小于本身，与大多少无关，具体来说，举个栗子：

```
//  1 2 10000
//  1 2 3
//上面两个序列在本题是等效的，因为无论第三项是3还是10000，它都大于第一项和第二项
```

这启发我们对数据**离散化**，先将数据排序，再用 $1 \sim 𝑛$ 分别对应 $n$ 个数表示它们的相对大小，对新的序列建树状数组空间就够了$(𝑛≤5×10^5)$

𝑄3: **相等的元素**是否会导致求解错误？每一个数（不管是否相等）对应的新数都不同诶？

𝐴𝑛𝑠3: 不处理的话会出错的，问题的关键在于是否有与 $𝑎_𝑖$​ 相等的元素在 $𝑎_𝑖$ 前被加入且**其相对大小标记更大**。出现这种情况就会误将两个相等的数判为逆序对。怎么解决呢，只要所有与 $𝑎_𝑖$ 相等的元素中，**先出现的标记也更小**就好了(我们只统计相对更大的)。具体只需要在排序时将 $𝑎_𝑖$ 作为第一关键字，下标(第几个出现)作为第二关键字从小到大排序即可。

如果用的不是这个方法的树状数组，那么你 WA 也多半是你忘记处理 Q3 中提到的问题了，如果 𝑅𝐸 ，多半是空间开小了。

Q4: 上面的是正序做法，倒序可以吗？

Ans4: 实际上也是可以的，当前数字的前一个数的前缀和即为以该数为较大数的逆序对的个数
```c++
#include<bits/stdc++.h>  
//using namespace std;  
  
#define lowbit(x) (x & -(x))  
  
typedef long long ll;  
const int N = 5e5 + 10;  
  
int tree[N], rank[N], n;  // rank是C++的保留字，如果加了using namespace std, 编译不通过  
  
void update(ll x, ll d){  
    while(x <= N){  
        tree[x] += d;  
        x += lowbit(x);  
    }  
}  
  
ll sum(ll x){  
    ll ans = 0;  
    while(x > 0){  
        ans += tree[x];  
        x -= lowbit(x);  
    }  
    return ans;  
}  
  
struct point{  
    int num, val;  
}a[N];  

point a[N];

bool cmp(point x, point y){  
    if (x.val == y.val) return x.num < y.num;  // 如果相等，让先出现的更小  
    return x.val < y.val;  
}  
  
int main(void){  
    scanf("%d", &n);  
    for(int i = 1; i <= n; i++){  
        scanf("%d", &a[i].val);  
        a[i].num = i;  
    }  
    std::sort(a + 1, a + 1 + n, cmp);  
    for(int i = 1; i <= n; i++) rank[a[i].num] = i;  
    ll ans = 0;  
        // 正序处理  
//    for(int i = 1; i <= n; i++){  
//        update(rank[i], 1);  
//        ans += i - sum(rank[i]);  
//    }  
//    倒序处理  
    for(int i = n; i > 0; i--){  
        update(rank[i], 1);  
        ans += sum(rank[i] - 1);  
    }  
    printf("%lld", ans);  
    return 0;  
}
```
# LCA
最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。 为了方便，我们记某点集 $S=\{v_1,v_2,\ldots,v_n\}$ 的最近公共祖先为 $\text{LCA}(v_1,v_2,\ldots,v_n)$ 或 $\text{LCA}(S)$。

### 性质
1. $\text{LCA}(\{u\})=u$；
2. u 是 v 的祖先，当且仅当 $\text{LCA}(u,v)=u$；
3. 如果 u 不为 v 的祖先并且 v 不为 u 的祖先，那么 u,v 分别处于 $\text{LCA}(u,v)$ 的两棵**不同子树**中；
4. 前序遍历中，$\text{LCA}(S)$ 出现在所有 S 中元素之前，后序遍历中 $\text{LCA}(S)$ 则出现在所有 S 中元素之后；
5. 两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\text{LCA}(A\cup B)=\text{LCA}(\text{LCA}(A), \text{LCA}(B))$；
6. 两点的最近公共祖先必定处在树上两点间的最短路上；
7. $d(u,v)=h(u)+h(v)-2h(\text{LCA}(u,v))$，其中 d 是树上两点间的距离，h 代表某点到树根的距离。

## 求法
### 朴素算法
#### 过程
可以每次找深度比较大的那个点，让它向上跳。显然在树上，这两个点最后一定会相遇，相遇的位置就是想要求的 LCA。 或者先向上调整深度较大的点，令他们深度相同，然后再共同向上跳转，最后也一定会相遇。
#### 性质
朴素算法预处理时需要 dfs 整棵树，时间复杂度为 $O(n)$，单次查询时间复杂度为 $\Theta(n)$。如果树满足随机性质，则时间复杂度与这种随机树的期望高度有关。

### 倍增算法
[manim | 算法】7分钟学会倍增法求解LCA]( https://www.bilibili.com/video/BV1N7411G7JD/?share_source=copy_web&vd_source=7e5be2911b148305be8878070abd5138)
离线做法，复杂度$O(n\log_2n+m\log_2m)$
#### 过程
倍增算法是最经典的 LCA 求法，他是朴素算法的改进算法。通过预处理 $\text{fa}_{x,i}$ 数组，游标可以快速移动，大幅减少了游标跳转次数。$\text{fa}_{x,i}$ 表示点 x 的第 $2^i$ 个祖先。$\text{fa}_{x,i}$数组可以通过 dfs 预处理出来。

**预处理**：
提前计算出每个节点的第 1,2,4...个祖先，即按2倍增的祖先
有了预计算出的祖先作为跳板，能从$x$快速跳到任何一个给定的目标深度。注意，**先用大数跳再用小数跳**
预计算方法：$$f[x][i] = f[f[x][i-1]][i-1]$$
$f[x][i-1]$：从$x$起跳，先跳$2^{i-1}$步到了祖先$z = f[x][i-1]$；$f[f[x][i-1]][i-1]=f[z][i-1]$：再从$z$跳$2^{i-1}$步到了祖先$f[z][i-1]$。一共跳了$2^i$步。于是实现了从$x$起跳，跳到了$x$的第$2^i$个祖先，这就是递推式右边的$f[x][i]$

特别的，$f[x][0]$为$x$的第$2^0=1$个祖先，即父节点，由其推出所有$f[x][i]$
![8ff2206c55f5d08b5ffcc61c0dfc8b1.png|650](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/8ff2206c55f5d08b5ffcc61c0dfc8b1.png)

现在我们看看如何优化这些跳转：
1. 在调整游标的第一阶段中，我们要将 u,v 两点**跳转到同一深度**。我们可以计算出 u,v 两点的**深度之差**，设其为 y。通过将 y 进行**二进制拆分**，我们将 y 次游标跳转优化为「y 的二进制表示所含 1 的个数」次游标跳转。 
2. 在第二阶段中，我们从**最大**的 $i$ 开始循环尝试，**同步向上走**，一直尝试到 0（包括 0），如果 $\text{f}_{u,i}\not=\text{f}_{v,i}$，则 $u\gets\text{f}_{u,i},v\gets\text{f}_{v,i}$，那么最后的 LCA 为 $\text{f}_{u,0}$。如果相等，那么$i$减小，再次尝试。

#### 性质
倍增算法的预处理时间复杂度为 $O(n \log n)$，单次查询时间复杂度为 $O(\log n)$。 另外倍增算法可以通过交换 $fa$ 数组的两维使**较小维放在前面**。这样可以减少 cache miss 次数，提高程序效率。

### 模板
5555 又忘记链式前向星怎么写了。。。。
y总那个尊嘟记不住。。。
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 500005;

struct Edge{
	int to;
	int next;
}edge[2 * N]; // 链式前向星

int head[2 * N], idx;

// 链式前向星初始化
void init(){
	for(int i = 0; i < 2 * N; i++){
		edge[i].next = -1;
		head[i] = -1;
	}
} 

// 加边
void add(int u, int v){
	edge[idx].to = v;
	edge[idx].next = head[u];
	head[u] = idx++;
}

int f[N][20], deep[N];

// 求 x 的深度deep[x]和f[x][]，father是x的父节点
void dfs(int x, int father){
	deep[x] = deep[father] + 1;
	f[x][0] = father;
	// 求 f 数组，最多到根节点
	for(int i = 1; (1 << i) <= deep[x]; i++){
		f[x][i] = f[f[x][i-1]][i-1];
	}
	
	for(int i = head[x]; i != -1; i = edge[i].next)
		if(edge[i].to != father) dfs(edge[i].to, x);  // 如果不是父亲节点，那么就是孩子节点，需要进行dfs
}

int lca(int x, int y){
	// 让x位于更底层
	if(deep[x] < deep[y]) swap(x, y);

	// x, y提到相同的位置
	for(int i = 19; i >= 0; i--){
		if(deep[x] - (1 << i) >= deep[y])  // 如果减了以后还大，说明x还是比y深，说明还得减；如果减了以后小了，就换个小的i重新减
			x = f[x][i];
	}
	if(y == x) return y; // 说明y就是x的祖先，那么直接返回
	
	// x和y同步往上跳，找到LCA
	for(int i = 19; i >= 0; i--){  // x 最多跳19次数， 2^19 > 500005
		if(f[x][i] != f[y][i]){
			x = f[x][i];
			y = f[y][i];
		}
	}
	return f[x][0];  // 最后x位于LCA的下一层，父节点f[x][0]就是LCA]
}

int main(void){
	init();
	int n, m, root;
	cin >> n >> m >> root;
	
	for(int i = 1; i< n; i++){  // 读入树
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v);  // 加边
		add(v, u);
	}
	
	dfs(root, 0);  // 计算节点深度并预处理 f[][]数组]
	
	while(m--){
		int a, b;
		scanf("%d%d", &a, &b);
		printf("%d\n", lca(a, b));
	}
	return 0;
}
```

### Tarjan(塔扬)算法求LCA
Tarjan算法是一种离散算法，巧妙利用**并查集**维护祖先节点
[【D10 Tarjan算法 P3379【模板】最近公共祖先（LCA）】 ](https://www.bilibili.com/video/BV1A94y12737/?share_source=copy_web&vd_source=7e5be2911b148305be8878070abd5138)
![](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240428171924.png)
1. 从根开始深搜遍历，入u时 打标记。
2. 枚举u的儿子v，遍历完v的子树，回u时 把v指向u。
3. 遍历完u的儿子们，离u时 枚举以 u为起点的查询，若终点v被搜过则查找v的根， 即 uv 的 LCA，答案记入 ans。
4. 递归遍历完整颗树，得到全部查询答案。
```c++
vector<int> e[N];
e[u] 存树边 , e[1] = 5, e[5] = 1 
// 无向边
for(int i = 1; i < n; i++){
	scanf("%d%d", &a, &b);
	e[a].push_back(b);
	e[b].push_back(a);
}

vector<pair<int,int>>query[N];
query[u] 存查询, query[3] = {4,1}, query[4] = {3,1}
// 起点是3，终点是4，1是查询的编号。
// 需要正着存一次，反着存一次
for(int i = 1; i <= m; i++){
	scanf("%d%d", &a, &b);
	query[a].push_back({b, i});
	query[b].push_back({a, i});
}

fa[u] 存父节点, fa[5]= 1, fa[2] = 5
for(int i = 1; i <= N; i++) fa[i] = i;  // 并查集初始化指向自己

vis[u] 打标记 vis[5] = true

ans[i] 存查询结果 ans[1] = 1, ans[2] = 5
//这里i是第几个查询，当所有处理完才输出结果

vector<int> e[N];
vector<pair<int,int>>query[N];
int fa[N], vis[N], ans[M];

int find(int u){  // 维护并查集
	if(u == fa[u]) return u;
	return fa[u] = find(fa[u]);
}

void tarjan(int u){  // 深搜
	vis[u] = true;  // 入u时，标记u
	for(auto v : e[u]){  // 枚举u的所有儿子
		if(!vis[u]){  // 判重，保证一定往下走
			tarjan(v);
			fa[v] = u; // 回u时，v指向u
		}
	}
	// 离u时，枚举LCA
	for(auto q: query[u]){
		int v = q.first, i = q.second;
		if(vis[v]) ans[i] = find(v);
	}
}
```
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240428180651.png)

