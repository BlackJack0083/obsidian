***重点是掌握二叉树如何构建与递归的运用***
# 二叉树
### 性质
![[微信截图_20231115192524.png|500]]![[微信截图_20231115192540.png|500]]![[微信截图_20231115192601.png|500]]
### 构造
**常见的构造是利用指针进行动态构造**
```c++
#include<bits/stdc++.h>
using namespace std;

typedef struct BiNode{
	char data; // 假设输入数据为字符
	struct BiTree* lchild;
	struct BiTree* rchild;
} BiNode, *pBiNode;

char s[100010];
int n;

// 二叉树的构建，使用递归
// 假设输入为一个数列，以数组方式存储：
// eg.FCA##DB###EHM###G##
// 注意，这里 n 必须传引用类型，因为n要随着递归不断增加
void createBiTree1(pBiTree &T, char a[], int &n){
	char ch = a[n++];
	if(ch != '#'){
	// 一开始的指针没有分配内存，需要给它分配内存才能存储数据
		T = (pBiNode)malloc(sizeof(BiTree));
		T -> data = ch;
		createBiTree(T -> lchild, a, n);
		createBiTree(T -> rchild, a, n);
	} else T = NULL; // 如果接收字符为'#'终止符，则该指针为空指针，建立空子树
}

// 另一种递归创建的方式，可以在构造的时候逐个读入，最后返回根节点
pBTNode createBiTree2(pBTNode &root){
    char ch;
    scanf("%c", &ch);
    if(ch == '#'){
        root = NULL;
    }else{
        root = (pBTNode)malloc(sizeof(BTNode));
        root -> data = ch;
        root -> lchild = createBTree(root -> lchild); //构造左子树
        root -> rchild = createBTree(root -> rchild); //构造右子树
    }
    return root;
}

int main(void){
	pBiNode T;
	int n = 0;
	cin >> s;  // 读入字符串，利用char数组读入
	createBiTree1(T, s, n);
	// createBiTreee2(T); 
}
```
