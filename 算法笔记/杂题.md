>[!note] 非常重要
>由于蓝桥杯是OI赛制，所以要**记得自己造数据**！！！不然对于一些题目可能会只过样例直接寄
# 蓝桥杯 2013 省 A 错误票据

## 题目背景
某涉密单位下发了某种票据，并要在年终全部收回。
## 题目描述

每张票据有唯一的 ID 号，全年所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。

你的任务是通过编程，找出断号的 ID 和重号的 ID。

数据保证断号不可能发生在最大和最小号。

## 输入格式
一个整数 $N(N<100)$ 表示后面数据行数，接着读入 $N$ 行数据，每行数据长度不等，是用空格分开的若干个（不大于 $100$ 个）正整数（不大于 $10^5$），每个整数代表一个 ID 号。

## 输出格式
要求程序首先输入要求程序输出 $1$ 行，含两个整数 $m$，$n$，用空格分隔，其中，$m$ 表示断号 ID，$n$ 表示重号 ID。

## 样例 #1
### 样例输入 #1
```
2
5 6 8 11 9
10 12 9
```
### 样例输出 #1
```
7 9
```
## 样例 #2
### 样例输入 #2
```
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
```
### 样例输出 #2
```
105 120
```

## 题解
呃好叭，做这道题的时候才发现`string`类型竟然不能把空格一起读入。。。
一道很简单的题目，就是输入输出比较头疼，结果又看见了神奇的读入形式：`while(cin >> n)`，但这个好像利用了洛谷是以文件输入的特性。。如果cin读到文件结尾就会自动停止(但scanf不会)，呃不过不太清楚蓝桥会不会也这样。。所以这个唯一的读入方法是用`char`来一个一个读？
感叹还是牛人多。。。
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
int da[N];

int com, n, loss, x;

int main(void){
	cin >> n;

	while(scanf("%d", &x)){
		da[x]++;	
		if(da[x] > 1) com = x;	
	} 
	for(int i = 0; i < N; i ++){
		if(da[i] == 0 && da[i - 1] && da[i + 1]) {
			loss = i;
			break;
		}
	}
	cout << loss << ' ' << com << endl;
}
```
另一种输入的方法（好神奇！）：
```c++
#include<bits/stdc++.h
using namespace std;
const int N=100;
int n;
int a[N];
int main(){
	int j=0;
	memset(a,-1,sizeof(a));
	scanf("%d",&n);
	
	for(int i=1;i<=n;i++){
		while(cin>>a[j++]){
			char c='0';
			c=cin.get();
			if(c=='\n') break;
		}
	}
	sort(a,a+j);

	int sum[j]={0};
	int x,y;
	for(int i-0;i<j;i++){
		sum[i]=a[i+1]-a[i];
		if(sum[i]=-0) x=a[i];
		if(sum[i]==2) y=a[i]+1;
	}
	
	cout<<y<<" "<<x;
}
```
`cin.get()`函数：读取cin的下一个值，通过这个来判断什么时候换行

# 蓝桥杯 2022 省 B 修剪灌木

## 题目描述
有 $N$ 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晩会修剪一棵灌木，让灌木的高度变为 $0$ 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。

灌木每天从早上到傍晩会长高 $1$ 厘米, 而其余时间不会长高。在第一天的早晨, 所有灌木的高度都是 $0$ 厘米。爱丽丝想知道每棵灌木最高长到多高。
## 输入格式
一个正整数 $N$ ，含义如题面所述。
## 输出格式
输出 $N$ 行, 每行一个整数, 第行表示从左到右第 $i$ 棵树最高能长到多高。
## 样例 #1
### 样例输入 #1
```
3
```
### 样例输出 #1
```
4
2
4
```
## 提示
对于 $30 \%$ 的数据, $N \leq 10$.
对于 $100 \%$ 的数据, $1<N \leq 10000$. 

### 题解
对于每一棵灌木的位置 $a_i$​，爱丽丝可以从 $a_i$​ 到 $a_1​$ 再到 $a_i​$，需要天数（也就是灌木长的高度）为 $2i$；也可以从 $a_i$​ 到 $a_n$​ 再到 $a_i$​，需要天数为 $2(n−i-1)$。
最后取大即可。

感觉每次都不会用max啊....
```c++
#include<bits.stdc++.h>

using namespace std;

int main(void）{
   int n;
   cin >> n;
   for(int i = 0; i < n; i ++ ){
       cout << max(i, n - i - 1) * 2 << endl;
   }
   return 0;
}
```

# 蓝桥杯 2023 省 A 平方差
## 题目描述
给定 $L,R$，问 $L \leq x \leq R$ 中有多少个数 $x$ 满足存在整数 $y,z$ 使得 $x=y^2-z^2$。
## 输入格式
输入一行包含两个整数 $L,R$，用一个空格分隔。
## 输出格式
输出一行含一个整数满足题目给定条件的 $x$ 的数量。
## 样例 #1
### 样例输入 #1
```
1 5
```
### 样例输出 #1
```
4
```
## 提示
#### 【样例说明】
* $1=1^2-0^2$
* $3=2^2-1^2$
* $4=2^2-0^2$
* $5=3^2-2^2$

### 题解
一道简单的数论。。。但我还是被卡住了
一开始当然大家都能想到这个平方差式子可以被分解：$$x = y^2 - z^2=(y-z)(y+z)$$
然后呢...?就暴露出我知识浅薄了。。
这里进一步化简，需要注意到奇偶数的性质：
- 同为奇数/同为偶数：那么$y+z, y-z$ 均为偶数
- 一奇一偶：$y+z$为奇数，$y-z$为奇数

对于情况2，可以假设 $y = z+1$，这样即可满足1奇1偶的条件，那么代入式子得到$$x=(2z+1)*1=2z+1$$这是可以映射到所有奇数的。故只要$x$为奇数就能满足

对于情况1，同样可以假设$y=z+2$，这样得到$$x = 2 \times(2z+2) = 4(z+1)$$
发现这种情况要求 $x$ 必须为$4$的倍数才能满足条件
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
int l, r;  
  
int main(void){  
    cin >> l >> r;  
    int cnt = 0;  
    for(int i = l; i <= r; i++)  
        if((i & 1) || (i % 4==0)) cnt ++;  
        cout << cnt << endl;  
    return 0;  
}
```

# 蓝桥杯 2016 国 C 赢球票 【模拟】
## 题目描述
某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。
主持人拿出 $N$ 张卡片（上面写着 $1 \sim N$ 的数字），打乱顺序，排成一个圆圈。
你可以从任意一张卡片开始顺时针数数 $1,2,3 \cdots$。
如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。
直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：
卡片排列是：$1,2,3$。
我们从 $1$ 号卡开始数，就把 $1$ 号卡拿走。再从 $2$ 号卡开始，但数的数字无法与卡片对上，
很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 $1$ 张球票。
还不算太坏！如果我们开始就傻傻地从 $2$ 或 $3$ 号卡片数起，那就一张卡片都拿不到了。
如果运气好，卡片排列是 $2,1,3$。
那我们可以顺利拿到所有的卡片！

本题的目标就是：已知顺时针卡片序列。
随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）
## 输入格式
第一行一个整数 $N(N<100)$，表示卡片数目。
第二行 $N$ 个整数，表示顺时针排列的卡片。
## 输出格式
一行，一个整数，表示最好情况下能赢得多少张球票。
## 样例 #1
### 样例输入 #1
```
3
1 2 3
```
### 样例输出 #1
```
1
```
## 样例 #2
### 样例输入 #2
```
3
2 1 3
```
### 样例输出 #2
```
6
```

### 题解
发现真的一点都不会模拟呢...
这题数据量不大，关键是想到要怎么模拟。

这题思路好精巧，用一个计数器来控制这个过程，然后模拟循环队列可以用模来实现
`maxa`提前存储最大值，当超过最大值时说明怎么样都无法匹配了，这个时候break
`x`存已经选中的位置，如果选满了也可以退出
`cnt`存当前计数
`sum`存当先起始位置下得到的总和，最后取最大值

崩溃了。。。看代码看半天发现有次提交数据范围没有改掉
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
// 一定要记得调整数据范围！！！！！
const int N = 110;  
  
int a[N], f[N];  
int n, maxa, ans;  
  
int main(void){  
    cin >> n;  
    for(int i = 0; i < n; i++){  
        cin >> a[i];  
        maxa = max(a[i], maxa);  
    }  
    // 尝试从各个起点开始  
    for(int k = 0; k < n; k++){  
        // cnt 用来计数  
        int cnt = 1;  
        // sum 用来记录当前总数  
        int sum = 0;  
        // i 用来记录当前位置  
        int i = k;  
        // x 表示当前已经有了多少个被选取  
        int x = 0;  
        // 每次均需要先给 f 清空  
        memset(f, 0, sizeof f);  
        while(1){  
            if(!f[i]){  
                if(cnt == a[i]){  
                // 如果匹配上，那么就结果 + cnt，并给f[i]标志为1，表示已访问  
                    sum += cnt;  
                    f[i] = 1;  
                    // cnt 从头开始计数  
                    cnt = 0;  
                    x ++;  
                }  
                cnt ++;  
            }  
            // 设置退出条件  
            if(x > n - 1 || cnt > maxa) break;  
            // 用模来表示循环队列  
            i = (i + 1) % n;  
        }  
        ans = max(sum, ans);  
    }  
	cout << ans << endl;  
	return 0;  
}
```

