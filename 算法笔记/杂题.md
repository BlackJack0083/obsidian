>[!note] 非常重要
>由于蓝桥杯是OI赛制，所以要**记得自己造数据**！！！不然对于一些题目可能会只过样例直接寄
# 蓝桥杯 2013 省 A 错误票据

## 题目背景
某涉密单位下发了某种票据，并要在年终全部收回。
## 题目描述

每张票据有唯一的 ID 号，全年所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。

你的任务是通过编程，找出断号的 ID 和重号的 ID。

数据保证断号不可能发生在最大和最小号。

## 输入格式
一个整数 $N(N<100)$ 表示后面数据行数，接着读入 $N$ 行数据，每行数据长度不等，是用空格分开的若干个（不大于 $100$ 个）正整数（不大于 $10^5$），每个整数代表一个 ID 号。

## 输出格式
要求程序首先输入要求程序输出 $1$ 行，含两个整数 $m$，$n$，用空格分隔，其中，$m$ 表示断号 ID，$n$ 表示重号 ID。

## 样例 #1
### 样例输入 #1
```
2
5 6 8 11 9
10 12 9
```
### 样例输出 #1
```
7 9
```
## 样例 #2
### 样例输入 #2
```
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
```
### 样例输出 #2
```
105 120
```

## 题解
呃好叭，做这道题的时候才发现`string`类型竟然不能把空格一起读入。。。
一道很简单的题目，就是输入输出比较头疼，结果又看见了神奇的读入形式：`while(cin >> n)`，但这个好像利用了洛谷是以文件输入的特性。。如果cin读到文件结尾就会自动停止(但scanf不会)，呃不过不太清楚蓝桥会不会也这样。。所以这个唯一的读入方法是用`char`来一个一个读？
感叹还是牛人多。。。
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
int da[N];

int com, n, loss, x;

int main(void){
	cin >> n;

	while(scanf("%d", &x)){
		da[x]++;	
		if(da[x] > 1) com = x;	
	} 
	for(int i = 0; i < N; i ++){
		if(da[i] == 0 && da[i - 1] && da[i + 1]) {
			loss = i;
			break;
		}
	}
	cout << loss << ' ' << com << endl;
}
```
另一种输入的方法（好神奇！）：
```c++
#include<bits/stdc++.h
using namespace std;
const int N=100;
int n;
int a[N];
int main(){
	int j=0;
	memset(a,-1,sizeof(a));
	scanf("%d",&n);
	
	for(int i=1;i<=n;i++){
		while(cin>>a[j++]){
			char c='0';
			c=cin.get();
			if(c=='\n') break;
		}
	}
	sort(a,a+j);

	int sum[j]={0};
	int x,y;
	for(int i-0;i<j;i++){
		sum[i]=a[i+1]-a[i];
		if(sum[i]=-0) x=a[i];
		if(sum[i]==2) y=a[i]+1;
	}
	
	cout<<y<<" "<<x;
}
```
`cin.get()`函数：读取cin的下一个值，通过这个来判断什么时候换行

# 蓝桥杯 2022 省 B 修剪灌木

## 题目描述
有 $N$ 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晩会修剪一棵灌木，让灌木的高度变为 $0$ 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。

灌木每天从早上到傍晩会长高 $1$ 厘米, 而其余时间不会长高。在第一天的早晨, 所有灌木的高度都是 $0$ 厘米。爱丽丝想知道每棵灌木最高长到多高。
## 输入格式
一个正整数 $N$ ，含义如题面所述。
## 输出格式
输出 $N$ 行, 每行一个整数, 第行表示从左到右第 $i$ 棵树最高能长到多高。
## 样例 #1
### 样例输入 #1
```
3
```
### 样例输出 #1
```
4
2
4
```
## 提示
对于 $30 \%$ 的数据, $N \leq 10$.
对于 $100 \%$ 的数据, $1<N \leq 10000$. 

### 题解
对于每一棵灌木的位置 $a_i$​，爱丽丝可以从 $a_i$​ 到 $a_1​$ 再到 $a_i​$，需要天数（也就是灌木长的高度）为 $2i$；也可以从 $a_i$​ 到 $a_n$​ 再到 $a_i$​，需要天数为 $2(n−i-1)$。
最后取大即可。

感觉每次都不会用max啊....
```c++
#include<bits.stdc++.h>

using namespace std;

int main(void）{
   int n;
   cin >> n;
   for(int i = 0; i < n; i ++ ){
       cout << max(i, n - i - 1) * 2 << endl;
   }
   return 0;
}
```