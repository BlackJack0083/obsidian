**熟练掌握算法：能够默写出来，记忆，提高熟练度**
# 基础算法
## 双指针
常见双指针：归并排序和快排
![[微信截图_20230919084051.png]]
```c++
for (i = 0, j = 0; i < n; i ++ ){
	while (j < i && check(i,j)) j++;
	// 每道题目的具体逻辑
}
```
**思路：** 先找怎么暴力求解，然后找到 i 和 j 的关系，再进行双指针

**优点：**
可以进行优化，将原本的朴素算法$O(n^2)$优化到$O(n)$

例子：输入字符串，并把每个单词逐个输出
```c++
#include<iostream>
#include<string.h>
using namespace std;

int main(){
	char str[1000];

	gets(str);

	int n = strlen(str);
	
	for(int i = 0; i < n; i++){
		int j = i;
		while(j < n && str[j] !=' ') j++;
		// 问题的具体逻辑
		for(int k = i; k < j; k++){
			cout << endl;
		}
		i = j;
	}
}
```

### Acwing790 找出最长连续无重复子序列
无重复：不能有数字重复出现，可以调用数组存储数字出现的次数
暴力做法：$O(n^2)$
```c++
for(int i = 0; i < n; i ++){
	for(int j = 0; j <= i; j ++){
		if(check(j, i)){ // 是否包含重复元素
			res = max(res , i - j  + 1);
		}
	}
}
```
设立两个指针 i 和 j，令 i 不断往后走，j 留在原来位置记录长度 

i 和 j 的关系：**单调性**，即 i 往后走，j 只能要么不动，要么一起往后走，否则会产生矛盾
因此改进后的双指针算法为：
```c++
for(int i = 0, j = 0; i < n; i +=){
	while(j <= i && check(j, i)) j ++;
	res = max(res, i - j + 1);
} 
```

完整代码：
```c++
#include<iostream>
using namespace std;

const int N = 100010;

int n;
int a[N], s[N];

int main(){
	cin >> n;
	for(int i = 0; i < n; i ++) cin>> a[i];
	
	int res = 0;
	for(int i = 0, j = 0; i < n; i ++){
		s[a[i]] ++; // 存放各数字出现次数
		while(s[a[i]] > 1){ // 出现重复，则计数超过1
			s[a[j]] --; 
			j++;
		} 
		res = max(res, i - j + 1);
	}
	cout << res << endl;
	return 0;
}
```

### Acwing 800: 判断子序列

同样为双指针算法的典型例题，指针同向向后走且 j 指针走的速度必然大于 i 指针
我的做法是用一个数组判断a\[n]是否全部被匹配，即若全部匹配，judge\[n-1]必然为1，这样复杂度为$O(n)$

```c++
#include<iostream>

using namespace std;

const int N = 100010;
int a[N], b[N], judge[N] = {0};
int n, m;

int main(void){
    cin >> n >> m;
    for(int i = 0; i < n; i++) cin >> a[i];
    for(int i = 0; i < m; i++) cin >> b[i];
    
    for(int i = 0, j = 0; i < n; i++ ){
        while(j < m && b[j] != a[i]) j++;
        if(j < m  && b[j] == a[i]){
           judge[i] = 1; 
           j++;
        } 
    }
    
    if(judge[n-1] == 1) {
        cout << "Yes";
    }
    else 
        cout << "No";
}
```

y总的思路很相似，但是他是直接让数组 i ++ 跳到下一个位置，如果走完以后 i 还没有走到最后，说明没有匹配完，说明不是子序列

```c++
#include<iostream>
#include<cstring>

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++) scanf("%d", &a[i]);
	for(int i = 0; i < m; i++) scanf("%d", &b[i]);

	int i = 0, j = 0;
	while(i < n && j < m){
		if(a[i] == b[j]) i ++;
		j++;
	}

	if(i == n) puts("Yes");
	else puts("No");

	return 0;
}
```
## 位运算

### 将十进制转换成二进制输出
$n$ 的二进制表示中，第 $k$ 位是几(从右往左算，第一个是第0位)
eg. $n = 15 = (1111)_2$
	1. 先把第k位移到最后一位 n >> k
	2. 看看个位是几
**整合：** `n >> k & 1`

```c++
#include<iostream>
#include<string.h>

using namespace std;

int main(void){
	int n = 10;

	for(int k = 3; k >= 0; k--) cout << (n >> k & 1) << endl; // 输出 1010
	return 0;
}
```

### lowbit操作
`lowbit(x)`操作：返回 x 的*最后一位1*
	eg.`x = 1010; lowbit(x) = 10;`
	`x = 101000; lowbit(x) = 1000;`

本质操作是：**x & -x = x & (~x+1)**(取反后+1)
在C/C++中，一个整数的负数是其补码，即取反x+1
这里有一个很生动的图：
![[微信截图_20230925221059.png]]

*一般应用：知道 x 中有多少个 1*
### Acwing 801：
给定n个数，求每个数的二进制数的1的个数
这个地方的lowbit运算很巧妙，没有直接用不断除2计算1，而是用lowbit操作把各个位置的 1 都减去，最后就剩下全0
```c++
#include<iostream>
using namespace std;

int lowbit(int x){
	return x & -x;
}
int main(void){
	int n;
	cin >> n;
	while(n--){
		int x;
		cin >> x;
		int res = 0;
		while(x) x -= lowbit(x), res ++;  // 每次减去x的最后一个1，算减了多少次
		cout << res << ' ';
	}
}
```

另一种算法：不断右移，若为1计数+1
```c++
#include<iostream>

using namespace std;

int main(void){
    int n;
    cin >> n;
    
    while(n--){
        int x, res = 0;
        cin >> x;
        while(x) {
            if(x % 2 != 0) res ++; // (x & 1)
            x /= 2;  // x = x >> 1
        }
        cout << res << ' ';
    }
}
```

### 原码、反码与补码

**正数三码合一**
对于负数，因为计算机没有减法操作，是用加法来表示减法，所以对于$x \ge 0$，有$x +(-x) = 0$，$-x = 0-x$，此处的$0$为32位的二进制表示，故需要借位，$100...000(32个0) -x = \~ x+1$

## 离散化(整数、有序)
基本含义：对于题目中给出的值域较大($0 - 10^9$)，个数较少($10^5$)的数，尝试将这些数映射到从0开始，n-1结束的自然数
![[微信截图_20231010105651.png]]
**问题：**
1. 数组中可能有重复元素 -> 去重
```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序1
alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素，unique返回去重后数组尾部
```
2. 如何计算 x 离散化后的值 -> 二分
```c++
// 二分求出x对应的离散化的1值
int find(int x){  // 找到第一个大于等于x的位置
	int l = 0, r = alls.size() -1; 
	while(l < r){
		int mid = l + r >> 1;
		if(alls[mid] >= x) r = mid;
		else l = mid + 1; 
	}
	return r + 1;  // 映射到 1，2，... n
}
```

### AcWing区间和
由于本题数据大小范围在 $2 \times 10^9$，但数据数范围只有$3 \times 10^ 5$，故可以离散化操作
```c++
#include<iostream>
#include<algorithm>
using namespace std;

typedef pair<int, int> PII;

const int N = 300010;   

int n, m;
int a[N], s[N];

vector<int> alls;
vector<PII> add, query;

int find(int x)
{
	int l = 0; r = alls.size() - 1;
	while(l < r){
		int mid = l + r >> 1;
		if(alls[mid] >= x) r = mid;
		else l = mid + 1;
	}
	return r + 1;
}

int main(){
	int x, c;
	cin >> n >> m;
	
	for(int i = 0; i < n; i ++){
		cin >> x >> c;
		add.push_back({x, c});

		alls.push_back(x);
	}
	for(int i = 0; i < m; i++){
		int l, r;
		cin >> l >> r;
		query.push_back({l, r});
		
		alls.push_back(l);
		alls.push_back(r);
	}
	
	// 去重
	sort(alls.begin(), alls.end());
	alls.erase(unique(alls.begin(), alls.end()), alls.end());

	for(auto item : add){ // 这里的for跟java一样，就是将add的元素进行迭代
		int x = find(item.first); // 找到item的第一个元素x对应的下标
		a[x] += item.second; // 对数组的对应位置加入item的第二个值，就是给的c
	}
}
	// 预处理前缀和
	for(int i = 1; i <= alls.size(); i ++) s[i] = s[i - 1] + a[i];

	// 处理询问
	for(auto item : query){
		int l = find(item.first), r = find(item.second);
		cout << s[r] - s[l - 1] << endl;
	}

	return 0;
}
```

`unique()`操作：双指针算法
![[微信截图_20231010194853.png]]
```c++
vector<int>::iterator unique(vector<int> &a){
	int j = 0;
	for(int i = 0; i < a.size(); i ++){
		if(!i || a[i] != a[i - 1])
			a[j++] = a[i];
	}
	// a[0] - a[j-1]存储的即为不同的数
}
```

## 区间合并
将有交集的区间进行合并
边界：交点重合也可以算为交集

### AcWing区间合并
![[微信截图_20231010205233.png]]
```c++
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

typedef pair<int, int> PII;

const int N = 100010;

int n;
vector<PII>segs;

void merge(vector<PII> &segs){
	vector <PII> res;

	sort(segs.begin(); segs.end());

	int st = -2e9, ed = -2e9;
	for(auto seg : segs){
		if(ed < seg.first){
			if(st != -2e9) res.push_back(st, ed);
			st = seg.first,ed = seg.second;
		}else ed = max(ed, seg.second);
		if(st != -2e9) res.push_back(st, ed);

		segs = res;
	}
}

int main(){
	cin >> n;

	for(int i = 0; i < n; i++){
		int l, r;
		cin >> l >> r;
		segs.push_back({l, r});
	}

	merge(segs);

	cout << segs.size() << endl;

	return 0;
}
```


# 数据结构
用数组来模拟，从而提高效率
## 链表
![[微信截图_20231020201717.png]]
### 单链表
通常用邻接表来模拟(**静态链表**)，可以存储图和树，优点是代码简介，但没有结构体易懂
单链表只能从头往后，不能往回遍历

每个节点都包含着一个value和一个next指针，最后会指向一个空节点
![[微信截图_20230824121309.png]]
如上图所示，绿色的为*每个节点的value值*，用数组e\[n]记录；蓝色的为节点的next指针，就是*节点 i 的下一个位置*，用数组ne\[n]来记录

**头插法：**
```c++
#include <iostream>  
  
using namespace std;  
  
const int N = 100010;  
  
// 所有节点均用下标索引  
// e[i]表示节点i的值  
// ne[i]表示节点i的next指针是多少  
// idx 存储当前已经用到了哪个点  
int head, e[N], ne[N], idx;  
  
// 初始化  
void init() {  
    head = -1;  
    idx = 0;  
}  
  
void add_to_head(int x) {  
    e[idx] = x;  
    ne[idx] = head; // idx指向原本head指向的点，即idx的下一个点  
    head = idx;  
    idx ++;  
}  
  
void add(int k, int x) {  
    e[idx] = x;  
    ne[idx] = ne[k];  
    ne[k] = idx;  
    idx++;  
}  
  
void remove(int k) {  
    ne[k] = ne[ne[k]];  
}  
  
int main(void) {  
    int m;  
    cin >> m;  
    init();  
    while (m--) {  
        int k, x;  
        char op;  
  
        cin >> op;  
        if (op == 'H') {  
            cin >> x;  
            add_to_head(x);  
        } else if (op == 'D') {  
            cin >> k;  
            if (!k) head = ne[head];  
    // 加入k = 0 时的特判，当k=0时，删除头节点即为指向head的指向的点的下一个结点  
            remove(k - 1);      // 注意这里要变为k-1，因为要插入到第k个结点右边，所以对应数组位置要-1  
        } else {  
            cin >> k >> x;  
            add(k - 1, x);  
        }  
    }  
    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';  
}
```

插入头结点：
![[微信截图_20231020202722.png]]

### 双链表
常用来优化某些问题
有两个指针，一个指向前，一个指向后
设置0为头，1为尾
```c++
#include<iostream>

using namespace std;

const int N = 100010;
int e[N], r[N], l[N];
int idx, M, x, k;

void init(){
    r[0] = 1;  //* 初始化 第一个点的右边是 1   第二个点的左边是 0
    l[1] = 0;  //! idx 此时已经用掉两个点了
    idx = 2;
}

void add(int k, int x){
    e[idx] = x;
    r[idx] = r[k];  //todo 这边的 k 不加 1 ， 输入的时候 k+1 就好
    l[idx] = k;
    l[r[k]] = idx; 
    r[k] = idx;
    idx++;
}//!当然在 K 的左边插入一个数 可以再写一个，也可以直接调用我们这个函数，
// 在 k 的左边插入一个数等价于在 l[k]的右边插入一个数 add(l[k],x)

//*删除第 k个 点

void remove(int k){
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}


int main(void){
    scanf("%d", &M);
    init();
    
    while(M--){
        string s;
        cin >> s;
        if(s == "R"){
            cin >> x;
            add(l[1], x);//!   0和 1 只是代表头和尾，所以最右边插入只要在指向 1的那个点的右边插入就可以了
        }else if(s == "L"){
            cin >> x;
            add(0, x);
        }else if(s == "D"){
            cin >> k;
            remove(k + 1);   // 注意，由于一开始就有01下标，需要+1
        }else if(s == "IL"){
            cin >> k >> x;
            add(l[k+1], x);
        }else{
            cin >> k >> x;
            add(k + 1, x);
        }
    }
    for(int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';
}
```
![[微信截图_20231020213438.png]]

#### 邻接表
n个单链表

## 栈和队列
虽然说开了$O_2$优化后STL与数组模拟速度接近，但是比赛时可能不会开优化，会导致STL比数组慢一些，因此最好用数组进行实现

**栈**：先进后出
**队列**：先进后出
栈的伪代码：
```c++
#include<iostream>

using namespace std;

const int N = 100010;

int stk[N], tt;

// 插入
stk[tt++] = x;

// 弹出
tt--;

// 判断栈是否为空
if(tt > 0) not empty;
else empty;

// 栈顶
stk[tt];
```

完整代码：
```c++
#include<iostream>
using namespace std;

const int N = 100010;
int M, x;
int stk[N];
string s; 

int main(void){
    int bottom = 0, top = -1; // 这个地方top = -1的原因是top始终指向栈顶，而非栈顶下一个元素
    cin >> M;  
    while(M--){
        cin >> s;  // cin 可以直接读入字符串哎
        if(s == "push") {
            cin >> x;
            stk[++top] = x;
        }else if(s == "query") printf("%d\n", stk[top]);
        else if(s == "pop") stk[top--];
        else{
            if(bottom > top) printf("YES\n");
            else printf("NO\n");
        }
    }
}
```

队列伪代码：
```c++
int q[N], hh, tt = -1; // tt表示队列尾部(tail)，hh表示队列头部(head)
// 林老讲的是两个都为0，这个看个人习惯
// 插入
q[++tt] = x;

// 弹出
hh ++;

// 判断是否为空
if(hh <= tt) not empty
else empty

// 去除队头元素
q[hh];
```

完整代码：
```c++
#include<iostream>

using namespace std;

const int N = 1000010;
int x, M;
int que[N];
string s;

int main(void){
    int front = 0, rear = 0;
    cin >> M;
    while(M--){
        cin >> s;
        if(s == "push"){
            cin >> x;
            que[rear ++] = x;
        }else if(s == "pop") front++;
        else if(s == "empty"){
            if(front == rear) printf("YES\n");
            else printf("NO\n");
        }else printf("%d\n", que[front]);
    }
}
```

### 单调栈和单调队列
#### 单调栈
给定一个序列，求序列每一个数左边离它最近且比它小的数
![[微信截图_20231020220414.png]]

*暴力做法：两重循环*
	第一个循环 i 从0到n，代表数组每一个数
		第二个循环 j 从 i 到 0 ，找到比 i 小的第一个数

发现可以用一个栈来存储前面的所有值，找到其数学性质
如果满足 $a_x \ge a_y$ 且 $x < y$，则一定不会进栈，最后剩下的序列即为单调序列
![[微信截图_20231020221616.png]]
如果栈顶元素`stk[tt] >= a[i]` 删掉栈顶元素
如果`stk[tt] < a[i]`说明找到了对应点，再将`a[i]`push进栈

```c++
#include<iostream>
using namespace std;

const int N =100010;

int n;
int stk[N], tt;

int main(void){
	cin.tie(0); // 提高读入速度
	cout.tie(0);
	ios::sync_with_stdio(false); //提高读入速度
	
	cin >> n;

	for(int i = 0; i < n; i++){
		int x;
		cin >> x;
		while(tt && stk[tt] >= x) tt--;  // 栈非空且栈顶元素大于或等于当前元素，则说明栈顶元素不会被用到，直接弹出
		if(tt) cout.tie(0) << stk[tt] << ' ';
		else cout << -1 << ' ';

		stk[tt ++] =x;
	}
}
```
`cin、cout`输入输出速度慢于`scanf、printf`，而且慢很多

**时间复杂度：** 每个元素只会进栈一次，出栈一次，总共只有2n次操作，总共时间复杂度为$O(n)$

#### 单调队列
主要用于滑动窗口
eg.输出滑动窗口中的最大值与最小值

使用队列来维护窗口![[微信截图_20231021110415.png]]
队列中存的不是值，是下标
判断最小：如果新插入的数字小于队列尾部的数，说明队尾数字无用，删除

```c++
#include<iostream>

using namespace std;

const int N = 1000010;

int n;
int a[N], q[N];

int main(){
	scanf("%d%d", &n, &k);
	for(int i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	int hh = 0, tt = -1;
	for(int i = 0; i < n; i++){
		// 判断队头是否已经滑出窗口，q[hh]表示的是下标
		if(hh <= tt && i - k + 1 > q[hh]) hh ++;
		while(hh <= tt && a[q[tt]] >= a[i]) tt--;

		q[++ tt] = i; // 将数组下标存入队列中
		if(i >= k - 1) printff("%d", a[q[hh]]);
	}

	puts("");

	hh = 0, tt = -1;
	for(int i = 0; i < n; i++){
		// 判断队头是否已经滑出窗口，q[hh]表示的是下标
		if(hh <= tt && i - k + 1 > q[hh]) hh ++;
		while(hh <= tt && a[q[tt]] <= a[i]) tt--;

		q[++ tt] = i; // 将数组下标存入队列中
		if(i >= k - 1) printff("%d", a[q[hh]]);
	}
	puts("");

	return 0;
}
```

## KMP
单模匹配算法：在一个文本串中*查找一个模式串*
算法包括预处理模式和匹配两部分
给定一个文本 $s$ 和一个字符串 $p$ ，我们尝试找到并展示 $p$ 在 $s$ 中的所有出现（occurrence）。
#### 暴力做法
```c++
s[N], p[M]

for (int i = 1; i <= n; i ++ ) // 母串
{
    bool flag = true;
    for (int j = 1; j <= m; j ++ )  // 子 串
    {
        if (s[i + j - 1] != p[j])
        {
            flag=false;
            break;
        }
    }
}
```
这种做法容易想到，而且要是字符均不一样，复杂度也仅为$O(n)$，但是要是$p$前面的$m-1$个字符均找到匹配，只有最后一个字符不匹配，那么复杂度就会退化成$O(mn)$（$i$ 需要退回到一开始的 $i+1$ 位置，$j$ 需要退回到0）

#### KMP
KMP是一种任何情况下都能达到$O(m+n)$复杂度的算法，其要点是**避免回溯与Next\[]数组**
*核心思想：* 在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。
##### 避免回溯
1. P在失配点前*每个字符均不同*
此时 i 没有必要回溯，直接从 i = 当前值，j = 0，开始重新匹配即可
2. 有部分相同
	1. 相同的部分是**前缀和后缀**
		**滑动子串**，使得子串 $p$ 的前缀部分与 $s$ 的后缀部分**对齐**，此时 i 不变，j = L(重合长度)，然后重新开始匹配
	2. 相同部分不是前缀或后缀
		i 不变，j 回溯到位置0

![[微信截图_20231024102340.png]]

##### Next\[]数组：最长公共前后缀
Next[]数组是KMP算法的关键，对Next\[ j ] ，是p\[1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 `p[1, next[j]] = p[j - next[j] + 1, j]`，称为“最长公共前后缀”
![[微信截图_20231024183617.png]]

##### 实现
###### 求next数组
![[微信截图_20231024185039.png]]
```c++
for(int i = 2, j = 0; i <= m; i++)  
// i = 2 的原因是next[1] = 0，且下标从1开始， 所以从第二个元素开始，把 i 的增加看作后缀的逐步扩展
// j = 0 是固定的，一般都是j+1进行匹配，即从p[1]开始匹配，这样代码比较简洁易懂
// 注意 j 的值与 i 一样不会因为循环而重新初始化
{
	// 退出循环条件：j 回溯到0，或者发生失配，这里(j!=0)条件是必须的，因为需要有退出条件，j = 0 时退出while循环
    while(j && p[i] != p[j+1]) j = next[j]; 
    
    // 当前位置的字符匹配，则继续，令 j 在原本的基础上 +1
    if(p[i] == p[j+1]) j++;
    // 更新 j 
    next[i] = j; // 
}
```
举个例子，假如子串是这个：
![[微信图片_20231025115922.jpg]]
###### 匹配字符串
![[微信截图_20231024185349.png]]
```c++
for(int i = 1, j = 0; i <= n; i++)
{
    while(j && s[i] != p[j+1]) j = ne[j]; // 发生失配则 j 滑动到Next[j]位置
    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)

    if(s[i] == p[j+1]) j++;
    //当前元素匹配，j移向p串下一位
    if(j == m)
    {
        //匹配成功，进行相关操作，以下为一个举例
        j = next[j];  //继续匹配下一个子串
    }
}
```

#### 完整代码
```c++
#include<iostream>

using namespace std;

const int N = 100010, M =  1000010; //N为模式串长度，M匹配串长度

int n, m;
char p[N], s[M]; //s为模式串， p为匹配串
int ne[N]; //next[]数组，避免和头文件next冲突

int main(void){
	cin >> n >> p + 1 >> m >> s + 1; // cin读入可以直接读取整个字符串内容，此处p+1和s+1均代表从1开始存放

	// 求next过程
	for(int i = 2, j = 0; i <= n; i ++){ 
	// 注意 j 的值与 i 一样不会因为循环而重新初始化
		while(j && p[i] != p[j + 1]) j = ne[j];
		if(p[i] == p[j + 1]) j ++;
		ne[i] = j;
	}
	//匹配操作
	for(int i = 1, j = 0; i <= m; i ++){  // 从0开始
		while(j && s[i] != p[j + 1]) j = ne[j]; // 要么 j 无法再退后，要么不能往下走
		if(s[i] == p[j + 1]) j ++;
		if(j == n){  //满足匹配条件，打印开头下标, 从0开始
			//匹配完成后的具体操作
            //如：输出以0开始的匹配子串的首字母下标
			printf("%d ", i - n);
			j = ne[j];   //再次继续匹配
		}
	}
	return 0;
}
```

函数体形式：
```c++
#include<iostream>  
  
using namespace std;  
  
const int N = 100010, M = 1000010;  
  
int n, m; // n 为子串长度， m为母串长度  
char p[N], s[M];  
int ne[N];  
  
void getNext(char *p, int n){  
    for(int i = 2, j = 0; i <= n; i ++){ // 注意这里的 i < plen  
        while( j && p[i] != p[j + 1]) j = ne[j];  
        if(p[i] == p[j + 1]) j ++;  
        ne[i] = j;  
    }  
}  
  
void kmp(char *s, char *p){ // 注意这里的 plen  
    getNext(p, n);  
    for(int i = 1, j = 0; i <= m; i++){ // 注意这里的 i < m  
        while (j && s[i] != p[j+1]) j = ne[j];  
          
        if(s[i] == p[j+1]) j++;  
          
        if(j == n){ // 注意这里的 plen  
            printf("%d ", i - n);  
            j = ne[j];   
        }  
    }  
}  
  
int main(void){  
    cin >> n >> p + 1 >> m >> s + 1;  
    kmp(s, p);  
}
```

## 字典树(Trie)
高效存储和查找字符串集合的数据结构

*复杂‘： 逐个匹配，遍历所有*
Tire操作：模拟查字典，按照索引找

**基本性质：**
- 根节点*不包含字符*，除根节点外的每个子节点都包含一个字符
- 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串
- 一个完整的单词并不是存储在某个节点上，而是*存储在一条链上*
- 一个节点的*所有字节点都有相同的前缀*

限制字符为英文
eg. abcdef, abdef, aced, bcdf, bcdf, cdaa, bcdc ,abc
![[微信截图_20231025202910.png|475]]

**应用：**
1. 字符串检索
2. 词频统计
3. 字符串排序
4. 前缀匹配

模板：
```c++
#include<iostream>

using namespace std;

const int N = 100010;

int son[N][26], cnt[N], idx;
// son存的是每个节点的所有儿子是什么，即树的下一个子节点的位置，实际上是数组模拟的指针
// cnt 存的是以 x 为结尾的点出现次数
// 下标为0的点既是根节点，又是空结点
// idx与单链表相同，指的当前移动到的结点

void insert(char str[]){
	int p = 0;
	for(int i = 0; str[i]; i++) // 当i到最后时str[i] = 0退出循环
	{
		int u = str[i] - 'a'; 
		// 将字母映射成为数字，得到对应的子节点编号
		if(!son[p][u]) son[p][u] = ++ idx; 
		//如果son的[p][u]不存在，则将其创建出来
		p = son[p][u];  // 沿着字典树往下走，新的儿子
	}

	cnt[p]++; // 统计这个后缀出现过几次，就是c[idx]++，即给这个单词出现次数+1
}

int query(char str[]){
	int p = 0;
	for(int i = 0; str[i]; i++){
		int u = str[i] - 'a';
		if(!son[p][u]) return 0; // 第一个就找不到
		p = son[p][u];
	}
	return cnt[p];  // 返回该字符串的次数
}

int main(void){
	int n;
	scanf("%d", &n);
	while(n--){
		char op[2];
		char str[N];
		scanf("%s%s", op, str); // op读入了一个空格，所以才要设置长度为2
		if(op[0] == 'I') insert(str);
		else printf("%d\n", query(str));
	}
	return 0;
}
```

>关于理解`int son[N][26]`这个二维数组的心得：
>`Tire`树本质上一个多叉树，最多可以分多少叉呢？因为此题存的都是小写字母，所以是`26叉`；
>这里就解释了son这个二维数组的**第二维**的含义，就是他最多有26个孩子，那么他是谁呢，他当然是**结点**了，那结点之间怎么区分，或者这些孩子的爸爸叫啥，爸爸们用下标来区别，所以**第一维**就是爸爸们的id，`son[0][1]`含义就是0号爸爸有个儿子b ，那`son[0][1] = 2`，就是0号爸爸有个儿子`b`，儿子的id是2； 这些id就是由idx来赋值的；
>
>idx可以理解为计划生育的管理局的给上户口的，生一个孩子，给孩子上身份证，证件上ID 为`++idx` ，而孩子叫啥，其实就是26个小写字母中的其中一个了；
>
>对于每个结点而言，可以知道他有没有这个孩子，有的话叫啥，在哪里；
>对于**查询**，从根节点一路查下来，就可以找到某个字符串在不在；
>对于**插入字符串**，也是一路下来，看有没有这个儿子，没有了给你生个儿子，有了继续给下面找，所以只插入该字符串中原来不存在的字符即可； 也就是利用了公共前缀来降低查询时间的开销以达到提高效率的目的;
>
>随便给一个结点`[x][y]`, 并不能看出它在第几层，只能知道，它的儿子是谁

## 并查集
作用：
1. 将两个集合合并
2. 询问两个元素是否在一个集合当中

**基本原理：**
用一个树来表示一个集合
集合编号为根节点编号

对于每个点均存储其*父节点*p\[x]
对于每个点，均找其父节点，若不为根节点，则继续向上找

*问题1：* 判断树根: `if (p[x] == x)`
*问题2：* 如何求x的集合编号：`while(p[x] != x) x = p[x];`
	**优化**：一旦找到了根节点，就会令路径上所有的点都指向根节点(**路径压缩**，复杂度接近$O(1)$)![[微信截图_20231026214648.png|450]]
*问题三：* 如何合并两个集合：px是x的集合编号，py是y的集合编号,p\[x] = y
![[微信截图_20231026214159.png|500]]

模板：
```c++
#include<iostream>

using namespace std;

const int N = 100010;

int p[N]; // 存储父节点

int find(int x){  // 返回x的祖宗节点，加上路径压缩
	if(p[x] != x) p[x] = find(p[x]);  // 递归，实现压缩
	return p[x];  // 最终返回祖宗节点
}

int main(){
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) p[i] = i;

	while(m--){
		char op[2];
		int a,b;
		scanf("%s%d%d", op, &a, &b); // scanf会读入一些空格和回车，读成字符串形式可以防止读入

		if(op[0] == 'M') p[find(a)] = find(b); // a的祖宗节点的父亲等于b的节点
		else {
			if(find(a) == find(b)) puts("Yes");
			else puts("No");
		}
	}
	retrun 0;
}
```

拓展：维护额外信息
#### Acwing 837.连通块中点的数量
注意可能有的编译器上会出现size重名的问题，比赛时最好改一下size的名字
```c++
#include<iostream>

using namespace std;

const int N = 100010;

int p[N], size[N]; // 存储父节点

int find(int x){  // 返回x的祖宗节点，加上路径压缩
	if(p[x] != x) p[x] = find(p[x]);  // 递归，实现压缩
	return p[x];  // 最终返回祖宗节点
}

int main(){
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		p[i] = i;
		size[i] = 1;
	}

	while(m--){
		char op[3];
		int a,b;
		scanf("%s", op); // scanf会读入一些空格和回车，读成字符串形式可以防止读入

		if(op[0] == 'C'){
			scanf("%d%d", &a, &b);
			if(find(a) == find(b)) continue;
			size([find(b)]) += size[find(a)];
			p[find(a)] = find(b); // a的祖宗节点的父亲等于b的节点	
		} 
		else if(op[1] == '1'){
			scanf("%d%d", &a, &b);
			if(find(a) == find(b)) puts("Yes");
			else puts("No");
		}else{
			scanf("%d", &a);
			printf("%d\n", size[find(a)]);
		}
	}
	retrun 0;
}
```

## 堆
1. 插入一个数
2. 求集合当中的最小值
3. 删除最小值
4. 删除任意一个元素
5. 修改任意一个元素

堆的基本结构：**完全二叉树**
除了最后一层可能不满，其他都是满的，最后一层从左至右排列
小根堆：每个根节点都小于等于左右子节点；*根节点为最小值*

**堆的存储：** 采用一维数组，下标从1开始
**x 的左儿子：2x，x 的右儿子：2x+1**
![[微信图片_20231102215212.jpg]]

基本操作：
`down`: 往下调整
`up`: 将节点上移 
![[微信图片_20231102220400.jpg|500]]
![[微信图片_20231102221346.jpg|500]]
![[微信图片_20231102221310.jpg|500]]
插入：
`heap[++size]=x; up(size)` 
查找最小值：
`heap[1]`
删除最小值：
用*最后一个元素*(最下右)覆盖堆顶元素，再size--干掉最后一个点，然后再让根节点往下走
`heap[1] = heap[size]; size--; down(1)`
删除任意元素：
用最后一个元素覆盖该元素，再size--干掉最后一个点，然后再up一遍，down一遍调整位置
`heap[k] = heap[size]; size--; down(k); up(k);`
修改任意元素：
把某个数修改完后，再up一遍,down一遍调整位置
`heap[k] = x; down(k); up(k);`

模板：**堆排序**
思路就是把数组建成堆，按照堆顶元素依次输出
求最小值复杂度为$O(1)$，插入和删除为$O(logn)$
```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;

int n, m ;
int h[N], size;

void down(int u){
	int t = u;
	if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2; // 判断有没有左儿子且满足根节点比左儿子大，如果均满足则让根节点等于左儿子
	if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;  // 如果右儿子更小那么替换为右儿子
	// 这样t存储的即为三个节点中最小的节点编号
	if(u != t){  // 说明根节点不是最小值，那么需要交换值
		swap(h[u], h[t]);
		down(t); 
		// 再执行下一次对交换位置后的子节点做down向下替换操作，递归
		// 只有不一样的时候才需要down操作
	}
}

void up(int u){
	while(u / 2 && h[u/2] > h[u]){  // 不为根节点且父节点大于该节点
		swap(h[u/2], h[u]);  // 交换
		u /= 2;  // 不断执行此操作
	}
}

int main(void){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &h[i]);
	size = n;

	for(int i = n/2; i; i--) {
		down(i); 
		// up(i); 这里不需要up了
	}
	
	// 从n/2开始down，即由于最后一层不用down，所以只要对最后一层往上的节点执行down操作即可，时间复杂度小于O(n)，由于是从下往上递归，故可以保证每个儿子都是已经排好的
	// 因为n是最大值，n/2是n的父节点，因为n是最大，所以n/2是最大的有子节点的父节点，所以从n/2往前遍历，就可以把整个数组遍历一遍

	while(m--){
		// printf("%d", h[i++]);  
        // 不能直接打印，堆只能保证根节点最大或最小，但子节点不能保证了  
        // 这里应该每打印一次根节点就进行一次排序
		printf("%d ", h[1]);  // 将第一个元素打印
		h[1] = h[size];  // 用最后一个节点填补
  		size--;   // size减小
		down(1);   // 再做一次down操作
		up(1); // down和up只会做一个
	}
	return 0;
}
```

对堆增加操作：
ph\[k]存放第k个插入点对应的堆下标，hp\[k]存储堆里的当前元素是第几个插入点
![[微信截图_20231103000745.png|500]]
```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;

int n, m ;
int h[N], ph[N], hp[N], size; 
// ph是通过次序找下标，hp是通过下标找次序

void heap_swap(int a, int b){
	swap(ph[hp[a]], ph[hp[b]]);
	swap(hp[a], hp[b]);
	swap(h[a], h[b]);
}

void down(int u){
	int t = u;
	if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2; 
	if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;  
	if(u != t){  
		heap_swap(u, t);
		down(t); 
	}
}

void up(int u){
	while(u / 2 && h[u/2] > h[u]){
		heap_swap(u/2, u);
		u /= 2;
	}
}

int main(void){
		int n;
		canf("%d", &n);
		while(n--){
			char op[10];
			scanf("%s", op); // 读入字符传操作
			if(!strcmp(op, "I")){
				scanf("%d", &x);
				size ++；
				m++;
				ph[m] = size, hp[size] = m;
				h[size] = x;
				up(size);
			}else if (!strcmp(op, "PM")) printf("%d\n", h[1]);
			else if (!strcmp(op, "DM")){
				heap_swap(1, size);
				size --; 
				down(1);
			}else if(!strcmp(op, "D")){
				scanf("%d", &k);
				k = ph[k];
				heap_swap(k, size);
				down(k), up(k);
			}else{
				scanf("%d%d", &k, &x);
				k = ph[k];
				h[k] = x;
				down(k), up(k);
			}
		}
	}
	return 0;
}
```

常用堆来实现优先队列，但是STL库也有`prioriry_queue`可以实现
```c++
#include<bits/stdc++>
using namespace std;
priority_queue<int, vector<int>, greater<int>> q;
int main(){
	int n;
	scanf("%d", &n);
	while(n--){
		int op; scanf("%d", &op);
		if(op == 1){
			int x; 
			scanf("%d", &x);
		}else if(op == 2) printf("%d\n", q.top());
		else q.pop();
	}
	return 0;
}
```

但通常优先队列中不只有数字这一信息，往往夹杂其他信息，如字符串等，所以这里需要使用`pair`容器
```c++
#include<bits/stdc++.h>

using namespace std;
// 自定义比较操作
struct Compare {  
    bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) {  
        return lhs.first > rhs.first; // 根据整数进行排序  
    }
};

string s1, s2;
priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q; 

int main(void){
    int n, p;
    scanf("%d", &n);
    while(n--){
        cin >> s1;
        if(s1 == "PUT") {
            cin >> s2 >> p;
            q.push({p, s2}); 
            // 注意，因为是pair，所以这里要加花括号将两个元素一起Push进去
        }
        if(s1 == "GET"){
            if(q.empty()) cout << "EMPTY QUEUE!" << endl;
            else{
                cout << q.top().second << endl;
                q.pop();
            }
        }
    }
}
```
`priority_queue`常用操作：`push()`,`pop()`,`top()`,`empty()`,`size()`

## 哈希表
作用：空间映射，把复杂的数据结构映射到小的数据结构($0\sim N$)
一般只有添加和查找两个操作
*离散化是一种特殊的哈希方式*

举例：数据范围$-10^9 \sim 10^9$
通过哈希函数映射：$h(x)\in(0,10^5)$

**添加x**：计算$h(x)$得到对应的哈希值，再插到对应槽
**查找x**：计算$h(x)$得到对应的哈希值，再进行寻找
*一般删除也不是直接删除，而是直接用一个`bool`数组打标记*

*Q:怎么写？*
一般情况：直接取模：$x\mod 10^5 \in (0,10^5)$ 一般模一个**质数**，并且离2的整数次方尽可能远
*Q:要是把两个数映射成同一个数怎么办？(冲突)*
采用开放寻址或拉链法
### 哈希表的存储结构
#### 开放寻址法
只开了一维数组，但一维数组范围一般要开到一维数组的$2-3$倍
类似于找坑位的操作：
**添加**：从第 $k$ 个坑位开始，一个坑位有人就往后找，直到找到没人的坑位为止
**查找**：类似操作，从第 $k$ 个坑位开始，如果当前坑位有人且为$x$ 则输出 $x$，有人且非 $x$ 则往后找，找完了没发现 $x$ 则说明 $x$ 不存在
```c++
#include<bits/stdc++.h>
using namespace std;

// 这里的k必须留大，不然可能会放不下
const int N = 200003, null = 0x3f3f3f3f;

int h[N]; 

int find(int x){  // 如果x存在，则返回它的位置，如果不在，则返回它应该在的位置
	int k = (x % N + N) % N;  
	// 将x映射到数组范围内
	while(h[k] != null && h[k] != x){
	// 从数组h[k]开始找，如果这个坑位有人那么就往下面找
		k++;
		if(k == N) k = 0;
	}
	return k;
}

int main(void){
	int n;
	scanf("%d", &n);

	memset(h, 0x3f, sizeof h); // 将所有槽都清空，赋值为ox3f3f3f3f，注意memset是按照字节赋值
	
	while(n--){
		char op[2];
		int x;
		scnaf("%s%d", op, &x);
		
		int k = find(x);  // 先转到相应的位置
		if(*op == 'I') h[k] = x; // x相当于op[0] == 'I'
		else{
			if(h[k] != null) puts("Yes"); 
			// 这里用h[k] == x 好像也可以
			else puts("No");
		}
	}
	return 0;
}
```
#### 拉链法
开一个*一维数组*来存储所有哈希值
当把 $x$ 映射到数的时候，给这个数组槽上拉一条链（链表），用来存储这个槽上已有的数
eg. $h(11)=3,\  h(23) = 3$
![[微信截图_20231125213815.png|500]]
![[微信截图_20231126110131.png|490]]
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 100003;

int h[N], e[N], ne[N], idx; 
// 跟图论的存储一样，都是邻接表的样式
// h[k]存放的是头指针

void insert(int x){
	int k = (x  % N + N) % N; 
	// c++中负数取模仍然为负数，为了使其变为正数，故在括号内先取模再+N，然后再取模一次
	e[idx] = x;
	ne[idx] = h[k]；
	h[k] = idx++; // 模仿单链表，新的点的ne[idx]指向h[k]，再让h[k]指向idx，头插法
}

bool find(int x){
	int k = (x % N + N) % N;
	for(int i = h[k]; i != -1; i = ne[i])
		if(e[i] == x) return ture;
	return  false;
}

int main(void){
	int n;
	scanf("%d", &n);

	memset(h, -1, sizeof h); // 将所有槽都清空，赋值为-1
	
	while(n--){
		char op[2];
		int x;
		scnaf("%s%d", op, &x);

		if(*op == 'I') insert(x);
		else{
			if(find(x)) puts("Yes");
			else puts("No");
		}
	}
	return 0;
}
```

##### 补充：`memset`函数
```c++
void *memset(void *str, int c, size_t n)
```
- 解释：复制字符`c`（一个无符号字符）到参数 `str` 所指向的字符串的前 `n` 个字符。
- 作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法
- 头文件：C中`#include<string.h>`，C++中`#include<cstring>`
看着介绍其实函数作用非常简单，就是用于初始化，但是需要注意的是memset赋值的时候是**按字节赋值**，是将参数化成二进制之后填入一个字节。
就比如想要通过`memset(a,100,sizeof a)`给`int`类型的数组赋值，你给第一个字节的是一百，转成二进制就是`0110 0100`，而`int`有四个字节，也就是说，一个`int`被赋值为`0110 0100,0110 0100,0110 0100,0110 0100，`对应的十进制是`1684300900`，根本不是你想要赋的值`100`，这也就解释了为什么数组中的元素的值都为`1684300900`。

###### memset初始化为无穷大
`memset(a , 0x3f , sizeof a);`
通过`memset`函数的介绍，上述初始化是将数组`a`的每个元素赋值为`0x3f3f3f3f`。`0x3f3f3f3f` 真的是个非常精巧的常量.
它十进制是` 1061109567`也就是 $10^9$ 级别的，和`0x7fffffff`一个数量级，`0x7fffffff`是`int`类型的最大值，即`231-1=2,147,483,647。`

### 字符串哈希方式： 字符串前缀哈希法
**作用：** 判断两个字符串是否相等
**核心：** 通过进制转换进行映射
举例：
`str = "ABCABCDEYXCACWing"
对应的哈希值：
`h[0] = 0`
`h[1]="A"的哈希值`
`h[2]="AB"的哈希值`
...
把字符串看作`P进制`的数，如"ABCD"，把"A"看作 $1$，"B"看作 $2$，"C"看作 $3$，"D"看作 $4$，那么$$(1 \ 2\ 3\ 4)_P = 1 \times p^3+2 \times p^2 + 3 \times p^1 + 4 \times p^0 $$
从而将字符串转换成数字，最后再取模$$(1 \times p^3+2 \times p^2 + 3 \times p^1 + 4 \times p^0)\mod Q$$
最后将字符串转化为 $0\sim(Q-1)$ 范围内的数

**注意：**
1. 不能映射成$0$
2. 假定人品足够好，不会发生冲突
	一般情况下，假定$P = 131 或 P=13331$，$Q = 2^{64}$

**好处：** 可以利用前缀哈希*计算所有字串的哈希值*

*举例：*
![[微信截图_20231126120738.png]]
如图，`h[R], h[L-1]`哈希值已知，即已知$1\sim (L-1)$的哈希值和$1 \sim R$ 的哈希值，目标是计算$L \sim R$ 的哈希值

由刚刚的举例可知，左边为高位，右边为低位，由`h[R]`知，最高位为$P^{R-1}$，最低位为$P^0$；同理，对`h[L-1]`，高位为$P^{L-2}$，低位为$P^0$

故我们需要将两段对齐，将`h[L]`左移若干位(`h[L-1] * P^{R-L+1}`)，再让`h[R]`减去这一部分$$h[R]-h[L] \times P^{R-L+1}$$得到的即为字串的哈希值

**技巧**：用`unsigned long long`来存储所有的`h`，刚好为其长度，由于溢出，那么就不需要取模
预处理前缀的哈希值：$h(i)=h(i-1)  \times P + str[i]$ 

例子：判断**两个字串是否一致** -> 转化为**判断哈希值是否一致**
```c++
#include<bits/stdc++>
using namespace std;

typedef unsigned long long ull;

const int N = 100010, P = 131;

int n, m;
char str[N];
ull h[N], p[N]; // p[N]用来存进制

ull get(int l, int r){
	return h[r] - h[l-1] * p[r - l + 1];
}

int main(void){
	scaafn("%d%d%s", &n, &m, str + 1);

	p[0] = 1;
	for(int i = 1; i <= n; i++){
		p[i] = p[i-1] * P;
		h[i] = h[i] - 1 + P * str[i]; // 此处直接将aicii码堪称代表字符的数字

		while(m--){
			int l1, r1, l2, r2;
			scanf("$d$d$d$d", &l1, &l2, & r1, & r2);
			if(get(l1, r1) == get(l2, r2)) puts("Yes");
			else puts("No");
		}
	}
}
```

*与kmp的比较*
1. kmp可以用来求循环节
2. 其他情况下很多时候kmp不一定比哈希好

# 搜索与图论
## 深度优先搜索 DFS
- 尽可能往深处搜，搜不到再回溯
- 使用**栈**
- 空间复杂度为$O(n)$
- 不具有最短性质

*需要明确以什么形式进行搜索*
*回溯一定要注意恢复现场*
关键：**回溯与剪枝**

例子：全排列问题
![[微信截图_20231129194126.png|400]]
第一位有三种不同填法进入不同分支，第二位两种，第三位一种
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 10;
int n;
int path[N];
bool st[N]; // state，标识当前位置上哪些点用过了，为true表示被用过了

void dfs(int u){ // u 表示层数
	if(u == n){ // u == n 说明已经被填完了
		for(int i = 0; i < n; i++) printf("%d ", path[i]);
		puts(" ");
		return;
	}
	for(int i = 1; i <= n; i++){
		if(!st[i]){
			path[u] = i;
			st[i] = true;
			dfs(u + 1);
			//path[u] = 0;  这个会被覆盖掉，所以不用令其为0
			// 出来递归就要进行恢复
			st[i] = false; // 恢复现场，让i恢复原本没用过的状态，便于下次使用
		}
	}
}

int main(){
	cin >> n;

	dfs(0);

	return 0;
}
```
#### n 皇后问题
每一行、每一列、每一对角线均不能有重复
为了减小复杂度，需要考虑**剪枝**
##### 可行性剪枝
对可行性进行分析，如果每一行、每一列和每一对角线上有重复的，那么就提前回溯
![[n-hh.png]]
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 20;
int n;
char g[N][N];
bool col[N], dg[N], udg[N]; 
// state，标识当前位置上哪些点用过了，为true表示被用过了，dg表示对角线
// 这里不需要对行建立数组的原因是原本for就是按照行来排布的

void dfs(int u){ // u 表示层数
	if(u == n){ // u == n 说明已经被填完了
		for(int i = 0; i < n; i++) puts(g[i]);
		puts(" ");
		return;
	}
	for(int i = 0; i < n; i++){
		// 每一列、每一对角线均无放置，这里的坐标变换手推一下，n-u+i这里+n实际上是为了防止i-u为负数
		if(!col[i] && !dg[u + i] && !udg[n - u + i]){
			g[u][i] = 'Q';
			col[i] = dg[u + i] = udg[n - u + i] = true;
			dfs(u + 1);
			//path[u] = 0;  这个会被覆盖掉，所以不用令其为0
			// 出来递归就要进行恢复
			col[i] = dg[u + i] = udg[n - u + i] = false; // 恢复现场，让i恢复原本没用过的状态，便于下次使用
			g[u][i] = '.';
		}
	}
}

int main(){
	cin >> n;
	for(int i = 0; i < n; i ++)
		for(int j = 0; j < 0; j++) 
			g[i][j] = '.';
	
	dfs(0);

	return 0;
}
```
##### 原始枚举
时间复杂度$O(n^2)$
一个格子一个格子进行枚举，每个位置都有两种情况，当枚举完最后一个格子就知道答案，但时间复杂度高
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 20;
int n, x, y, s;
char g[N][N];
bool row[N], col[N], dg[N], udg[N]; 
// state，标识当前位置上哪些点用过了，为true表示被用过了，dg表示对角线
// 这里不需要对行建立数组的原因是原本for就是按照行来排布的

// s表示已经放上去的皇后个数
void dfs(int x, int y, int s){
	// 处理超出边界的情况
	if(y == n) y = 0, x++; 
	// 如果列填满了，那么将y再返回到原本位置，x++换行
	if(x == n) //  x==n说明已经枚举完n^2个位置了 
	{
		if(s == n){ // s==n说明成功放上去了n个皇后，那么这是一种可能情况
			for(int i = 0; i < n; i++) puts(g[i]);
			puts("");
		}
		return;
	}
	// 不放皇后
	dfs(x, y + 1, s);
	
	// 放皇后
	if(!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]){
		g[x][y] = 'Q';
		row[x] = col [y] = dg[x + y] = udg[x - y + n] = true;
		dfs(x, y + 1, s + 1);
		g[x][y] = '.';
		row[x] = col [y] = dg[x + y] = udg[x - y + n] = false;
	}
}

int main(){
	cin >> n;
	for(int i = 0; i < n; i ++)
		for(int j = 0; j < n; j++) 
			g[i][j] = '.';
	
	dfs(0, 0, 0);

	return 0;
}
```
## 宽度优先搜索 BFS
- 每次只会扩展一层
- 使用队列存储
- 由于一层层往下搜，空间复杂度为$O(2^n)$
- 第一次扩展到的点为其最短路，当权重为1时一定为**最短路**
#### 走迷宫
这里另一个比较重要的知识点是偏移量如何表示，采用向量表示
![[微信截图_20240116201917.png|475]]
```c++
#include<bits/stdc++.h>
using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
// g存入原始数据，d表示是否走过
int g[N][N], d[N][N];
PII q[N * N], Prev[N][N]; // 用pair来模拟queue，prev记录来时的路径

int bfs(){
	int hh = 0; tt = 0;
	q[0] = {0, 0};

	memset(d, -1, sizeof d);  // 用-1表示没走过，0表示走过了
	d[0][0] = 0;

	// 偏移量技巧
	int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

	while(hh <= tt){
		auto t = q[hh++];  // t类型与pair此时类型一致PII
		// t为pair数组的第hh元素

		for(int i = 0; i < 4; i ++){
			// 更新x, y
			int x = t.first + dx[i], y = t.second + dy[i];
			// x,y 符合边界且不存在障碍且可达
			if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1){
				// 过该点，设置为0
				d[x][y] = d[t.first][t.second] + 1;
				prev[x][y] = t;
				q[++ tt] = {x, y};
			}
		}
	}
/* 这部分是用于输出到达路径的
	int x = n - 1, y = m - 1;
	while(x || y){
		cout << x << ' ' << y << endl;
		auto t = Prev[x][y];
		// 更新x, y 
		x = t.first, y = t.second;
	} 
*/
	return d[n-1][m-1];
}

int main(void){
	cin >> n >> m;

	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			cin >> g[i][j];
		}
	}
	cout << bfs() << endl;
}
```
## 树与图的存储
**树是特殊的图：无环连通图**
**无向图是一种特殊的有向图**

一般存储：
	1. 邻接矩阵，存储稠密图 `g[a][b]`
	2. 邻接表，与哈希表的类似，用多条链表表示(孩子兄弟表示)
![[微信截图_20231108232914.png|284]]![[微信截图_20231108232943.png|342]]
增加一条边2->3，则采用尾插法
```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
// e存储值, ne存储next指针，h[N]因为有N个链表头

// 插入a指向b的边
void add(int a, int b){
	// 存入值，该点的next为原本h[a]对应的头，h[a]指向当前结点作为头
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int main(){
	scanf("%d", &n);
	// 初始化
	memset(h, -1, sizeof(h));
	for(int i = 0; i < n; i++){
		scanf("%d%d", &a, &b);
		add(a, b);
	} 
}
```

## 深度优先遍历
![[微信截图_20231109000943.png]]
特殊的深度优先与宽度优先搜索
```c++
bool st[N];  // 存储某个节点是否被标记 

void dfs(int u){
	st[u] = true; // 标记一下，已经被搜过了
	for(int i = h[u]; i != -1; i++){
		int j = e[i];
		if(!st[j]) dfs(j); // 不需要恢复
	}
}
```
#### 树的重心
重心：树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个结点被称为树的重心
![[162238_447c789cd9-树的重心.jpg]]
`sum`表示以这一点为根结点的树中所有结点个数
`res`表示删除这一点后的连通块中结点数目的最大值(不断更新)
`ans`表示所有(依次删除每个结点的情况)最大连通结点数目的最小值,即各个res的最小值(不断更新)
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 100010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
bool st[M];

int ans = N;
//a所对应的单链表中插入b  a作为根
void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

//返回以u为根的子树中节点的个数，包括u节点
int dfs(int u){
	st[u] = ture; // 标记已经被搜过

	int sum = 1；//存储 以u为根的树 的节点数, 包括u，如图中的4号节点
	int res = 0; //存储 删掉某个节点之后，最大的连通子图节点数
	//访问u的每个子节点
	for(int i = h[u]; i != -1; i = ne[i]){
		int j = e[i];
		//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问
		if(!st[j]){  // 如果j没有被标记过
			int s = dfs(j);  // u节点的单棵子树节点数 如图中的size值
			res = max(res, s); 
			// 记录最大联通子图的节点数分
			// 通过打擂台获得删除u后u子树中最大连通块的结点个数(图中6与3-9比谁结点多)
			sum += s;  
			// 以u为根结点的树结点数量=1+它各个子树的结点数量
		}
		
	}
	//n-sum 如图中的n-size值，不包括根节点4
	// 比较删除u后的u子树中最大的连通块(6,3-9中的更大者),和整个树减u子树剩下的连通块(1-2-8-5-7)
	res = max(res, n - sum); // 选择u节点为重心，最大的 连通子图节点数
	ans = min(ans, res);  //遍历过的假设重心中，最小的最大联通子图的节点数
	return sum;  // 返回以u为根的子树结点的个数(1+u的所有子树结点个数)
}

int main(void){
	cin >> n;
	memset(h, -1, sizeof h);
	// 题目接下来会输入，n-1行数据，
    // 树中是不存在环的，对于有n个节点的树，必定是n-1条边
	for(int i = 0; i < n - 1; i++){
		int a, b;
		cin >> a >> b;
		add(a, b), add(b, a); 
		// 因为是无向边所以要加入两条

		dfs(1); //可以任意选定一个节点开始 u<=n
		
		cout << ans << endl;
	}
}
```
## 宽度优先遍历
Acwing 847 图中点的层次
每条边的长度都是1，点的编号为1-n，求1号点到某点的最短路
直接宽搜

```c++
#iinclude<bits/stdc++.h>
using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx; // h表示head，当前节点的头节点，即兄弟节点, e表示对应点, ne表示next指针
int d[N], q[N];  // d为距离，q为队列

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
} // 必背，头插

int bfs(){
	int hh = 0, tt = 0;
	q[0] = 1; // 队列第一个为起点1
	
	memset(d, -1, sizeof d); // -1 表示没有遍历过
	d[1] = 0;  // 一定要记得还有个初始化，放在memset后面！！
	while(hh <= tt){
		int t = q[hh++];

		for(int i = h[t]; i != -1; i = ne[i]){
			int j = e[i];
			if(d[j] == -1){ // 数组模拟队列
				d[j] = d[t] + 1;
				q[++ tt] = j;
			}
		}
	}
	return d[n];  // 返回d[n]，不是d[n-1]!!因为读入点是从1开始！！
}

int main(){
	cin >> n >> m;  // 读入所有点、边

	memset(h, -1, sizeof h);  // 注意这里也要初始化！！！

	for(int i = 0; i < m; i++){
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	cout << bfs() << endl;
	
	return 0;
}
```

图的宽搜的应用：求拓扑序列
拓扑序列：针对有向图
一个无环图一定至少存在一个入度为0的点
有向无环图➡拓扑图

 入度为0的点作为起点
 1. 把所有入度为0的点入队列
 2. while(队列不空) 取出队头，枚举 t 的所有出边
 3. 删除 `t -> j, d[j]--`
 4. 如果 `d[j] = 0`， j 入队

```c++
#incldue<bits/stdc++.h>
using namespace std;

const int N = 100010;

itn n, m;
int h[N], e[N], ne[N], idx;
int q[N], d[N];

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool topsort(){
	int hh = 0, tt = -1; // 这里因为后面初始化是++ tt，所以这个地方应该从-1开始
	// 最开始初始化，将一开始入度为0的点加入队列
	for(int i = 1; i <= n; i++){ // 一定要注意这里是 i = 1开始，因为这里遍历的是点！
		if(!d[i]) // 如果入度为0，那么加入队列
			q[++ tt] = i;
	}
	
	while(hh <= tt){
		int t = q[hh++];
		for(int i = h[t]; i != -1; i = ne[i]){
			int j = e[i];
			d[j] --; // i 指向的 j 入度 -1
			if(d[j] == 0) q[++ tt] = j; // 如果入度为0， 加入队列，tt++，继续while循环
		}
	}
	return tt == n - 1;  // 如果 tt = n - 1，说明是有向无环图(tt从0开始)，否则就不是有向无环图，且此时队列中的顺序恰好就是拓扑排序结果
}

int main(void){
	cin >> n >> m;
	memset(h, -1, sizeof h);
	for(int i = 0; i < m; i++){
		int a, b;
		cin >> a >> b;
		add(a, b);
		d[b] ++; // b 的入度 +1
	}
	if(topsort()){
		for(int i = 0; i < n; i++) printf("%d ", q[i]);
	}else{
		puts("-1");
	}
}
```

## 最短路问题

考察的问题往往是建图(太真实了)，想办法把给的题目变成图
有向图和无向图其实没有区别，因为无向图只是特殊的有向图
### 单源最短路
#### 所有边权均为正数
##### 朴素Dijkstra算法 $O(n^2)$
与边数无关，适合稠密图(邻接矩阵存)
1. 初始化距离 `dist[1]=0, dist[i]=inf`，设 `s`为当前已确定最短距离的点
2. `for(i: range(n))`：循环`n`次即可得到到**各点**的最短距离
	1. `t:` 不在`s`中的，距离**最近**的点(找最近实际也是一重循环)，那么这点一定是最短路(基于贪心，原理可以回去看数据结构或者算法书，但这个之前学过，所以还好)
	2. `s <- t` 
	3. 用`t`更新其它点的距离
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];  // 确定哪些点没有确定最短路

int dijkstra(){
	memset(dist, 0x3f, sizeof dist); // 初始化为正无穷
	dist[1] = 0; // 起点距离为0

	// 由于算法一次只能更新一个点的最短距离，所以需要进行n次，才能得到起点到所有点的最短距离
	for(int i = 0; i < n; i++){
		int t = -1;  // 初始化
		for(int j = 1; j <= n; j++){
			// 在所有未找到最短路的点中找到最短dist的点
			if(!st[j] && (t == -1 || dist[t] > dist[j]))
				t = j; // 检查节点j是否未被标记且到起点的距离比当前最近的节点t更近。如果是，则更新t为j
		}
		if(t == n) break; // 已经找到最短距离，那么就不用再进行更新
		
		st[t] = true;  // 标记已被找到最短路

		// 用 t 更新所有点的距离
		for(int j = 1; j <= n; j++)
			dist[j] = min(dist[j], dist[t] + g[t][j]);
		// 在这个for循环中，原本已经是最短路的点不会被替代，但是不是最短路的点会被替换为dist[t]+g[t][j]进行逐步缩小
	}
	if(dist[n] == 0x3f3f3f3f) return -1;
	else return dist[n];
}

int main(void){
	scanf("%d%d", &n, &m);

	memset(g, 0x3f, sizeof g); // 初始化

	while(m--){
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		g([a][b]) = min(g[a][b], c); // 由于可能存在重边，所以用min保留最短边
	}
	int t = dijkstra();
	printf("%d\n", t);
	
	return 0;
}
```
##### 堆优化Dijkstra算法 $O(m \log n)$
稀疏图
找不在`s`中且距离最短的点可以用堆进行实现，从而优化时间复杂度
由于对堆更新需要$O(\log n)$，共$m$次(m条边)，所以对应的时间复杂度为$O(m \log n)$
**写法：** 手写堆/*优先队列*
```c++
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> PII;

const int N = 150010;
int n, m, idx;
int h[N], e[N], ne[N], w[N];
int dist[N];
bool st[N];

void(int a, int b, int c){
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int dijkstra(){
	memset(dist, 0x3f, sizeof dist); // 初始化为正无穷
	dist[1] = 0; // 起点距离为0

	priority_queue<PII, vector<PII>, greater<PII>> heap; // 小根堆
	// 用优先队列维护所有的距离，即使有重边也会因为小根堆的原因放在后面，而且后面还有st数组保证不会重复更新
	heap.push({0, 1}); // 第一次放入起点

	while(heap.size()){
		auto t = heap.top();  // 每次取出距离最小的点
		heap.pop();

		int ver = t.second, distance = t.first;
		if(st[ver]) continue; // 如果这个点之前出现，说明是冗余，直接continue
		st[ver] = true; // 如果没有这句会再次进入循环，速度会变慢，但是由于if语句的判断，保证仍然是最短，所以不会报错
		// 开始更新
		for(int i = h[ver]; i != -1; i = ne[i]){
			int j = e[i];
			if(dist[j] > distance + w[i]){
				dist[j] = distance + w[i];
				heap.push({dist[j], j});
			}
		}
	}
	if(dist[n] == 0x3f3f3f3f) return -1;
	else return dist[n];
}

int main(void){
	scanf("%d%d", &n, &m);

	memset(h, -1, sizeof h); // 初始化

	while(m--){
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		add(a, b, c);
	}
	int t = dijkstra();
	printf("%d\n", t);
	
	return 0;
}
```
#### 存在负权边
**如果有负权回路，则最短路不一定存在**
##### Bellman-Ford $O(nm)$
基本思路：
```
for n 次
	备份
	for 所有边 a, b, w  
	(存边方式可以用结构体)
		dist[b] = min(dist[b], dist[a] + w) // 松弛操作

一定满足：dist[b] <= dist[a] + w
```
迭代第k次的含义：从*1号点*出发，经过不超过k条边的最短路距离
**备份原因：**
可能会存在在更新时候由于一次前面的改变，导致后面所有都跟着改变的情况，但这个不符合原本的想法，于是用`backup`数组存放上一次更新的结果，这样就不会出现串联![[微信截图_20240227170659.png]]
#### acwing853 有边数限制的最短路
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 510, M = 100010;

int n, m, k;
int dist[N], backup[N];

struct Edge{
	int a, b, w;
} edges[M];

int bellman_ford(){
	memset(dist, 0x3f, zieof dist);
	dist[1] = 0;

	for(int i = 0; i < k; i++){
		memcpy(backup, dist, sizeof dist);
		for(int j = 0; j < m; j++){
			int a = edges[j].a, b = edge[j].b, w = edge[j].w;
			// 只用备份来更新，这样就不会出现串联的结果
			dist[b] = min(dist[b], backup[a] + w);
		}
	}
	// 这里 0x3f3f3f3f/2 的原因是一开始设的是 INF，但是如果存在负权回路，那么可能会在更新过程中使得这条边小于INF，所以这里设成了除以2
	if(dist[n] > 0x3f3f3f3f/2) return -1;
	return dist[n];
}

int main(void){
	scanf("%d%d%d", &n, &m, &k);
	while(m--){
		int a, b, w;
		scanf("%d%d%d", &a, &b, &w);
		edges[i] = {a, b, w};
	}
	int t = bellman_ford();

	if(t == -1) puts("impossible");
	else printf("%d\n", t);

	return 0;
}
```
##### SPFA $O(m)$，最坏$O(nm)$
**要求题目中不能存在负环**
不是所有情况都管用，比如如果求距离小于 $k$ 的所有点，这个时候就不能用
Bellmon-Ford的问题是，每次都会对所有边进行遍历与尝试更新，但是不一定每条边都会更新，只有当`dist[a]`发生变化时，`dist[b]`才可能更新。因此，SPFA算法基于BFS对这一问题进行优化，即只有被更新过的点才进行遍历

```
queue <- 1
while queue 不空
	1. t = q.front() 取出队头
	2. q.pop()
	3. 更新 t 的所有出边  t -w> b
		 queue <- b
```
#### Acwing 851
求1号点到n号点的最短距离，边权可能为负数
```c++
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> PII;

const int N = 100010;
int n, m, idx;
int h[N], e[N], ne[N], w[N];
int dist[N];
bool st[N];

void add(int a, int b, int c){
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa(){
	memset(dist, 0x3f, dist);
	dist[1] = 0;
	
	queue<int> q;
	q.push(1);
	st[1] = true;
	
// st数组存放的是数是不是在队列当中，防止存储重复的点
	while(q.size()){
		int t = q.front();
		q.pop();

		st[t] = false;

		for(int i = h[t]; i != -1; i = ne[i]){
			int j = e[j];
			if(dist[j] > dist[t] + w[i]){
				dist[j] = dist[t] + w[i];
				// 如果 j不在队列里面，那么加入进去
				if(!st[j]){
					q.push(j);
					st[j] = true;
				}
			}
		}
	}
	if(dist[n] == 0x3f3f3f3f) return -1;
	return dist[n];
}

int main(void){
	scanf("%d%d", &n, &m);

	memset(h, -1, sizeof h); // 初始化

	while(m--){
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		add(a, b, c);
	}
	int t = spfa();

	if(t == -1) puts("impossible");
	else printf("%d\n", t);
	
	return 0;
}
```
SPFA可以用来判负环，也是用抽屉原理
`dist[x]` 1~x的最短距离
`cnt[x]` 当前最短路的边数
```c++
dist[x] = dist[t] + w[i];
cnt[x] = cnt[t] + 1

if(cnt[x] >= n) printf("-1");
//说明经过了至少n条边，那么经过了n+1个点，说明一定有两个点相同
```

```c++
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> PII;

const int N = 100010;
int n, m, idx;
int h[N], e[N], ne[N], w[N];
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c){
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa(){
	// 负环可能从1号点到不了，所以这里需要进行修改，将所有点放入队列内
	queue<int> q;
	for(int i = 0; i <= n; i++){
		st[i] = true;
		q.push(i);
	}
	
// st数组存放的是数是不是在队列当中，防止存储重复的点
	while(q.size()){
		int t = q.front();
		q.pop();

		st[t] = false;

		for(int i = h[t]; i != -1; i = ne[i]){
			int j = e[j];
			if(dist[j] > dist[t] + w[i]){
				dist[j] = dist[t] + w[i];
				// 如果 j不在队列里面，那么加入进去
				cnt[j] = cnt[t] + 1;
				if(cnt[j] >= n) return true;
				
				if(!st[j]){
					q.push(j);
					st[j] = true;
				}
			}
		}
	}
	return false;
}

int main(void){
	scanf("%d%d", &n, &m);

	memset(h, -1, sizeof h); // 初始化

	while(m--){
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		add(a, b, c);
	}
	
	if(spfa()) puts("YES");
	else puts("NO");
}
```
### 多元汇最短路 Floyd算法 $O(n^3)$
基于动态规划
$$d[k, i, j]=d[k-1, i, k] + d[k-1, k, j]$$
不能有负权回路
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, Q;
int d[N][N];

void floyd(){
	for(int k = 1; k <= n; k++){
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= n; j++){
				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
			}
		}
	}

}

int main(void){
	scanf("%d%d%d", &n, &m, &Q);
	// 注意这里从 1 开始
	for(int i = 1; i<= n; i++){
		for(int j = 1; j <= n; j++){
			if(i == j) d[i][j] = 0;
			else d[i][j] = INF;
		}
	}

	while(m--){
		int a, b, w;
		scanf("%d%d%d", &a, &b, &w);

		d[a][b] = min(d[a][b], w);
	}
	floyd();

	while(Q--){
		int a, b;
		scnaf("%d%d", &a, &b);
		// 可能存在负权边
		if(d[a][b] > INF/2) puts("impossible");
		else printf("%d\n", d[a][b]);
	}
	return 0;
}
```

## 最小生成树
无向图

### Prim算法
#### 朴素版$O(n^2)$ 稠密图
用 s 表示在连通块中的点
正负边无关
```
dist[i] <- +INF
for(i = 0; i < n; i++){
	找到集合外距离最近的点
	用 t 更新其它点到 **集合** 的距离
	s[t] = true;
}
```
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim(){
	memset(dist, 0x3f, sizeof dist);

	int res = 0;
	// 所有点均要遍历
	for(int i = 0; i < n; i++){
		int t = -1; // 记录当前最短距离的节点
		// 遍历所有节点，找到距离最近且未被访问过的节点 `t`。
		for(int j = 1; j <= n; j++){
			if(!st[j] && (t == -1 || dist[t] > dist[j]))
				t = j;
		}
		// 如果遍历完了最近的点为正无穷，那么说明该点不连通
		if(i && dist[t] == INF) return INF;
		// 先累加，再更新
		if(i) res += dist[t];
		
		// 更新，找到目前的最短
		for(int j = 1; j <= n; j++)
			dist[j] = min(dist[j], g[t][j]); // 这个点到集合的距离
		// 不是第一个点
		
		st[t] = true;
	}
	return res;
}

int main(){
	scanf("%d%d", &n, &m);
	memset(g, 0x3f, sizeof g);

	while(m--){
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		g[a][b] = g[b][a] = min(g[a][b], c);
	}
	int t = prim();

	if(t == INF) puts("impossible");
	else printf("%d\n", t);
	
	return 0;
}

```
#### 堆优化法$O(mlogn)$ 不常用

### Kruskal算法$O(mlogm)$ 稀疏图
```
1. 将所有边按权重从小到大排序 O(mlogm)
2. 枚举每条边 a->b，权重c (并查集类似)
	 if a, b 不连通，则将这条边加入集合中
```
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 200010;

struct Edge{
	int a, b, w;
	bool operator < (const Edge &W) const{
		return w < W.w;
	}
}edges[N];

int find(int x){
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}

int main(){
	scanf("%d%d", &n, &m);

	for(int i = 0; i < m; i++){
		int a, b, w;
		scanf("%d%d%d", &a, &b, &w);
		edge[i] = {a, b, w};
	}
	// 所有边从小到大排序
	sort(edges, edges + m);
	// 初始化并查集
	for(int i = 1; i <= n; i++) p[i] = i;

	// cnt 存边数， res存结果
	int res = 0, cnt = 0;
	for(int i = 0; i < m; i ++){
		int a = edges[i].a, b = edges[i].b, w = edges[i].w;
		a = find(a), b = find(b);
		// 如果边不连通
		if(a != b){
			p[a] = b;
			res += w;
			cnt ++;
		}
	}
	if(cnt < n) puts("impossible");
	else printf("%d\n", res);

	return 0;
}
```

## 二分图
### 二分图判别——染色法$O(n+m)$
判断一个图是否为二分图(把所有的点分成两部分，每部分内部没有连边，集合之间才有连边)
>[!info] 一个图为二分图当且仅当图中不含奇数环
>由于图中不含奇数环，所以染色过程中一定没有矛盾
```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool dfs(int u, int c){
	color[u] = c;
	for(int i = h[u]; i != -1; i = ne[i]){
		int j = e[j];
		if(!color[j]){
			if(!dfs(j, 3-c)) return false;
		}else if (color[j] == c) return false;
	}
	return true;
}

int main(void){
	scanf("%d%d", &n, &m);
	memset(h, -1, sizeof h);

	while(m--){
		int a, b;
		scanf("%d%d", &a, &b);
		// 无向图
		add(a, b), add(b, a);
	}
	bool flag = true;
	for(int i = 1; i<= n; i++){
		if(!color[i]){
		// 如果染色过程出现异常，则将bool设为false
			if(!dfs(i, 1)){
				flag = false;
				break;
			}
		}
	}
	if(flag) puts("Yes");
	else puts("No");
}

```
### 匈牙利算法——求最大匹配，最坏$O(mn)$，实际远小于
给定一个二分图，求最大匹配
成功匹配：没有两条边连的是同一个点
![[微信截图_20240309212240.png|450]]

匈牙利算法是用于解决二分图最大匹配问题的经典算法之一。其主要步骤如下：
1. **初始化**：将所有的匹配关系初始化为空。
2. **从左侧顶点开始**：
    - 遍历所有的左侧顶点。
    - 对于每个左侧顶点，尝试为其找到一个右侧顶点进行匹配。
3. **寻找增广路径**：
    - 对于当前的左侧顶点，尝试从与其相连的所有未匹配的右侧顶点开始寻找增广路径。
    - 增广路径是一条交替经过匹配边和非匹配边的路径，其起点和终点分别是一个未匹配的左侧顶点和一个未匹配的右侧顶点。
4. **增广路径的寻找**：
    - 从当前的左侧顶点开始，如果存在一个未匹配的右侧顶点与其相连，直接匹配这两个顶点。
    - 如果不存在这样的右侧顶点，则尝试从与其相连的所有已匹配的右侧顶点开始寻找增广路径的延伸。
5. **递归寻找增广路径**：
    - 如果找到了一个已匹配的右侧顶点，尝试从这个右侧顶点已匹配的左侧顶点开始寻找增广路径的延伸。
    - 如果延伸成功，更新匹配关系，使得原本匹配的边变为非匹配的边，非匹配的边变为匹配的边。
6. **递归回溯**：
    - 如果无法找到增广路径的延伸，回溯到上一层递归，尝试寻找其他路径。
    - 直到找到一个增广路径或者无法找到增广路径为止。
7. **重复步骤2至步骤6**，直到所有的左侧顶点都找到了匹配，或者无法找到增广路径为止。
8. **输出匹配结果**：所有匹配的边即为最大匹配。
匈牙利算法的关键在于通过寻找增广路径来不断增加匹配的数量，直到无法找到增广路径为止
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 510, M = 100010;

// 只需要存左边指向右边
int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool find(int x){
	//遍历与左边节点 `x` 相连的所有右边节点 `j`
	for(int i = h[x]; i != -1; i = ne[x]){
		int j = e[i];
		// 如果右边节点 `j` 没有被访问过，或者右边节点 `j` 的匹配节点可以尝试找到另一个匹配，递归尝试匹配。
		if(!st[j]){
			st[j] = true;
			if(match[j] == 0 || find(match[j])){
				// 如果成功匹配，则更新右边节点 `j` 的匹配节点为左边节点 `x`
				match[j] = x;
				// 返回是否成功匹配右边节点 `x`
				return true;
			}
		}
	}
	return false;
}

int main(void){
	scanf("%d%d%d", &n1, &n2, &m);

	memset(h, -1, sizeof h);

	while(m--){
		int a, b;
		scanf("%d%d", &a, &b);
		add(a, b);
	}
	int res = 0;  // 匹配数量
	for(int i = -1; i <= n1; i++){
	// 清空 
		memset(st, false, sizeof st);
		if(find(i)) res++;
	}
	printf("%d\n", res);

	return 0;
}
```

# DP动态规划
## 常用模型 背包
### 01 背包 
$N$个物品，容量为$V$的背包
每件物品最多只用一次，每个物品体积$v_i$，价值$w_i$
要求给出最大价值

考虑的两种角度：
- 状态标识 $f(i,j)$
	- 集合：所有选法
		- 条件
			1. 只从前 $i$ 个物品中选
			2. 总体积 $i \leq j$
	- 属性： Max, Min, 数量
- 状态计算
	- 最后 $f(N, V)$，所有选法，总容量不超过 $V$ 的集合
	- 对应的是集合划分：不重不漏‘
	- 对于$f(i,j)$，其可以划分为
		- 不含 $i$ 的$f(i-1,j)$
		- 含 $i$ 的 $f(i,j)$
			- 先把所有物品中去掉 $i$，那么得到 $1 \sim i-1$个物品，对应的容量变为$j - v[i]$
			- 即为 $f(i-1, j -v[i])$
			- 这种情况当 $j < v[i]$ 时不存在
			- 故最后结果为$f(i-1, j - v[i]) + w[i]$
	- 最优$f(i,j)=\max\{f(i-1,j), f(i-1,j-v[i]) + w[i]\}$
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;

int n,m;
int v[N], w[N];
int f[N][N];

int main(){
	cin >> n >> m;

	for(int i = 1; i <= n; i++)
		cin >> v[i] >> w[i];

	for(int i = 1; i <= n ; i ++){
		for(int j = 0; j <= m; j++){
			f[i][j] = f[i - 1][j];
			if(j >= v[i]) f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
		}
	}
	cout << f[n][m] << endl;
}
``` 
优化：
- 每次计算$f[i]$时只用到了$f[i-1]$，故可以使用滚动数组
- $j < v[i]$ 的情况可以不考虑，故可以把二维降成一维
> 二维转化为一维：
> 删掉了第一维：在前i个物品中取。
> 
> ### 为何能转化为一维？
> 二维时的更新方式：`f[i][j]=max(f[i - 1][j] ,f[i - 1][j - v[i]] + w[i])`;
> 1. 我们发现，对于每次循环的下一组`i`，只会用到`i-1`来更新当前值，不会用到`i-2`及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。
> 所以对于`i`的更新，只需用一个数组，直接覆盖就行了。
> 2. 我们发现，对于每次`j`的更新，只需用到之前`i-1`时的`j`或者`j-v[i]`，不会用到后面的值。
> 所以为了防止串着改，我们采取**从后往前更新**的方式，用原来`i-1`的数组来更新i。
> （如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，这样就不能保证是用原来`i-1`的数组来更新`i`的了）
>
> ### 如何转化一维
> 只用一个数组，每次都覆盖前面的数组。
> 1. 如果当前位置的东西不拿的话，和前一位置的信息（原来`i-1`数组的这个位置上的值）是相同的，所以不用改变。
> 2. 如果当前位置的东西拿了的话，需要和前一位置的信息（原来`i-1`数组的这个位置上值）取max。
> 所以，更新方式就为：`f[j]=max(f[j],f[j-v[i]]+w[i])`;
>
> 整个更新方式就相当于：每次`i++`，就从后往前覆盖一遍 f 数组，看每个位置上的值是否更新。

```c++
for(int i = 1; i <= n; i++){
	for(int j = m; j >= v[i]; j--)
		f[j] = max(f[j], f[j - v[i]] + w[i]);
}
cout << f[m] <<endl;
```

### 完全背包
每件物品有**无限个**
状态表示 $f(i,j)$
- 集合：所有只考虑前 i 个物品，且总体积不大于 j 的所有选法
- 属性： max
状态计算
- 按第$i$个物品选了多少个来分：选0个、1个...k个
- 选k个算法
	- 去掉k个物品i
	- 求max$f[i-1, j-k*v[i]]$
	- 再加回来k个物品i
- $f[i,j]=f[i-1,j]+f[i-1,j-k*v[i]] + k*w[i]=f[i-1,j-v[i]*k]+w[i]*k$
```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main(void){
	cin >> n >> m;
	for(int i = 0; i <= n; i++) cin >> v[i] >> w[i];

	for(int i = 1; i <= n; i ++)
		for(int j = 0; j <= m; j++)
			for(int k = 0; k * v[i] <= j;k++)
				f[i][j] = max(f[i][j], f[i-1][j-v[i] * k] + w[i] * k);

	cout << f[n][m] << endl;
}
```
由于有三重循环，时间复杂度较高，可进行优化成2维
$$
\begin{equation}
	\begin{aligned}
		f[i,j] &= \max(f[i-1,j],&f[i-1,j-v]+w,\  &f[i-1][j-2v]+2w...) \\
		f[i, j - v] &= \max(&f[i-1, j-v], \ &f[i-1, j-2v] + w, \ f[i-1,j-3v]+2w...)
	\end{aligned}
\end{equation}
$$
每一项均一一对应，只是每一项均比下面多了一个w
最后可化为只有两项的关系：
![|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240401103029.png)
$$f[i,j] = \max(f[i-1,j],f[i,j-v] + w[i])$$
```c++
for(int i = 1; i <= n; i ++)
		for(int j = 0; j <= m; j++){
			f[i][j] = f[i-1][j];
			if(j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
		}	
```
这样时间复杂度会变成$O(n^2)$

**对比01背包：**
$$01背包：f[i,j] = \\\max(f[i-1, j], f[i-1, j - v]+w)$$
区别很小，只是将$i-1$换成了$i$

故也可以进行化为一维的操作
这里就不会有01背包时候，$i-1$的问题，可以直接从左向右进行枚举，$j-v[i]$保证从小到大进行循环
```c++
for(int i = 1; i <= n; i ++)
		for(int j = v[i]; j <= m; j++)
			f[j] = max(f[j], f[j - v[i]]+w[i]);
```
### 多重背包
每个物品有有限个
与完全背包类似
$$f[i,j] = \max(f[i-1,j-v[i]*k]+w[i]*k),k=0,1,2...,s[i]$$

 ```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main(void){
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i] >> s[i] ;

	for(int i = 1; i <= n; i ++)
		for(int j = 0; j <= m; j ++) 
			for(int k = 0; k <= s[i]; && k * v[i] <= j; k++)
				f[i][j] = max(f[i][j], f[i-1][j - v[i]*k] + w[i] * k);
}
```
优化：
从转移方程入手？
$$
\begin{equation}
	\begin{aligned}
	f[i,j] &= \max(f[i-1,j], &f[i-1,j-v]+w,f[i-1,j-2v]+2w,...f[i-1,j-sv]+ sw) \\
	f[i,j-v] &= \max(f[i-1,j-v], &f[i-1, j-2v]+w,...,f[i-1,j-(s-1)v]+(s-1)w,f[i-1,j-(s+1)v]+sw)
	\end{aligned}
\end{equation}
$$
发现后面多了一项，故不能采取这种方法进行优化

此处采用**二进制优化**
根据二进制计算原理，任何一个十进制整数$X$均可以用1，2，4，8等2的倍数相加得到，这些2的倍数只有$log_2 X$个。题目中第$i$个物品有$s_i$个，用$log_2 s_i$就能组合出 $0 \sim s_i$种情况

注意拆分的具体实现，**不能全部拆成2的倍数**，而是先按2的倍数从小到大拆，最后是一个小于或等于最大倍数的余数。从而保证拆出的数相加在$[1,s_i]$范围内，不会大于$s_i$
 
### 分组背包问题
$N$组，每组若干个，每组最多选一个

