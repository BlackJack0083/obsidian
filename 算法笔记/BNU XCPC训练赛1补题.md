### 失误点
1. dfs没切出来，很多个地方不熟练，包括搜索后状态没有还原、然后判断退出的条件有问题...
2. B题没有思路，感觉这种构造题，考思维的目前见得还是少，不怎么会做

# A rect-angle
## 题目描述
平面直角坐标系上有一个矩形，它的四条边都平行于 $x$ 或 $y$ 轴，并且它的面积不为零。
给出这个矩形的三个顶点的坐标 $(x_1,y_1),(x_2,y2),(x_3,y_3)$，请你求出另一个顶点的坐标。
## 输入格式
输入三行，每行两个整数 $x_i​,y_i$​，表示三个顶点坐标。
## 输出格式
输出两个整数 $x,y$，表示另一个顶点的坐标。
## 数据范围
- −100≤$x_i​,y_i​$≤100。
- 数据保证矩形存在，它的四条边都平行于 $x$ 或 $y$ 轴，并且它的面积不为零。
- 所有输入均为整数。
### 样例 1
|Inputcopy|Outputcopy|
|---|---|
|-1 -1<br>-1 2<br>3 2|3 -1|
### 样例 2
|Inputcopy|Outputcopy|
|---|---|
|-60 -40<br>-60 -80<br>-20 -80|-20 -40|
#### 思路
这题本身很简单，就只要看哪些 $x,y$ 只出现了一次，那么就是缺失的那个点的坐标。但是怎么统计那些只出现过一次的点呢？我当时没想太多直接用数组实现了，但是这样就会需要遍历两个数组，还需要开辟额外空间，然后听其他人说可以用`map`做，于是写了下，但感觉好像还是要开两个。
数组实现：
```c++
#include<bits/stdc++.h>  
using namespace std;  
  
const int N = 201;  
int x[N], y[N], xx, yy;  
  
int main(void){  
    for(int i = 0; i < 3; i++){  
        cin >> xx >> yy;  
        x[xx + 100]++, y[yy + 100]++;  
    }  
    for(int i = 0; i < N; i++){  
        if(x[i] == 1) printf("%d ", i - 100);  
    }  
    for(int i = 0; i < N; i++){  
        if(y[i] == 1) printf("%d", i - 100);  
    }  
}
```
于是翻题解，翻到了这个绝妙的**异或**操作：
```c++
#include<bits/stdc++.h>  
using namespace std;  
  
int main(void){  
    int x = 0, y = 0;  
    int xx , yy;  
    for(int i = 0; i < 3; i ++){  
        cin >> xx >> yy;  
        x ^= xx, y ^= yy;  
    }  
    cout << x << ' ' << y << endl;  
}
```
两次异或操作就可以消除重复的元素，代码非常简洁，而且不需要开额外空间进行存储



