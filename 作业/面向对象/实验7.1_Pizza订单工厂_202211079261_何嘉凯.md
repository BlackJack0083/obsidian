# 测试步骤
## 相关代码
```java
import java.util.Scanner;

public class OrderPizza {
	private Pizza pizza;
	public OrderPizza(String pizzaType) {
		this.pizza = PizzaFactory.createPizza(pizzaType);
	}
	
	public void displayPizza() {
		if(pizza != null) {
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			pizza.display();
		}
		else System.out.println("We don't have this pizza");
	}
	
	public static void main(String[] args) {
		System.out.println("please enter the type of pizza(pepper, Greek, cheese)");
		Scanner input = new Scanner(System.in); // 动态输入名字
		OrderPizza odpizza = new OrderPizza(input.nextLine());
		odpizza.displayPizza();
	}
}

abstract class Pizza{
	public abstract void display();
	public void prepare() {
		System.out.println("The pizza is preparing.");
	}
	public void bake() {
		System.out.println("The pizza is baking.");
	}
	public void cut() {
		System.out.println("The pizza is cutting");
	}
	public void box() {
		System.out.println("The pizza has been boxed into the box");
	}
}


class CheessPizza extends Pizza{
	public void display() {
		System.out.println("Cheese Pizza");
	}
}

class GreekPizza extends Pizza{
	public void display() {
		System.out.println("Greek Pizza");
	}
}

class PepperPizza extends Pizza{
	public void display() {
		System.out.println("Pepper Pizza");
	}
} 

class PizzaFactory{
	public static Pizza createPizza(String pizzaType) {
		if(pizzaType.equals("cheese")) {
			return new CheessPizza();
		}else if(pizzaType.equals("Greek")) {
			return new GreekPizza();
		}else if(pizzaType.equals("pepper")) {
			return new PepperPizza();
		}else {
			return null;
		}
	}
}
```

## 对应输出结果说明
![[微信截图_20231029204816.png]]
# 算法原理概述
### 对应的UML图
![[微信截图_20231029204518.png]]
### 原理阐述
1. **类之间的关系**：
    - `Pizza` 是一个抽象类，定义了制作和显示披萨的基本方法。
    - `CheessPizza`、`GreekPizza` 和 `PepperPizza` 是 `Pizza` 的具体子类，每个子类都重写了 `display` 方法以显示各自的披萨类型。
    - `PizzaFactory` 是一个工厂类，用于根据输入的披萨类型创建对应的披萨对象。
    - `OrderPizza` 是一个订购披萨的类，它包含一个 `Pizza` 对象，并根据披萨类型来制作和显示披萨，与`PizzaFactory`为关联关系
2. **重写（Override）**：
    - 在 `CheessPizza`、`GreekPizza` 和 `PepperPizza` 子类中，`display` 方法重写了父类 `Pizza` 中的 `display` 方法。
3. **抽象（Abstract）**：
    - `Pizza` 类被声明为抽象类，因为它包含一个抽象的 `display` 方法。这意味着 `Pizza` 类不能直接实例化，而只能通过子类来实现这个抽象方法。

整个流程是这样的：首先，通过 `OrderPizza` 类的构造函数输入披萨类型，然后使用 `PizzaFactory` 来创建对应的披萨对象。接着，调用 `displayPizza` 方法制作和显示该披萨。如果用户输入了一个不存在的披萨类型，系统会输出“We don't have this pizza”。

### 总结工厂范式
工厂范式是一种创建对象的设计模式，它允许通过一个共同的接口来创建不同类型的对象，而无需直接指定具体的类。工厂范式主要实现了以下两个目标：

1. **功能隔离**：工厂将对象的创建和使用分离，使得客户端代码只需要与工厂接口进行交互，而无需关心具体对象的创建细节。这样可以降低代码的耦合性，使得系统更加灵活和可扩展。
2. **实现细节的隐藏**：工厂封装了对象的创建过程，客户端代码无需知道具体的类名和构造函数，只需要通过工厂接口来获取所需的对象。这样可以保护系统的内部实现，使得代码更加健壮和易于维护。

在本代码中，`PizzaFactory` 类就是一个工厂类的实现，它负责根据输入的披萨类型来创建对应的披萨对象。客户端代码（`OrderPizza` 类）通过调用 `PizzaFactory` 的 `createPizza` 方法来获取所需的披萨对象，无需关心具体的披萨类的构造函数和实现细节。因此，本代码实现了工厂范式的功能隔离和实现细节的隐藏。

# 实验结果与验证
## 结果验证
详见输出结果，经检验得，符合实际情况，且实现新增口味(pepper pizza)的下单功能
## 讨论改进
1. **错误处理**：在 `PizzaFactory` 类中，如果输入的披萨类型不正确，它会返回 `null`。而在 `OrderPizza` 类中，只有当披萨对象不为 `null` 时才会制作和显示披萨。这种错误处理方式可能会导致系统在运行时抛出空指针异常。为了提高代码的健壮性，可以考虑在 `PizzaFactory` 类中添加错误处理逻辑，例如当输入的披萨类型不正确时抛出一个自定义的异常。
2. **可扩展性**：如果以后要添加新的披萨类型，需要修改 `PizzaFactory` 类的 `createPizza` 方法，并添加新的条件分支。为了提高代码的可扩展性，可以考虑使用设计模式中的“**开闭原则**”，即对扩展开放，对修改封闭。一种实现方式是使用反射机制和配置文件来动态创建披萨对象，这样就不需要修改 `PizzaFactory` 类的源代码，也可以尝试使用泛型方法。
3. **代码可读性**：在 `OrderPizza` 类中，制作和显示披萨的过程被封装在 `displayPizza` 方法中，这个方法包含了多个步骤的调用。为了提高代码的可读性，可以考虑将这个过程分解为多个小方法，每个方法对应一个步骤，这样可以让代码更加清晰易懂。
