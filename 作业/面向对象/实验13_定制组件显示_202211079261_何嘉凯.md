# 测试步骤
## 相关代码
原始代码，仿照画椭圆的方法写的，发现和老师的重复度太高了，就写了第二版，讨论改进部分结合MVC设计模式对代码进行了进一步优化：
```java
package lesson13;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class RectDrawer extends JPanel implements Runnable{
	private Color[] colors = {Color.RED, Color.BLACK, Color.BLUE, Color.GREEN, Color.DARK_GRAY};
	private Color color;
	private int x = 20, y = 20, width = 20, height = 20; 
	
	@Override
	public void run() {
		while(true) {
			x = (int)(Math.random() * 300);
			y = (int)(Math.random() * 300);
			width = (int)(Math.random() * 100);
			height = (int)(Math.random() * 100);
			color = colors[(int)(Math.random() * (colors.length - 1))];
			
			repaint();
			
			try {
				Thread.sleep(300);
			}catch(InterruptedException e) {
				throw new RuntimeException(e);
			}
		}
	}
	public RectDrawer(){
		new Thread(this).start();
	}
	
	public void paintComponent(Graphics g){
		super.paintComponent(g);
		g.setColor(color);
		g.fillRect(x,y,width,height); //画矩形
	}
	
	public static void main(String args[]){
		JPanel panel=new RectDrawer();
		JFrame frame=new JFrame("Hello");
		frame.setContentPane(panel);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300,300);
		frame.setVisible(true);
	}
}
```
第二版：
```java
package lesson13;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.Random;

public class RectDrawer extends JPanel implements Runnable{
	private int x = 20, y = 20, width = 20, height = 20; 
	private Random random = new Random();
	private Color color;
	
	public static Color generateRandomColor() {
        Random random = new Random();
        int red = random.nextInt(256); // 0 to 255
        int green = random.nextInt(256); // 0 to 255
        int blue = random.nextInt(256); // 0 to 255

        return new Color(red, green, blue);
    }
	
	@Override
	public void run() {
		while(true) {
			x = random.nextInt(300);
	        y = random.nextInt(300);
	        width = random.nextInt(300);
	        height = random.nextInt(300);
			color = generateRandomColor();
			repaint();
			try {
				Thread.sleep(1000);
			}catch(InterruptedException e) {
				throw new RuntimeException(e);
			}
		}
	}
	public RectDrawer(){
		new Thread(this).start();
	}
	
	public void paintComponent(Graphics g){
		super.paintComponent(g);
		g.setColor(color);
		g.fillRect(x,y,width,height); //画矩形
	}
	
	public static void main(String args[]){
		JPanel panel=new RectDrawer();
		JFrame frame=new JFrame("Hello");
		frame.setContentPane(panel);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(400,400);
		frame.setVisible(true);
	}
}
```
## 对应结果输出
![[微信截图_20231217125025.png|205]]![[微信截图_20231217124905.png|200]]![[微信截图_20231217125031.png|200]]
# 算法原理阐述
## 对应的UML图
![[微信截图_20231217125715.png|319]]
## 原理阐述
### 成员变量：
1. **`x`, `y`, `width`, `height`：** 整数类型的成员变量，表示矩形的位置和尺寸。
2. **`random`：** `Random` 类型的成员变量，用于生成随机数。
3. **`color`：** `Color` 类型的成员变量，表示矩形的颜色。
### 方法阐述：
1. **`generateRandomColor()`：**
	改进了原本代码中的颜色数组，改为用RGB值显示颜色，通过生成三个随机的数值来生成不同的RGB值表示颜色，同时设为静态方法，利于直接调用

*Color构造方法：*
在 `java.awt.Color` 类中，有多个构造器用于创建颜色对象。以下是一些常用的构造器：
1. **通过RGB值创建：**
   ```java
   Color(int r, int g, int b)
   ```
   这个构造器接受三个整数参数，分别代表红、绿、蓝三个颜色分量的值，范围是 0 到 255。

2. **通过RGB值和透明度创建：**
   ```java
   Color(int r, int g, int b, int a)
   ```
   这个构造器与上面的相似，但多了一个参数 `a`，表示透明度（范围是 0 到 255）。0 表示完全透明，255 表示完全不透明。

3. **通过HSB值创建：**
   ```java
   Color(float h, float s, float b)
   ```
   这个构造器接受三个浮点数参数，分别代表色相（Hue）、饱和度（Saturation）、亮度（Brightness）。这些值的范围是 0.0 到 1.0。

4. **通过亮度和透明度创建灰度颜色：**
   ```java
   Color(int gray, int alpha)
   ```
   这个构造器用于创建灰度颜色，其中 `gray` 表示灰度值（0 到 255），`alpha` 表示透明度。

5. **通过16进制值创建：**
   ```java
   Color(int rgb)
   ```
   这个构造器接受一个整数参数，表示颜色的 RGB 值。RGB 值可以用十六进制表示，例如，0xFF0000 表示红色。

这些构造器提供了多种方式来创建 `Color` 对象，以满足不同的需求和表示颜色的方式。

2. **`run()`：**
	实现了 `Runnable` 接口的 `run` 方法。在一个无限循环中，它生成随机的矩形位置、尺寸和颜色，然后调用 `repaint` 方法请求重绘，最后通过 `Thread.sleep(1000)` 使线程休眠 1 秒。
3. **`paintComponent(Graphics g)`：**
	重写了 `JPanel` 类的 `paintComponent` 方法，用于绘制矩形。设置矩形的颜色并绘制矩形。
### 使用：
在 `main` 方法中创建了一个 `RectDrawer` 的实例，并将其作为内容面板添加到 `JFrame` 中，然后设置一些基本的 `JFrame` 属性，最后使其可见。
# 实验结果与验证
## 结果验证
与老师代码结果进行比较，结果无误，代码正确
## 讨论改进
使用MVC设计模式改进：
MVC（Model-View-Controller）是一种经典的软件设计模式，旨在将应用程序分为三个主要组件，以提高代码的可维护性和灵活性。这三个组件分别是：
1. **Model（模型）：**
   - 模型表示应用程序的数据和业务逻辑。
   - 它负责维护数据的状态，以及定义和执行与数据相关的操作。
   - 模型是应用程序的核心，但不直接处理用户界面。
2. **View（视图）：**
   - 视图是用户界面的表示，负责显示模型中的数据给用户。
   - 它接收用户输入，但不处理业务逻辑或数据操作。
   - 视图通常是观察模型的变化，以便在数据发生变化时及时更新界面。
3. **Controller（控制器）：**
   - 控制器负责处理用户的输入，调用模型进行相应的操作，并更新视图。
   - 它充当模型和视图之间的桥梁，协调用户界面和应用程序逻辑之间的交互。
   - 控制器通常包含应用程序的业务逻辑。

MVC的基本思想是通过这三个组件的分离，使得每个组件都可以独立变化，从而提高了系统的可扩展性和可维护性。这种分层结构使得开发人员可以更容易地修改或替换系统中的一个组件而不影响其他部分。

一般而言，用户通过与视图进行交互，视图将用户的输入传递给控制器，控制器处理输入并更新模型，模型的变化通知视图更新显示。这种交互流程有助于实现代码的松耦合和可维护性。

基于此对代码进行改进：
1. **创建模型（Model）：**
   ```java
   import java.awt.Color;
   import java.util.Random;

   public class RectModel {
       private int x, y, width, height;
       private Color color;

       public void updateData() {
           Random random = new Random();
           x = random.nextInt(300);
           y = random.nextInt(300);
           width = random.nextInt(300);
           height = random.nextInt(300);
           color = generateRandomColor();
       }

       public int getX() {return x;}
       public int getY() {return y;}
       public int getWidth() {return width;}
       public int getHeight() {return height;}
       public Color getColor() {return color;}

       private Color generateRandomColor() {
           Random random = new Random();
           int red = random.nextInt(256);
           int green = random.nextInt(256);
           int blue = random.nextInt(256);

           return new Color(red, green, blue);
       }
   }
   ```

2. **创建控制器（Controller）：**
   ```java
   public class RectController {
       private RectModel model;

       public RectController(RectModel model) {
           this.model = model;
       }

       public void handleUserInput() {
           model.updateData();
       }
   }
   ```

3. **修改视图（View）：**
   ```java
   import java.awt.Graphics;
   import javax.swing.JPanel;

   public class RectDrawer extends JPanel {
       private RectController controller;

       public RectDrawer(RectController controller) {
           this.controller = controller;
       }

       @Override
       public void paintComponent(Graphics g) {
           super.paintComponent(g);
           RectModel model = controller.getModel();
           g.setColor(model.getColor());
           g.fillRect(model.getX(), model.getY(), model.getWidth(), model.getHeight());
       }
   }
   ```

4. **在主方法中实例化和连接三者：**
   ```java
   import javax.swing.JFrame;

   public class Main {
       public static void main(String[] args) {
           RectModel model = new RectModel();
           RectController controller = new RectController(model);
           RectDrawer drawer = new RectDrawer(controller);

           JFrame frame = new JFrame("Hello");
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.setSize(400, 400);
           frame.setContentPane(drawer);
           frame.setVisible(true);

           // Start the update loop
           while (true) {
               controller.handleUserInput();
               drawer.repaint();
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
           }
       }
   }
   ```

`RectModel` 负责维护矩形的数据和状态，`RectController` 负责处理用户输入和更新模型，而 `RectDrawer` 作为视图则负责绘制矩形。在主方法中，创建了这三个组件，并使用 `handleUserInput` 方法更新模型数据，然后调用 `repaint` 方法刷新视图。这样使得代码更具有模块性和可维护性，符合MVC设计模式的基本原则。