# 测试步骤
## 相关代码
```java
public class Bank {
	protected int year, posit;
	protected double rate;
	public Bank(int year, int posit, double rate) { // 构造函数
		this.year = year;
		this.posit = posit;
		this.rate = rate;
	}
	
	public Bank(double year, int posit, double rate) {} // 便于后续继承
	public double getInterest() {return year * rate * posit;}  // 计算利润
	
	public static void main(String[] args) {
		int amount = 10000;
		Bank bank0 = new Bank(2, amount, 0.035);
		// System.out.printf("央行利息为%.2f%n", bank0.getInterest()); 用printf写法
		System.out.println("央行利息为" + bank0.getInterest()); // 测试央行
		CCB bank1 = new CCB(2.5, amount, 0.035);
		System.out.println("建设银行利息为" + bank1.getInterest()); // 测试CCB
		DLB bank2 = new DLB(2.5, amount, 0.035);
		System.out.println("大连银行利息为" + bank2.getInterest()); // 测试DLB
	}
}
	
class CCB extends Bank{
	private double year;
	public CCB(double year, int posit, double rate) {  // 构造器
		super(year, posit, rate);
		this.year = year;
		this.posit = posit;
		this.rate = rate;
	}
	
	public double getInterest() {  // 计算利润，方法重写
		double yearInterest = (int)year * rate * posit;
		double dayInterest = (year - (int)year) * rate * posit;
		return yearInterest + dayInterest;
	}
}
	
class DLB extends Bank{
	private double year;
	public DLB(double year, int posit, double rate) {
		super(year, posit, rate);
		this.year = year;
		this.posit = posit;
		this.rate = rate;
	}

	public double getInterest() {
		double yearInterest = (int)year * 1.2 * rate * posit;
		double dayInterest = (year - (int)year) * 1.2 * rate * posit;
		return yearInterest + dayInterest;
	}
}
```

## 对应输出结果说明
![[微信截图_20231029200302.png]]

# 算法原理概述
### 对应的UML图
![[微信截图_20231029201739.png]]
### 原理阐述
1. **Bank类**：
    - `Bank`类中定义了三个成员变量：`year`，`posit`和`rate`。
    - 它有一个构造函数，用于初始化这三个变量。
    - 还定义了一个`getInterest`方法，用于计算利息。
2. **继承关系**：
    - `CCB`和`DLB`都是`Bank`类的子类。这意味着它们继承了`Bank`类的属性和方法。
3. **方法的重写**：
    - 在`CCB`和`DLB`类中，都重写了父类`Bank`的`getInterest`方法。这是方法重写的例子，子类根据自己的需求重新定义了父类的方法。
4. **构造函数的重载**：
    - 在`Bank`类中，存在两个构造函数，一个是接受`int`类型的`year`，另一个是接受`double`类型的`year`。这是构造函数的重载，即同一个类中可以有多个同名但参数列表不同的构造函数。
5. **代码逻辑**：
    - 在`main`方法中，分别创建了`Bank`，`CCB`和`DLB`的对象，并通过调用它们的`getInterest`方法来计算并打印利息。

总结：这段代码展示了继承、方法重写和构造函数重载的应用。其中`Bank`是基类，`CCB`和`DLB`是继承自`Bank`的子类，并且这两个子类都重写了父类的`getInterest`方法。在`Bank`类中，存在两个重载的构造函数。

# 实验结果与验证
## 结果验证
央行：$10000 \times 0.35 \times 2 = 700$
建设银行：$10000 \times 0.35 \times 2.5 = 875$
大连银行：$10000 \times 0.35 \times 2.5 \times 1.2 = 1050$
经检验得，以上结果均正确，代码无误
## 讨论改进
1. **封装性**：`Bank` 类中的 `year`，`posit` 和 `rate` 变量被声明为 `protected`，这意味着它们可以被子类直接访问。为了更好的封装性，可以考虑将它们设置为 `private`，并通过 `getter` 和 `setter` 方法进行访问和修改。
2. **避免数据冗余**：在 `CCB` 和 `DLB` 子类中，重新定义了 `year`，`posit` 和 `rate` 变量，其实是不必要的，因为继承自 `Bank` 类的变量已经足够使用，可以考虑移除这些冗余的变量定义。
3. **代码复用**：`CCB` 和 `DLB` 类中的 `getInterest` 方法有大量重复的代码，可以考虑将这些重复的代码提取到一个公共的方法中，以提高代码的复用性。
4. **类型转换**：在 `getInterest` 方法中，有多次类型转换操作。这可能会导致精度损失或引发其他问题。如果可能的话，尽量避免类型转换或者确保类型转换是安全的。