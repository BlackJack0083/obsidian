😓以为写完了，结果发现老师发的代码更好，所以重新补上后面的修正，顺便学习一下
# 测试步骤
## 相关代码
*我自己的：*
```java
package lesson12;

class Tortoise implements Runnable{
	private int totalSteps;
	private int tortoiseSteps = 0;
	
	public Tortoise(int steps) {
		this.totalSteps = steps;
	}
	
	public void run() {
		while(tortoiseSteps < totalSteps) {
			tortoiseSteps++;
			System.out.println("乌龟跑了" + tortoiseSteps + "步...");
		}
		if(tortoiseSteps == totalSteps) {
			System.out.println("乌龟结束了比赛");
			System.exit(0);
		}
	}
}

class Hare implements Runnable{
	private int totalSteps;
	private int hareSteps = 0;
	private boolean isHareSleep;
	
	public Hare(int steps) {
		this.totalSteps = steps;
	}
	
	public void run() {
		while(hareSteps < totalSteps) {
			isHareSleep = Math.random() > 0.5; 
			if(isHareSleep){
				System.out.println("兔子睡着了zzzz");
			}else{
				hareSteps += 2;
				System.out.println("兔子跑了"+ hareSteps +"步...");
			}
		}
		if(hareSteps == totalSteps) {
			System.out.println("兔子结束了比赛");
			System.exit(0);
		}
	}
}

public class TortoiseHareRace {
	public static void main(String[] args) {
		Tortoise tortoise = new Tortoise(100);
		Hare hare = new Hare(100);
		System.out.println("龟兔赛跑开始了...");
		Thread tortoiseThread = new Thread(tortoise);
		Thread hareThread = new Thread(hare);
		tortoiseThread.start();
		hareThread.start();
	}
}
```

但是这个代码的问题就是感觉输出的结果不是很好，就是即使一方结束了比赛，另一方仍然在继续进行，这个地方当时没有想清楚该怎么解决，所以在下面贴上老师的代码并进行分析：

*老师的代码：*
```java
public class RaceGame {
	public static void main(String[] args) {
		RaceState rs = new RaceState(100);  // 多定义了一个RaceState类
		Tortoise tort = new Tortoise(rs);
		Hare hare = new Hare(rs);
		Thread tortThread = new Thread(tort);
		Thread hareThread = new Thread(hare);
		tortThread.start(); hareThread.start();
	}
}
class RaceState{  // 区别最大的部分，将totalStep与state状态封装到一个类中
	private int totalStep, state;
	public final int RACING = 0, HARE_WINNER = -1, TORT_WINNER = 1;
	public RaceState(int totalStep) {
		this.totalStep = totalStep;
	}
	public int getTotalStep(){return totalStep;}
	public int getState(){return state;}
	public void setState(int state){
		this.state = state;
	}
}

class Tortoise implements Runnable{
	private RaceState gs; private int step;  
	// 使用组合，在内部创建一个RaceState对象
	public Tortoise(RaceState gs) {this.gs = gs;}
	
	public void run() {
		while(gs.getState() == gs.RACING) { 
			step ++; System.out.println("The Tortoise have ran " + step + " steps.");
			if (step == gs.getTotalStep()) {
				gs.setState(gs.TORT_WINNER);
				System.out.println("***The Tortoise win the game!***");
				System.exit(0);
			}
		}
	}
}

class Hare implements Runnable{
	private RaceState gs; private int step;
	public Hare(RaceState gs) {this.gs = gs;}
	public void run() {
		while(gs.getState() == gs.RACING) {
			int a = (int)(Math.random()*10) % 2;
			if(a == 0) {
				System.out.println("The hare is sleeping in " + step + "step: zzz");
			} else{
				step += 2; System.out.println("The hare have ran " + step + " steps.");
			}
			if (step == gs.getTotalStep()) {
				gs.setState(gs.HARE_WINNER);
				System.out.println("***The HARE win the game!***");
				System.exit(0);
			}
		}
	}
}
```

## 对应输出结果说明
*我自己的：*
![[微信截图_20231202212527.png]]

*老师的：*
![[微信截图_20231202214854.png]]
# 算法原理概述
### 多线程的应用：
1. **并发执行**：通过使用多线程，我们可以模拟乌龟和兔子同时开始比赛。`Tortoise`和`Hare`类都实现了`Runnable`接口，这意味着它们都有一个`run()`方法，该方法定义了每个线程应执行的代码。
2. **资源共享**：虽然这两个线程共享同一个控制台输出，但由于每个线程都有自己的步骤计数器（`tortoiseSteps`和`hareSteps`），它们不需要任何特殊的同步机制。这意味着乌龟和兔子可以并发地打印它们的步骤，而不需要等待其他线程。
### 如何创建线程：
1. **实现Runnable接口**：要创建线程，你可以创建一个实现`Runnable`接口的类。这个接口只有一个方法，即`run()`，当线程启动时，这个方法会被调用。在这个例子中，`Tortoise`和`Hare`类都实现了`Runnable`接口。
2. **创建Thread对象**：在主函数`main`中，我们使用`new Thread(tortoise)`和`new Thread(hare)`来创建两个新的线程对象。这两个对象分别代表乌龟和兔子的线程。
3. **启动线程**：通过调用线程的`start()`方法，我们可以启动线程。这会导致线程的`run()`方法被调用，从而开始执行线程的代码。在这个例子中，我们调用了`tortoiseThread.start()`和`hareThread.start()`来启动乌龟和兔子的线程。
### 老师代码分析与好处：
老师的代码和我的最大的不同是多了一个`RaceState`类，对控制最后的输出起了很大的作用
```java
class RaceState{
	private int totalStep, state;
	public final int RACING = 0, HARE_WINNER = -1, TORT_WINNER = 1;
	public RaceState(int totalStep) {
		this.totalStep = totalStep;
	}
	public int getTotalStep(){return totalStep;}
	public int getState(){return state;}
	public void setState(int state){
		this.state = state;
	}
}
```
#### RaceState类分析
- `RaceState`类主要用于维护比赛的总体状态。这个类有两个主要的属性：`totalStep`（总步数）和`state`（当前状态）。其中`state`可以是三种状态之一：正在比赛（`RACING`）、乌龟赢了（`TORT_WINNER`）或兔子赢了（`HARE_WINNER`）。
- 该类提供了获取和设置这些属性的方法。特别是`setState`方法，它允许更改比赛的状态。当乌龟或兔子达到总步数时，他们会使用这个方法来更新比赛的状态，并宣告自己为赢家。
- 除此以外，在`Hare`类与`Tortoise`类中运用了组合，在类内部有一个`RaceState`的变量，这样能够更方便控制状态与输出
#### 设计模式分析
这段代码主要运用了**观察者模式**。虽然这里没有明确的观察者接口和实现，但是通过共享的状态（即RaceState实例），Tortoise和Hare类都可以观察并响应状态的变化。
- **被观察者（Subject）**：在这里，`RaceState`类起到了被观察者的角色。它维护了比赛的状态，并在状态改变时通知其他对象（虽然这里没有明确的通知机制，但通过状态的检查可以实现类似的效果）。
- **观察者（Observer）**：`Tortoise`和`Hare`类都是观察者。他们通过检查`RaceState`的状态来决定自己的行为。例如，当比赛状态变为`TORT_WINNER`或`HARE_WINNER`时，输掉比赛的一方会停止运行。
#### 状态同步
1. **状态中心化**: 在老师的代码中，比赛的状态（例如总步数、当前状态等）是在一个中心化的`RaceState`类中管理的。这保证了状态的一致性和同步性。而在我的代码中，乌龟和兔子各自管理自己的步数，这可能导致状态的不一致，而且缺少`gs.getState() == gs.RACING`这一个判断条件，不好控制进程。
2. **避免竞态条件**: 由于`RaceState`类集中管理了比赛状态，所以更容易避免竞态条件（race condition）。在第二份代码中，两个线程分别更新`tortoiseSteps`和`hareSteps`，这可能导致竞态条件。
#### 可扩展性和可维护性
1. **单一职责原则**: `RaceState`类专注于管理比赛状态，这更符合单一职责原则（Single Responsibility Principle）。在我的代码中，状态管理和线程逻辑混合在一起，这可能使代码更难维护。
2. **易于扩展**: 如果有更多与比赛状态相关的属性或逻辑需要添加，老师的代码的结构更容易扩展。
3. **封装**: `RaceState`类封装了比赛状态的内部表示，这提供了更好的数据隐藏和安全性。
#### 代码清晰度和可读性
1. **意图明确**: 通过命名和组织，`RaceState`类更清晰地表达了其意图，即管理比赛的状态。
2. **减少冗余**: 在我的代码中，乌龟和兔子有相似的逻辑（例如检查是否达到了总步数）。这种逻辑在老师的代码中只需要在一个地方实现。
### 其他实验补充
1. 为了使多线程表现得更加明显，最好增大`totalSteps`的大小，如果设置为10会因为执行过快难以观察

# 实验结果与验证
## 结果验证
与老师代码结果进行比较，结果一致
## 代码改进(针对原本代码)
1. **线程安全性**：虽然这个特定示例中没有出现数据竞争或其他线程安全性问题，但如果有其他代码访问或修改`tortoiseSteps`和`hareSteps`，就可能需要添加同步机制。
2. **代码复用**：`Tortoise`和`Hare`类中有一些相似的代码，例如用于打印步骤的代码。这部分代码可以通过提取到一个共享的方法或类中来减少重复。
3. **可扩展性**：目前，乌龟和兔子的行为是硬编码的。如果想添加更多的动物或更改它们的行为，代码就会变得难以维护。可以考虑**使用策略模式**或其他设计模式来使代码更易于扩展。
4. **结束条件**：目前，乌龟和兔子只是简单地跑到一个固定的步数就结束比赛。在现实世界中，龟兔赛跑的结束条件可能更复杂，例如其中一个动物到达终点线，可以尝试以下改进：
	-  引入一个共享的`finishLine`变量，表示比赛的终点线。
	-  修改`Tortoise`和`Hare`的`run()`方法，使它们在达到终点线时停止。
	- 添加一个检查，以确保只有一个动物能赢得比赛。
5. **错误处理**：虽然这个简单的示例中没有错误处理，但在更复杂的程序中，处理可能出现的错误和异常是很重要的。