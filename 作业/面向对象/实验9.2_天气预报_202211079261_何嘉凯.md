# 测试步骤
## 相关代码
```java
interface WeatherState{
	void showState();
}

class Weather{
	private WeatherState state;
	public Weather(WeatherState state) {
		this.state = state;
	}
	
	public void show() {
		state.showState();
	}
}

class SunnyDay implements WeatherState{
	public void showState(){
		System.out.println("Tomorrow will be a sunny day");
	}
}

class CloudyDay implements WeatherState{
	public void showState(){
		System.out.println("Tomorrow will be a cloudy day");
	}
}

class RainyDay implements WeatherState{
	public void showState(){
		System.out.println("Tomorrow will be a rainy day");
	}
}

class FoggyDay implements WeatherState{
	public void showState(){
		System.out.println("Tomorrow will be a foggy day");
	}
}

public class TestWeather {
	public static void main(String[] args) {
		Weather weather1 = new Weather(new SunnyDay());
		weather1.show();  // 展示天气
		
		Weather weather2 = new Weather(new RainyDay());
		weather2.show();
		
		Weather weather3 = new Weather(new FoggyDay());
		weather3.show();
		
		Weather weather4 = new Weather(new CloudyDay());
		weather4.show();
	}
}
```
## 对应结果输出说明
![[微信截图_20231112201105.png]]

# 算法原理概述
### 对应的UML图
![[微信图片_20231112200841.png]]

### 原理阐述
1. **weatherState 接口**：
	* 这是一个接口，它声明了一个 `showState()` 方法。这个接口充当了一个规范或契约，任何实现它的类都必须提供 `showState()` 方法的具体实现。
2. **Weather 类**：
	* 这个类有一个 `weatherState` 类型的字段 `state` 来存储天气状态。
	* 它有一个*构造方法*，该方法接受一个 `weatherState` 对象，并将其存储在 `state` 字段中。
	* 它还提供了一个 `show()` 方法，这个方法用来调用存储的 `weatherState` 对象的 `showState()` 方法。
3. **SunnyDay 类**：
	* 这个类实现了 `weatherState` 接口，它代表了晴天状态。
	* 它提供了 `showState()` 方法的具体实现，该方法打印出“明天将是晴天”。
4. **CloudyDay 类**：
	* 这个类也实现了 `weatherState` 接口，它代表了多云状态。
	* 其 `showState()` 方法的具体实现会打印出“明天将是多云”。
5. **RainyDay 类**：
	* 同样，这个类实现了 `weatherState` 接口，代表下雨状态。
	* 其 `showState()` 方法的具体实现会打印出“明天将是雨天”。
6. **FoggyDay 类**：
	* 这个类实现了 `weatherState` 接口，代表雾天状态。
	* 其 `showState()` 方法的具体实现会打印出“明天将是雾天”。
7. **TestWeather 类**：
	* 这是一个测试类，包含 `main` 方法来执行测试。
	* 在 `main` 方法中，它创建了四个不同的 `Weather` 对象，分别对应四种不同的天气状态（晴天、雨天、雾天和多云），并通过调用它们的 `show()` 方法来显示这些状态。

综上所述，这些类通过接口实现了一种策略模式，使得天气状态（策略）可以动态更改，而客户端代码（在这里是 `Weather` 类和 `TestWeather` 类）不需要做任何改变。

# 实验结果与验证
## 结果验证
经检验得，对于每一种需求，均能给出正确的反馈，代码无误

## 代码改进
**1. 使用静态内部类减少文件数量**
如果这些天气状态类不会被其他地方引用，可以考虑将它们定义为`TestWeather`类的静态内部类，这样可以减少文件数量，并使代码更集中。
例如：
```java
public class TestWeather {

    static class SunnyDay implements WeatherState {
        public void showState() {
            System.out.println("Tomorrow will be a sunny day");
        }
    }

    // ... 其他天气状态类

    public static void main(String[] args) {
        // ...
    }
}
```
**2. 增加一些扩展性**
可以考虑使用`Map`来存储和查找这些天气状态，以便于进行天气状态的添加，这样可以避免在代码中硬编码它们。
**3.不用构造器的方法**
可以在`Weather`中对代码进行一些调整，具体看使用习惯
```java
class Weather{
	private WeatherState state;
	public void show() {state.showState();}
	public void setState(WeatherState state) {
		this.state = state;
	}
}
```
直接使用`setState`可以不需要重复定义多个变量，减少代码长度