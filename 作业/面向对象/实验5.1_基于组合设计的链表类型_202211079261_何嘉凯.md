# 测试步骤
## 相关代码
```java
public class testList {  // 测试代码
	public static void main(String[] args) {
		MyList list = new MyList();
		Node node1 = new Node(10);
		Node node2 = new Node(4);
		Node node3 = new Node(20);
		Node node4 = new Node(15);
		Node node5 = new Node(22);
		
		list.add(node1);
		list.add(node2);
		list.add(node3);
		list.add(node4);
		list.add(node5);
		list.display();
		
		list.remove(2); // 删除第三个结点
		list.display();
		list.remove(0);
		list.display(); // 删除第一个结点
	}
}

class MyList{
	private Node firstNode;  // 设置私有变量
	private int length;
	
	public MyList() {  // 构造器
		firstNode = null;
		length = 0;
	}
	
	public void clear() {  // 清空链表
		firstNode = null;
		length = 0;
	}
	
	public void add(Node d) {  // 添加结点
		if(firstNode == null){ //如果链表为空，直接将新结点作为头结点
			firstNode = d;
		}else{ //否则，遍历链表，找到最后一个结点，将新结点链接到它后面
			Node current = firstNode;
			while(current.next != null){
				current = current.next;
			}
			current.next = d;
		}
		length++; //链表长度加一
	}
	
	public void remove(int i) {  // 删除结点
		if(i < 0 || i >= length){ //如果位置不合法，抛出异常
			throw new IndexOutOfBoundsException("Invalid index: " + i);
		}else if(i == 0){ //如果位置为0，直接将头结点指向下一个结点
			firstNode = firstNode.next;
		}else{ //否则，遍历链表，找到要删除的结点的前一个结点，将它的next指向要删除的结点的next
			Node previous = firstNode;
		for(int j = 0; j < i - 1; j++){
			previous = previous.next;
		}
		Node current = previous.next;
		previous.next = current.next;
		}
		length--; //链表长度减一
	}
	
	public Node getAt(int i) {  // 得到某个位置的值
		if(i < 0 || i >= length){ //如果位置不合法，抛出异常
			throw new IndexOutOfBoundsException("Invalid index: " + i);
		}else{ //否则，遍历链表，找到要返回的结点，并返回它
			Node current = firstNode;
		for(int j = 0; j < i; j++){
			current = current.next;
		}
		return current;
		}
	}
	
	public void display() {  // 输出链表
		Node current = firstNode;
		while(current != null){
			System.out.print(current.data + " ");
			current = current.next;
		}
		System.out.println();
	}
}

class Node{
	//值
	protected int data;
	// Node 节点类型,引用当前结点的下一个结点
	protected Node next;
	protected Node(int d){
		this.data = d;
		next = null;
	}
	protected Node(int d, Node n){
		this.data = d;
		next = n;
	}
}
```
## 对应输出结果说明
![[微信截图_20231007101956.png]]

# 算法原理概述
## 链表
链表是一种常用的数据结构，它通过指针将一组零散的内存块（称为链表的“结点”）串联在一起。每个链表结点除了存储数据之外，还需要记录链上的下一个结点的地址。这样，通过指针，可以从一个结点访问到链表中的下一个结点。
![[2d1dcb64e8d044128e5868bd99dd8528.png]]

链表的主要优点是可以高效地进行插入和删除操作，因为只需要修改指针即可，不需要移动大量的数据。然而，链表的访问速度相对较慢，因为需要从头结点开始逐个访问结点，直到找到所需的结点。

链表有很多种类型，包括单向链表、双向链表和循环链表等。单向链表只能从一个方向遍历，双向链表可以从两个方向遍历，而循环链表则是首尾相连的。不同类型的链表在算法实现上也有所不同。
![[42384092038e482289bd8d2ef7eb1116.png]]

在实现链表时，需要注意指针的使用和管理，避免出现野指针和内存泄漏等问题。同时，需要根据具体应用场景选择合适的链表类型，以达到最优的效果。

## 关于Java中链表实现
Node是一个类，它是一种引用类型（reference type）。引用类型的变量不是直接存储对象的值，而是存储对象在内存中的地址（reference）。当我们创建一个Node对象时，Java虚拟机会在堆（heap）中为该对象分配一块内存空间，并返回该空间的地址给变量。例如，当我们执行以下语句时：

```java
Node node1 = new Node(10);
```

Java虚拟机会在堆中创建一个Node对象，并将它的data属性赋值为10，next属性赋值为null。然后，Java虚拟机会将该对象在堆中的地址（假设为0x1234）赋值给变量node1。这样，node1就指向了堆中的Node对象

当我们执行以下语句时：
```java
node1 = null;
```

Java虚拟机会将变量node1的值设为null，表示它不再指向任何对象。这样，原来的Node对象就不再被任何变量引用

注意，这里我们并没有改变Node对象本身的属性，而只是改变了变量node1的值。Node对象在堆中仍然存在，只是没有任何变量指向它了。这样就满足了垃圾回收机制中可回收对象（garbage）的定义：没有任何引用指向该对象或者所有指向该对象的引用都失效了。因此，在合适的时机（通常是内存不足时），Java虚拟机会自动回收这些可回收对象所占用的内存空间，从而释放内存资源。

# 实验结果与验证
## 结果验证
详见输出结果，经检验得，符合实际情况，代码正确

## 讨论
1. 存在的问题及改进：
Node的属性，应该设置为protected，防止在包外被访问，但不能设置成private，否则会导致测试时无法访问

