这次作业不是很会写，一个是没有想好怎么通过状态变量来控制线程，另一个是没想好怎么样控制猜数字的范围，所以主要参考了老师的代码一进行修改，另附上老师的的代码二用于复习和借鉴：
# 测试步骤
## 相关代码
我的代码（主要参考老师的代码一（因为真的不会写...））：
```java
package lesson12;
import java.util.Random;  
public class GuessNumberGame {  
    public static void main(String[] args) {  
        Number number = new Number();  
        number.maker.start();  // 启动number的maker线程
        number.guess.start();  // 启动number的guess线程
    }  
}  
  
class Number implements Runnable{
	int message, makeNumber, guessNumber, min = 0, max = 100;  // 设置message用于通信
	boolean readyToGuess, readyToMake = true;
	volatile boolean isSuccess = false;  // 设置volatile用于可见性
	Thread maker, guess;
	
	public Number() {
		maker = new Thread(this);
		guess = new Thread(this);
	}
	
	public void run() {
		int count = 0;  // 记录猜的次数
		while(isSuccess == false) {
			count ++; 
			//if(count <= 5) repeatGame(count);
			//else {
				//System.out.println("超过次数限制");
				//maker.stop();
				//guess.stop();
			repeatGame(count);
			}
		}
	
	
	public synchronized void repeatGame(int count) {
		if(Thread.currentThread() == maker && readyToMake == true) {
			Random random = new Random();  
			makeNumber = random.nextInt(100) + 1;  
			System.out.println("请猜一个范围在 1 - 100 范围内的数");
			readyToMake = false; readyToGuess = true;  // 两个变量转换控制进程运行
		}
		if(Thread.currentThread() == maker) {
			while(readyToGuess) {
				try {
					wait();  // 如果当前为readyToGuess轮次，那么maker线程休眠
				}catch(InterruptedException e) {}
			}
			if(guessNumber < makeNumber) {
				message = -1; // 如果为-1说明小了 
				System.out.println("数小了");
			} else if(guessNumber > makeNumber) {
				message = 1;  // 如果为1说明大了
				System.out.println("数大了");
			} else {
				message = 0; // 如果为0说明正确
				System.out.println("答案正确");  // 为0 说明相等
				isSuccess = true;
			}
			readyToGuess = true;
		}
		if(Thread.currentThread() == guess && readyToMake == false) {
			while(readyToGuess == false) {
				try{
					wait();
				}catch(InterruptedException e) {}
			}
			
			if(message == -1) {  // 如果小了，就调整下界
				min = guessNumber; 
				guessNumber = (min+max)/2;
				System.out.println("第 " + count + " 步猜的数是：  " + guessNumber);
			} else if(message == 1) {
				max = guessNumber; 
				guessNumber = (min+max)/2;
				System.out.println("第 " + count + " 步猜的数是：  " + guessNumber);
			}
			readyToGuess = false;
		}
		notifyAll();  // 唤醒所有线程
	}
}
```
## 对应结果输出
![[Attachment/作业/Java/12/微信图片_20231211003708.png|400]]


老师的代码二：
```java
public class NumberGame {
	public static void main(String[] args) {
		GameState numberState = new GameState();
		NumberMaker maker = new NumberMaker(numberState);
		NumberGuesser guesser = new NumberGuesser(numberState);
		maker.start(); guesser.start();
	}
}
class GameState{
	private boolean isGuessed = false, isMade = false, isChecked = false;
	private volatile boolean isSuccess = false;
	private final int LESS = -1, GREATER = 1, EQUAL = 0, BEGIN = 5;
	private int truth, answer, compared = BEGIN;
	private boolean public void setGuessSuccess(boolean success) {isSuccess = success;}
	public boolean getGuessSuccess() {return isSuccess;}
	public void setGuessed(boolean guess) {isGuessed = guess;}
	public boolean getGuessed() {return isGuessed;}
	public void setcompared(int c) {compared = c;}
	public int getCompared() {return compared;}
	public void setMade(boolean made) {isMade= made;}
	public boolean getMade() {return isMade;}
	public void setChecked(boolean checked) {isChecked= checked;}
	public boolean getChecked() {return isChecked;}
	public void setTruth(int truth){this.truth = truth;}
	public int getTruth() {return truth;}
	public void setAnswer(int answer) {this.answer = answer;}
	public int getAnswer() {return answer;}
}
class NumberMaker extends Thread{
	private final int LESS = -1, GREATER = 1, EQUAL = 0;
	private int truth, answer;
	private GameState state;
	public NumberMaker(GameState state) {this.state = state;}
	public void run() {
	synchronized(state) {
		while (!state.getGuessSuccess()) {
			if(!state.getMade()) {
			truth = (int)(Math.random()*99) + 1; state.setTruth(truth);
			System.out.println("Please guess a number between 1 and 100:" + truth);
			state.setMade(true); state.setChecked(false); state.setGuessed(false);
			}
			while(state.getChecked() || !state.getGuessed()) {
				try {state.wait();}catch(InterruptedException e) {}}
				checkAnswer();
			}
		}
	}
	public void checkAnswer() {
	answer = state.getAnswer(); truth = state.getTruth();
	if(answer < truth) {
		System.out.println("Your number is too small"); state.setcompared(LESS); state.setGuessed(false);
	} else if(answer > truth) {
		System.out.println("Your number is too great"); state.setcompared(GREATER); state.setGuessed(false);
	} else {
		System.out.println("You are right!:" + truth + ":"); state.setcompared(EQUAL); state.setGuessSuccess(true); state.setGuessed(true);
	}
		state.setChecked(true); state.notifyAll();
	}
}
```

# 算法原理阐述

1. **类定义与变量声明**:
	* `Number`类实现了`Runnable`接口，这样它就可以被线程执行。
	* 它有多个变量，包括用于表示猜测结果的`LESS`, `GREATER`和`SUCCESS`（后被我直接设为-1, +1 和0），表示随机数的`makeNumber`，表示用户猜测的`guessNumber`，以及控制线程交互的`readyToGuess`和`readyToMake`标志。
	* 除此以外，还有个我当时没想清楚的`message`变量，两个线程通过这个变量进行通信，从而控制线程的执行；`isSuccess`则接收数字比较结果，从而控制`run`函数是否继续执行

2. **线程的创建与启动**:
在`main`方法中，创建了两个线程`maker`和`guess`，并分别启动。

3. **run方法**:
这是线程的主要执行方法。当线程启动时，它们将执行这个方法。这个方法会一直循环执行，直到用户猜测正确为止。

4. **repeatGame方法**:
这是一个*同步方法*，意味着在同一时刻只有一个线程可以执行此方法。它根据当前线程是`maker`还是`guess`来决定执行不同的逻辑。
	* 如果当前线程是`maker`，它会生成一个新的随机数，并提示用户进行猜测。然后它等待，直到`guess`线程完成猜测。之后，它会检查用户的猜测并输出相应的消息。如果用户猜对了，它会设置`isSuccess`标志为`true`，结束循环。
	* 如果当前线程是`guess`，它会等待，直到`maker`线程提示用户进行猜测。然后它会根据提示来更新猜测的数字。如果用户的猜测数字小于目标数字，它会更新最小值并输出提示消息；如果用户的猜测数字大于目标数字，它会更新最大值并输出提示消息；如果用户的猜测数字正好是目标数字，它会设置`isSuccess`标志为`true`，结束循环。

5. **volatile关键字**:
在Java中，`volatile`关键字用于确保多线程之间的可见性。具体来说，当一个共享变量被`volatile`修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去主内存中读取新值。在这个程序中，`isSuccess`变量被声明为`volatile`，以确保所有线程都能正确地看到它的值。
在老师的代码中，通过将`isSuccess`这一变量设置为`volatile`属性，从而使得两个线程均能正确读取与改写

6. **synchronized关键字**:
在Java中，`synchronized`关键字用于实现同步。它可以应用于方法或代码块，以防止多个线程同时访问特定资源。在这个程序中，`repeatGame`方法是同步的，这意味着在同一时刻只有一个线程可以执行此方法。这样做是为了确保在修改和读取共享变量时不会发生数据不一致的问题。

7. **wait和notifyAll方法**:
这些方法用于线程之间的协作。当一个线程调用对象的`wait`方法时，它会让出对象的锁，进入等待状态，直到其他线程调用同一个对象的`notify`或`notifyAll`方法唤醒它。在这个程序中，当`maker`线程生成新的随机数后，它会调用`wait`方法让出锁，等待`guess`线程完成猜测；而当`guess`线程完成猜测后，它会调用`notifyAll`方法唤醒所有在此对象上等待的线程（在此程序中就是指`maker`线程）。

### 实验补充
猜数字高效的办法：采用二分，对数字进行二分取中间处理，通过两个成员变量`max`和`min`进行范围缩小

# 实验结果与验证
## 结果验证
实验结果与老师一致
## 改进
1. 是否可以设置成**超过一定轮数就停止**？
	注释部分曾经试着这么做，但是`stop`方法已被淘汰存在一定风险
![[Attachment/作业/Java/12/微信图片_20231211003708.png]]

2. **线程管理**：可以使用线程池来管理线程，以便更有效地利用系统资源。同时，可以添加异常处理机制，以防止线程意外终止或出现其他异常情况。
3. **用户交互**：可以添加更多的用户交互功能，比如提示用户输入猜测数字、输出游戏进度等。
