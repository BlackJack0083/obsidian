# 测试步骤
## 相关代码
```java
public class Machine {
	public static void main(String[] args) {
		Machine machine = new Machine();
		
		Goods g1 = new Goods("apple", false);
		Goods g2 = new Goods("explosive", true);
		Goods g3 = new Goods("clothes", false);
		Goods g4 = new Goods("watch", false);
		Goods g5 = new Goods("sulfuric acid", true);
		Goods goods[] = {g1, g2, g3, g4, g5};
		
		for(Goods good : goods) {
			try {
				machine.checkBag(good);
			}catch(DangerException e) {
				System.out.println("The" + good.getName() + " is dangerous");
				// System.out.println(g.getName()+":"+e.getMessage());
			}
		}
	}

public void checkBag(Goods goods) throws DangerException{
	if(goods.isDanger() == true) throw new DangerException();
	else System.out.println("The " + goods.getName() + " is safe");
	}
}

class Goods{
	private String name;
	private boolean dangerous;
	public Goods(String name, boolean danger) {
		this.name = name;
		this.dangerous = danger;
	}
	
	public String getName() {
		return name;
	}
	
	public boolean isDanger() {
		return this.dangerous;
	}
}
 
class DangerException extends Exception{
	public DangerException() {
		super("Dangerous");
	}
}
```
## 对应结果输出说明
![[微信截图_20231113163026.png]]

# 算法原理概述
### 原理阐述
1. **Goods 类**:
	* 这个类用来表示一种商品。
	* 它有两个私有属性：`name` 和 `dangerous`。其中，`name` 表示商品的名字，`dangerous` 是一个布尔值，表示这个商品是否危险。
	* `Goods` 类有一个构造函数和两个公共方法：`getName()` 和 `isDanger()`。这两个方法分别用来获取商品的名字和检查商品是否危险。
2. **DangerException 类**:
	* 这是一个自定义异常类，继承自 `Exception` 类。
	* 当一个商品是危险的时候，`DangerException` 会被抛出。
	* 这个类包含一个构造函数，调用父类的构造函数并传递一个字符串 "Dangerous" 作为异常信息。
3. **Machine 类**:
	* 这个类包含一个 `main` 方法和一个 `checkBag` 方法。
	* 在 `main` 方法中，创建了五个不同的 `Goods` 对象并存储在数组 `goods` 中。然后遍历这个数组，检查每个商品是否是危险的。
	* `checkBag` 方法接受一个 `Goods` 对象作为参数。如果这个商品是危险的，那么抛出 `DangerException` 异常；否则，输出这个商品是安全的。
	* 在 `main` 方法中，使用了一个 try-catch 块来捕获 `DangerException`。如果 `checkBag` 方法抛出异常，那么 catch 块会捕获它，并输出相应的商品是危险的。

**三者之间的关系**:
* `Goods` 类是一个基础类，它只负责定义商品的属性和行为。
* `DangerException` 是一个特定的异常类，用于处理与 `Goods` 相关的特定异常情境，即商品是危险的情况。
* `Machine` 类使用 `Goods` 对象，并在遇到危险商品时抛出和处理 `DangerException` 异常。

**异常处理**:
代码中已经包含了对 `DangerException` 的处理。当检查到危险的商品时，`checkBag` 方法会抛出 `DangerException`，然后在 `main` 方法中使用 try-catch 结构捕获该异常并打印出相应的警告消息。这样的异常处理机制确保了程序在遇到危险商品时能够正常执行，并给出用户相应的警告信息。

#### try-catch模块
1. **try块**：
    - `try`块中的代码是尝试执行的代码，这些代码可能会抛出一个或多个类型的异常。
    - 在这个例子中，`try`块包含了对`machine.checkBag(good)`的调用。这个调用可能会抛出一个`DangerException`，如果所检查的商品是危险的。
2. **catch块**：
    - `catch`块用于捕获并处理`try`块中抛出的异常。
    - 在这个例子中，`catch`块捕获`DangerException`类型的异常，并打印出一条消息，指出哪个商品是危险的。
    - `catch`块的参数`e`是捕获到的异常对象。在这个例子中，该对象并未用于获取任何额外的异常信息，因为异常消息已经在`DangerException`的构造函数中固定为"Dangerous"。

#### 构造类型数组方法
在Java中，构造数组主要有以下几种方法：
1. **声明与赋值同时进行：** 这是最常用的构建数组的方法，你可以在声明数组的同时为其赋值。例如：
```java
int[] arr = {1, 2, 3, 4, 5};
```
2. **先声明，后赋值：** 你也可以首先声明数组，然后在后续的代码中为其赋值。例如：
```java
int[] arr;
arr = new int[]{1, 2, 3, 4, 5};
```
3. **通过循环或其他方式赋值：** 你还可以通过循环或者其他方式为数组赋值。例如，通过循环为数组赋值：
```java
int[] arr = new int[5];
for (int i = 0; i < arr.length; i++) {
    arr[i] = i;
}
```
4. **数组字面量初始化：** 此种方法主要用于初始化值不会改变的数组，比如一些常量数组。
```java
final int[] ARR = {1,2,3,4,5};
```
对于不同类型的数组（如对象数组），构造方法类似，只是在声明数组类型时有所不同。例如，构造一个`Goods`对象数组：
```java
Goods[] goodsArray = new Goods[5];  // 声明并构造一个能存放5个Goods对象的数组

// 然后可以通过循环或者其他方式，为每个数组元素赋值
for (int i = 0; i < goodsArray.length; i++) {
    goodsArray[i] = new Goods("item" + i, false);
}
```
注意，当创建一个对象数组时，实际上只是创建了可以存储对象引用的数组，而不是创建了对象本身。你需要为每一个数组元素单独创建对象。

##### 含有多个属性的类型数组构造
这个地方是第一次遇到这样构造，所以记录一下：
```java
String names[] = {"apple", "explosive", "clothes", "sulfuric acid"};
boolean dangerous[] = {false, true, false, true};
Goods goods[] = new Goods[names.length];
```
利用两个符合类型要求且长度一致的数组来构造一个新的对象数组

其他方法：
1. **使用循环来创建和初始化数组元素**：你可以首先创建一个该类型的数组，然后使用循环来为每个数组元素调用构造函数并传入所需的属性。例如：
```java
public class MyClass {
    private int prop1;
    private String prop2;

    public MyClass(int prop1, String prop2) {
        this.prop1 = prop1;
        this.prop2 = prop2;
    }
}

// 在其他地方创建 MyClass 数组
MyClass[] myArray = new MyClass[5];

for (int i = 0; i < myArray.length; i++) {
    myArray[i] = new MyClass(i, "property_" + i); // 传入所需的属性
}
```
2. **使用Java 8 Stream API**：如果你使用的是Java 8或更高版本，你也可以使用Stream API来更简洁地创建和初始化数组：
```java
import java.util.stream.Collectors;
import java.util.stream.IntStream;

MyClass[] myArray = IntStream.range(0, 5)
        .mapToObj(i -> new MyClass(i, "property_" + i))
        .toArray(MyClass[]::new);
```
3. **使用数组初始化块**：你还可以使用数组初始化块来创建和初始化数组。这种方法比较简洁，但不太适用于需要动态计算属性值的场景。
```java
MyClass[] myArray = {
    new MyClass(0, "property_0"),
    new MyClass(1, "property_1"),
    // ...
};
```

# 实验结果与验证
## 结果验证
经检验得，对于每一种商品，均能给出正确的危险判断，代码无误

## 讨论改进
1. **异常处理**：
    - 在`DangerException`中，你可以添加一个构造函数，它接受一个字符串作为参数，这样你就可以传递更具体的错误信息。
    - 你也可以考虑在`DangerException`中添加一个`getDangerousGoodsName()`方法来获取危险物品的名称，这样在异常处理时，你就可以直接打印出危险物品的名称，而不是仅仅打印出“Dangerous”。