# 测试步骤
## 相关代码
```java
package lesson11;
import java.util.ArrayList;
import java.io.File;  
import java.io.FileNotFoundException;  
import java.util.*;  
import java.util.Map.Entry;  
import java.util.regex.Pattern;  
  
public class WordAnalyzer {  
    private String filePath;  
    private Map<String, Integer> wordCountMap;  
    private ArrayList<String> wordCountList;
  
    public WordAnalyzer(String filePath) {  
        this.filePath = filePath;  
        this.wordCountMap = new HashMap<>();  
        this.wordCountList = new ArrayList<>();
    }  
  
    public void analyze() throws FileNotFoundException {  
        Scanner sc = new Scanner(new File(filePath));  
  
        // 使用正则表达式来分割单词  
        String regularExpression = "[\\s\\d\\p{Punct}]+";  
        sc.useDelimiter(regularExpression);  
  
        // 从Scanner对象获取下一个单词并计数  
        while (sc.hasNext()) {  
            String word = sc.next().toLowerCase(); // 转换为小写以实现不区分大小写的统计  
            wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1);  
            wordCountList.add(word);
        }  
  
        sc.close();  
    }  
  
    public int getTotalWordCount() {  
        return wordCountList.size();  
    }  
  
    public int getTotalUniqueWordCount() {  
        return wordCountMap.keySet().size();  
    }  
  
    public void printWordsSortedByFrequency() {  
        // 创建一个列表来保存单词和它们的频率  
        List<Map.Entry<String, Integer>> sortedList = new ArrayList<>(wordCountMap.entrySet());  
          
        // 按照频率进行降序排序  
        sortedList.sort((entry1, entry2) -> entry2.getValue().compareTo(entry1.getValue()));  
          
        // 打印按照频率排序的单词  
        System.out.println("\nWords sorted by frequency:");  
        for (Map.Entry<String, Integer> entry : sortedList) {  
            System.out.println(entry.getKey() + ": " + entry.getValue());  
        }  
    }
  
    public static void main(String[] args) {  
        String filePath = "C:\\Java Codes\\lesson11\\EngishWord.txt"; // 请替换为您的文件路径  
        WordAnalyzer analyzer = new WordAnalyzer(filePath);  
        try {  
            analyzer.analyze();  
            System.out.println("Total words: " + analyzer.getTotalWordCount());  
            System.out.println("Total unique words: " + analyzer.getTotalUniqueWordCount());  
            analyzer.printWordsSortedByFrequency();  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

## 对应结果输出说明
*原文：*
![[微信截图_20231122214644.png]]
*对应输出结果：*
![[微信截图_20231122214559.png|500]]

# 算法原理概述
### 原理阐述
1. **类成员变量**:
	* `filePath`: 存放文件的路径。
	* `wordCountMap`: 一个字典，用于存放每个单词及其出现次数。
	* `wordCountList`: 一个列表，用于存放所有的单词。
2. **构造函数** (`public WordAnalyzer(String filePath)`):
	* 初始化`filePath`，`wordCountMap`和`wordCountList`。
3. **analyze方法** (`public void analyze() throws FileNotFoundException`):
	* 使用`Scanner`读取文件，文件路径由`filePath`指定。
	* 使用正则表达式`[\\s\\d\\p{Punct}]+`作为分隔符来分隔单词。这个正则表达式将空格、数字和标点符号都作为单词的分隔符。
	* 将每个单词转换为小写，这样在统计时不会区分大小写。
	* 使用`wordCountMap`统计每个单词出现的次数，并将单词存入`wordCountList`。
	* 最后，关闭Scanner。
4. **getTotalWordCount方法** (`public int getTotalWordCount()`):
	* 返回`wordCountList`的大小，即文件中单词的总数。
5. **getTotalUniqueWordCount方法** (`public int getTotalUniqueWordCount()`):
	* 返回`wordCountMap`中键的数量，即文件中唯一单词的总数。
6. **printWordsSortedByFrequency方法** (`public void printWordsSortedByFrequency()`):
	* 创建一个列表`sortedList`来保存`wordCountMap`中的每个条目。
	* 使用Java的Lambda表达式对`sortedList`进行排序，按照每个单词出现的次数从高到低排序。
	* 打印按频率排序的单词及其出现次数。

### 数据结构与相关操作：
1. **Map**: 使用`HashMap`来存储每个单词及其出现次数。这是通过`put`方法实现的，其中键是单词，值是出现次数。
	- HashMap是一种基于键值对的数据结构，它允许你存储、检索和删除键值对。 
	- 在这个程序中，HashMap用于存储每个单词及其出现次数。其中，键是单词，值是单词的出现次数。 
	- 使用HashMap的*优势*是，单词的查找、插入和删除操作通常具有$O(1)$的平均时间复杂度
```java
wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1); 
```
-  `wordCountMap.getOrDefault(word, 0)`：这个方法会尝试从 `wordCountMap` 中获取 `word` 对应的值（也就是它出现的次数）。如果 `word` 存在于 `wordCountMap` 中，那么就会返回它对应的值；如果 `word` 不存在，那么就会返回默认值 0。
-  `+ 1`：对于获取到的值（或者默认值 0），我们将其加 1，表示我们又找到了一个这个单词。
-  `wordCountMap.put(word, ...)`: 最后，我们将单词 `word` 和其新的计数（原计数 + 1）放回到 `wordCountMap` 中。

2. **ArrayList**: 使用`ArrayList`来存储所有的单词，方便后续操作。
	- 这里一开始想同样用`map`进行操作，但后面发现`map`无法输出所有值求和(比较繁琐)，所以采用了`List`，好处是不会去重，可以存储所有单词，满足实验要求
```java
wordCountList.add(word);
public int getTotalWordCount() {  
        return wordCountList.size();  
    }  
```
- 通过`add`和`list.size()`操作，可以较容易获得所有单词的数量

3. **List**: 在`printWordsSortedByFrequency`方法中，创建了一个`ArrayList`来复制和排序`wordCountMap`的条目。
4. **Lambda表达式**: 用于在`sortedList.sort`中对列表进行排序。这是一个简洁的方式，用于定义应根据什么标准对列表进行排序。
```java
List<Map.Entry<String, Integer>> sortedList = new ArrayList<>(wordCountMap.entrySet());  

sortedList.sort((entry1, entry2) ->entry2.getValue().compareTo(entry1.getValue()));
```
- 首先创建了一个新的 `ArrayList`，该列表是 `wordCountMap` 中所有条目的拷贝。其中，`wordCountMap` 是一个映射单词（字符串）到其出现次数（整数）的 `Map`，用`ArrayList`转换是为了利用其排序功能
- 其次使用了一个 lambda 表达式来对 `sortedList` 进行排序。它比较两个条目的值（也就是单词的频率）并逆序排序，这意味着频率最高的单词将位于列表的顶部。从而达到按照频率排序的目的

5. **正则表达式**: 用于定义单词的分隔符。这允许程序正确地分隔和计数单词。
6. **Scanner**: 用于读取文件内容，并与正则表达式结合使用，以识别和分隔单词。
```java
Scanner sc = new Scanner(new File(filePath));  
// 使用正则表达式来分割单词  
String regularExpression = "[\\s\\d\\p{Punct}]+";  
sc.useDelimiter(regularExpression);  
sc.close();
```
1. **`new File(filePath)`**：
    - 这部分代码使用了`File`类的构造函数来创建一个`File`对象，它代表一个文件路径。这里的`filePath`是一个变量，它应该包含要读取的文件的路径。
2. **`new Scanner(...)`**：
    - 这部分代码创建了一个新的`Scanner`对象。`Scanner`是Java的一个实用类，它可以用于读取和解析文本。
    - 当你将一个`File`对象作为参数传递给`Scanner`的构造函数时，这个`Scanner`对象将被设置为从该文件中读取数据。
3. `sc.useDelimeter(regularExpression)`:
	- 结合正则表达式，则可以做到按照正则表达式的要求对读入的字符进行分隔
4. `sc.close()`:
	关闭`Scanner`对象，以确保释放与文件相关联的资源

# 实验结果与验证
## 结果验证
经检验得，对于任意英文文本，程序均能给出正确的字符统计，代码无误

## 讨论改进
1. **直接在原本的`map`进行排序**
要在原`wordCountMap`上进行排序，可以使用`TreeMap`来创建一个新的排序后的`Map`。`TreeMap`默认会按照键的自然顺序进行排序，但通过传递一个自定义比较器来按照值进行排序。
```java
public void printWordsSortedByFrequency() {
    // 创建一个TreeMap来存储排序后的单词和它们的频率
    Map<String, Integer> sortedMap = new TreeMap<>(Collections.reverseOrder(Map.Entry.<String, Integer>comparingByValue()));
    sortedMap.putAll(wordCountMap);

    // 打印按照频率排序的单词
    System.out.println("\nWords sorted by frequency:");
    for (Map.Entry<String, Integer> entry : sortedMap.entrySet()) {
        System.out.println(entry.getKey() + ": " + entry.getValue());
    }
}
```
在这个改进中，使用了`Collections.reverseOrder()`和`Map.Entry.comparingByValue()`来创建一个比较器，它按照值的降序对`Map`进行排序。然后，使用`putAll()`方法将原`wordCountMap`的内容放入新的`sortedMap`中，从而得到了一个按照频率排序的`Map`。最后，遍历`sortedMap`并打印出排序后的单词和它们的频率。

这样就可以在原`wordCountMap`上进行排序，而无需创建一个新的列表来存储排序后的结果。