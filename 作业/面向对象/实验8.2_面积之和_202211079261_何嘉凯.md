# 测试步骤
## 相关代码
### 原始代码（未优化）
```java
package lesson8;

//// 定义Shape抽象类 ////
abstract class Shape{
	protected int x, y;
	public abstract double getArea();
}

//// 定义矩形类 ////
class Rectangular extends Shape{
	private int l, w;
	public Rectangular(int x, int y, int l, int w) {
		this.x = x;
		this.y = y;
		this.l = l;
		this.w = w;
	}

//// 方法重写
	public double getArea() {
		System.out.println("The rectangular center is located in (" + x + " , " + y + ")");
		return l * w;
	}
}

//// 定义圆类 ////
	class Circle extends Shape{
	private int r;
	public Circle(int x, int y, int r) {
		this.x = x;
		this.y = y;
		this.r = r;
}

//// 方法重写
	public double getArea(){
		System.out.println("The circle center is located in (" + x + " , " + y + ")");
		return 3.14 * r * r;
	}
}

///// 定义TotalArea类 /////
public class TotalArea {
	private double totalArea = 0;
	private Shape geometry[];
	// 通过构造器给geometry赋值
	public TotalArea(Shape[] s) {
		this.geometry = s;
	}
	
	public double getTotalArea() {
		for(Shape shape: geometry) {
			totalArea += shape.getArea();  // 动态绑定
			System.out.println("Now the total area is " + totalArea );
		}
		return totalArea;
	}
	
	///// 进行测试 /////
	public static void main(String[] args) {
		Shape s[] = new Shape[10];
		for(int i = 0; i < s.length; i++) {
			if((i & 1) == 1)  // 判断奇偶
			s[i] = new Circle(1 + i, 1 + i, 2 * i); // 位置为(1 + i，1 + i)，半径为2i
			else s[i] = new Rectangular(-1 - i, 1 + i, 1 + i, 2 * (1 + i)); // 位置为(-1 - i，1 + i)，长为i，宽为2i
		}
		TotalArea totalArea = new TotalArea(s);
		System.out.println("TotalArea is: " + totalArea.getTotalArea()); // 测试动态绑定
	}
}
```

### 优化一：Shape类更名为ABTShape
```java
package lesson8;

//// 定义Shape抽象类 ////
abstract class ABTShape{
	protected int x, y;
	public int getX() { return x; }  
    public int getY() { return y; }  
    public void setX(int x) { this.x = x; }   
    public void setY(int y) { this.y = y; }  
	public abstract double getArea();
}

//// 定义矩形类 ////
class Rectangular extends ABTShape{
	private int l, w;
	public Rectangular(int x, int y, int l, int w) {
		this.x = x;
		this.y = y;
		this.l = l;
		this.w = w;
	}

//// 方法重写
	public double getArea() {
		System.out.println("The rectangular center is located in (" + x + " , " + y + ")");
		return l * w;
	}
}

//// 定义圆类 ////
class Circle extends ABTShape{
	private int r;
	public Circle(int x, int y, int r) {
		this.x = x;
		this.y = y;
		this.r = r;
}

//// 方法重写
	public double getArea(){
		System.out.println("The circle center is located in (" + x + " , " + y + ")");
		return 3.14 * r * r;
	}
}

///// 定义TotalArea类 /////
public class TotalArea {
	private double totalArea = 0;
	private ABTShape geometry[];
	// 通过构造器给geometry赋值
	public TotalArea(ABTShape[] s) {
		this.geometry = s;
	}
	
	public double getTotalArea() {
		for(ABTShape shape: geometry) {
			totalArea += shape.getArea();  // 动态绑定
			System.out.println("Now the total area is " + totalArea );
		}
		return totalArea;
	}
	
	///// 进行测试 /////
	public static void main(String[] args) {
		ABTShape s[] = new ABTShape[10];
		for(int i = 0; i < s.length; i++) {
			if((i & 1) == 1)  // 判断奇偶
			s[i] = new Circle(1 + i, 1 + i, 2 * i); // 位置为(1 + i，1 + i)，半径为2i
			else s[i] = new Rectangular(-1 - i, 1 + i, 1 + i, 2 * (1 + i)); // 位置为(-1 - i，1 + i)，长为i，宽为2i
		}
		TotalArea totalArea = new TotalArea(s);
		System.out.println("TotalArea is: " + totalArea.getTotalArea()); // 测试动态绑定
	}
}
```

### 优化二：将Shape类优化为一个接口IFCShape
```java
package lesson8;

//定义 IFCShape 接口
interface IFCShape {
	int getX(); // 添加 getter
	int getY(); // 添加 getter
	void setX(int x); // 添加 setter
	void setY(int y); // 添加 setter
	double getArea();
}

class Rectangle implements IFCShape {
	private int x, y;
	private int l, w;
	public Rectangle(int x, int y, int l, int w) {
		this.x = x;
		this.y = y;
		this.l = l;
		this.w = w;
	}
	
	// 实现接口方法
	public double getArea() {
		return l * w;
	}
	
	// 实现接口的 getter 和 setter 方法
	public int getX() { return x; }
	public int getY() { return y; }
	public void setX(int x) { this.x = x; }
	public void setY(int y) { this.y = y; }
}

class Circle implements IFCShape {
	private int x, y;
	private int r;
	public Circle(int x, int y, int r) {
		this.x = x;
		this.y = y;
		this.r = r;
	}
	
	// 实现接口方法
	public double getArea(){
		return 3.14 * r * r;
	}
	
	// 实现接口的 getter 和 setter 方法
	public int getX() { return x; }
	public int getY() { return y; }
	public void setX(int x) { this.x = x; }
	public void setY(int y) { this.y = y; }
}

///// 定义TotalArea类 /////
public class TotalArea {
	private double totalArea = 0;
	private IFCShape geometry[];
	// 通过构造器给geometry赋值
	public TotalArea(IFCShape[] s) {
		this.geometry = s;
	}

	public double getTotalArea() {
		for(IFCShape shape: geometry) {
			totalArea += shape.getArea(); // 动态绑定
			System.out.println("Now the total area is " + totalArea );
		}
		return totalArea;
	}

///// 进行测试 /////
	public static void main(String[] args) {
		IFCShape s[] = new IFCShape[10];
		for(int i = 0; i < s.length; i++) {
			if((i & 1) == 1) // 判断奇偶
			s[i] = new Circle(1 + i, 1 + i, 2 * i); // 位置为(1 + i，1 + i)，半径为2i
			else s[i] = new Rectangle(-1 - i, 1 + i, 1 + i, 2 * (1 + i)); // 位置为(-1 - i，1 + i)，长为i，宽为2i
		}
		TotalArea totalArea = new TotalArea(s);
		System.out.println("TotalArea is: " + totalArea.getTotalArea()); // 测试动态绑定
	}
}
```

## 对应输出结果说明
### 优化一：
![[微信图片_20231105155424.png]]
第一行显示生成了什么图形，中心在什么位置；
第二行显示增加该图形后总面积的变化
### 优化二：
![[微信图片_20231105155439.png]]
同理

# 算法原理概述
### 对应的UML图
#### 优化一：
![[微信截图_20231105161730.png]]

#### 优化二：
![[微信截图_20231105161629.png]]

### 原理阐述
#### 优化一
1. **抽象类ABTShape**：这是一个抽象类，它定义了一个形状的通用属性和行为。它有一个`getArea()`的抽象方法，该方法需要在子类中实现。`getX()` 和 `getY()` 方法返回形状的位置，`setX()` 和 `setY()` 设置形状的位置，较原代码能更好地对元素的属性进行设置，且满足封装性。
2. **多态**：多态在这段代码中体现在`getArea()`方法上。不同的形状（矩形和圆形）都有自己的`getArea()`方法实现。当通过抽象类引用调用`getArea()`时，实际执行的是具体子类的实现，实现*方法重写*，这是多态的体现。
3. **矩形类和圆形类**：这两个类都是`ABTShape`的子类，他们实现了`getArea()`方法，以计算各自的面积。同时，他们都有自己的构造器，用来初始化对象的位置和形状相关的属性。
4. **类型转换**：在这段代码中，类型转换体现在`ABTShape`数组`s`的初始化上。数组`s`的类型是`ABTShape[]`，但是它可以存储`Rectangular`和`Circle`类型的对象，这是因为`Rectangular`和`Circle`是`ABTShape`的子类，这是向上转型（upcasting）。
5. **TotalArea类**：这个类有一个`ABTShape[]`类型的成员变量`geometry`和一个计算总面积的方法`getTotalArea()`。在`getTotalArea()`方法中，通过遍历`geometry`数组，并调用每个元素的`getArea()`方法来计算总面积。因为`geometry`中的元素可能是不同的子类对象，所以这里也体现了多态性。

#### 优化二：
1. **代码复用性增强**：通过定义一个接口`IFCShape`，并让`Rectangle`和`Circle`类实现这个接口，增强了代码的复用性。这种方式可以让其他的类也实现这个接口，以达到重用的效果。
2. **可维护性增强**：在接口中定义了`getX()`, `getY()`, `setX()`, `setY()`方法，这样一来，如果有其他类实现了这个接口，就必须实现这些方法。这保证了所有实现这个接口的类都有统一的方法可以获取和设置x，y坐标。增加了代码的可维护性。
3. **封装性更好**：在`Rectangle`和`Circle`类中，通过接口强制实现了`getter`和`setter`方法，确保了所有实现类都有一致的访问和修改x，y坐标的方式。这种改进使得代码更具一致性和统一性
4. **动态绑定**：在`TotalArea`类中，通过for-each循环遍历`IFCShape`数组，并动态调用每个形状的`getArea()`方法，实现了动态绑定。这样使得代码更加灵活，可以应对更多的形状类型。
5. **变量：** 由于接口中均为常量，所以不能在接口中定义`x, y`

#### 接口类型数组
在优化二中，定义了一个`IFCShape`类型的数组
```java
IFCShape s[] = new IFCShape[10];
```

这部分课上并没有详细说明，实际上，接口在这个地方可以理解为一个更抽象的抽象类，只要实现了该接口的类均能成为该数组中的元素，但一般很少直接定义接口数组

#### 判断奇偶数
与老师提供的代码不同，此处使用位运算判断奇偶数
```java
if((i & 1) == 1) // 判断奇偶
	s[i] = new Circle(1 + i, 1 + i, 2 * i); 
	else s[i] = new Rectangle(-1 - i, 1 + i, 1 + i, 2 * (1 + i)); 
```
`i & 1`若为奇数返回1，偶数返回0，这样计算时间更短

# 实验结果与验证
## 结果验证
经检验得，面积计算的结果均正确，且原代码、优化一、优化二结果一致，代码无误
## 讨论改进
1. **错误处理**：目前的代码没有处理可能的错误情况。例如，如果在创建`Rectangle`或`Circle`对象时传入了不合理的参数（如负数半径），代码不会进行任何错误检查。考虑添加合适的错误处理或验证逻辑。
2. **增加构造函数的参数验证**：对于`Rectangle`和`Circle`的构造函数，可以增加对传入参数的验证。例如，如果长宽或者半径为负数，可以抛出一个异常。
3. **使用数学库中的π值**：为了更精确的计算面积，可以使用数学库中的π值，而不是硬编码的3.14，如下例
```java
public class Main { 
	public static void main(String[] args) { 
		double radius = 5.0; 
		double circumference = 2 * Math.PI * radius;  
		System.out.println("圆的周长为: " + circumference); 
	} 
}
```
4. **动态绑定中的输出**：在`getTotalArea()`方法中，每次计算面积时都会输出当前的总面积。这可能不是所有用例都需要的功能。考虑将输出总面积的操作与计算总面积的操作分离，使它们更加解耦。
5. **关于坐标：** 在原本老师提供的代码中，`x, y`只是作为基本属性，但并未使用，在优化后的代码中，对这两个变量进行了显示，使得代码清晰度更高，符合需要