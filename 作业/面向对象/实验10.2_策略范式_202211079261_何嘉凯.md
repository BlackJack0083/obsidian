```java
package lesson10;

interface Strategy{
	int doOperation(int x1, int x2);
}

class OperationAdd implements Strategy{  // 加法
	public int doOperation(int x1 , int x2) {
		System.out.println(x1 + "+" + x2 + "=" + (x1+x2));
		return x1 + x2;
	}
}

class OperationSubtract implements Strategy{   // 减法
	public int doOperation(int x1 , int x2) {
		System.out.println(x1 + "-" + x2 + "=" + (x1-x2));
		return x1 - x2;
	}
}

class OperationMultiply implements Strategy{  // 乘法
	public int doOperation(int x1 , int x2) {
		System.out.println(x1 + "*" + x2 + "=" + (x1*x2));
		return x1 * x2;
	}
}

class OperationDivision implements Strategy{  // 除法
	public int doOperation(int x1 , int x2) {
		System.out.println(x1 + "/" + x2 + "=" + (x1/x2));
		return x1 / x2;
	}
}

class OperationPower implements Strategy{  // 乘方
	public int doOperation(int x1, int x2) {
		int t = x1;
		for(int i = 0; i < x2 - 1; i++) {
			x1 *= t;
		}
		System.out.println(t + "^" + x2 + "=" + (x1));
		return x1;
	}
}

public class Context {
	private Strategy strategy;
	public Context(Strategy strategy) {  // 构造器
		this.strategy = strategy;
	}
	
	public void setStrategy(Strategy strategy) {
		this.strategy = strategy;
	}
	
	public int executeStrategy() {
		return strategy.doOperation(10, 5);
	}
	/* 可改进为：
	public int executeStrategy(int x, int y) {
		return strategy.doOperation(x, y);
	}
	*/
	public static void main(String[] args) {
		Context context = new Context(new OperationAdd()); // 加法
		context.executeStrategy();
		
		context.setStrategy(new OperationSubtract()); // 减法
		context.executeStrategy();
		
		context.setStrategy(new OperationMultiply());  // 乘法
		context.executeStrategy();
		
		context.setStrategy(new OperationDivision());  // 除法
		context.executeStrategy();
		
		context.setStrategy(new OperationPower());  // 乘方
		context.executeStrategy();
	}
}
```

## 对应结果输出说明
![[微信截图_20231113165302.png]]

# 算法原理概述
### 对应的UML图
![[微信截图_20231113190037.png]]

### 原理阐述
这段代码是一个典型的策略模式（Strategy Pattern）的应用。策略模式是一种行为设计模式，允许你在运行时改变对象的行为。

### 代码解释：
1. `Strategy` 是一个接口，它定义了一个方法 `doOperation`，接受两个整数参数并返回一个整数。
2. `OperationAdd`, `OperationSubtract`, `OperationMultiply`, `OperationDivision`, 和 `OperationPower` 是实现了 `Strategy` 接口的具体策略类。每一个类实现了 `doOperation` 方法以执行具体的数学操作。
3. `Context` 类是使用策略的对象。它有一个 `Strategy` 类型的成员变量，通过构造函数或者 `setStrategy` 方法来设置。`executeStrategy` 方法调用当前策略的 `doOperation` 方法。
4. 在 `main` 方法中，创建了一个 `Context` 对象，并依次设置了不同的策略对象，然后执行这些策略。

#### 策略范式的应用：
在这个例子中，策略范式用于将算法的选择与使用算法的客户端代码分离。这样做有几个好处：
1. **灵活性：** 你可以在运行时改变对象的行为。例如，在 `main` 方法中，同一个 `Context` 对象用于执行不同的数学操作。
2. **可扩展性：** 如果想添加新的操作（比如求模运算），只需要创建一个新的类实现 `Strategy` 接口，而不需要修改现有的代码。
3. **重用性：** 现有的策略类和 `Context` 类可以在其他项目中重用。
4. **清晰性：** 使用策略模式使得代码更容易理解和测试，因为每一个策略都是一个封装好的独立模块。

# 实验结果与验证
## 结果验证
经测试得，对于各种计算方式，均能得到正确答案，代码正确
## 代码改进
**1. 异常处理：**
目前的代码在进行除法或乘方运算时，可能会产生除以0的错误，但代码没有任何异常处理机制来应对这种情况。可以添加一些错误检查和异常处理机制来提高代码的健壮性。
```java
class OperationDivision implements Strategy {  // 除法  
    public int doOperation(int x1, int x2) {  
        if (x2 == 0) {  
            throw new IllegalArgumentException("除数不能为0");  
        }  
        System.out.println(x1 + "/" + x2 + "=" + (x1 / (double)x2));  
        return x1 / x2;  
    }  
}
```
**2. 扩展性：**
虽然现在已经有加法、减法、乘法、除法和乘方运算，但如果想扩展到更复杂的数学运算（例如，开方，三角函数等），可能需要为每种运算都新建一个类，这样会导致类数量过多。可以考虑使用更通用的数学表达式解析器来增强扩展性。
此外，对于乘方运算，可以使用Java内置的`Math.pow`函数代替循环，优化速度
乘方优化：
```java
class OperationPower implements Strategy {  // 乘方  
    public int doOperation(int x1, int x2) {  
        double result = Math.pow(x1, x2);  
        System.out.println(x1 + "^" + x2 + "=" + result);  
        return (int)result;  
    }  
}
```
**3. 泛型与参数化：**
目前的`executeStrategy`方法中硬编码了参数10和5。更好的做法是使用参数化，使得`executeStrategy`方法能接受任意参数，这样提高了方法的复用性。
**4. 接口与实现分离：**
可以将具体的策略实现与主程序分离，例如将策略实现放在单独的包里，这样主程序只依赖Strategy接口，而不依赖具体实现，符合依赖倒置原则，降低了耦合度。

