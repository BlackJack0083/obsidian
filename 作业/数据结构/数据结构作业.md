# 01
## 1.01 求所需的斐波那契数列
![[微信截图_20230901135248.png]]
```c
#include<stdio.h>
int main(void){
    int n;
    scanf("%d", &n);
    int a = 1, b = 1;
    while (a < n){  // 注意这里的斐波那契数列构造方法
        a = a + b;
        b = a - b;
    }
    printf("%d\n", a);
}
```

这里真的太久没做了...一开始竟然直接想要构造斐波那契数组，但感觉不是很好构造...
但是这道题目好像不需要这么麻烦，因为只要找到那个数字比n大就好了，不需要管之前的数字，所以直接利用动态更替数字找到相应的斐波那契数就好了

## 1.02
![[微信截图_20230901143447.png]]
方法一：(qsort)
```c
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
	return *(char *)a - *(char *)b;
}

int main(void) {
	int n;
	scanf("%d", &n);
	char ch[n];
	getchar();
	for (int i = 0; i < n; i++) {
		ch[i] = getchar();
		if (ch[i] >= 'A' && ch[i] <= 'Z')
			ch[i] += 32;
	}
	qsort(ch, n, sizeof(ch[0]), cmp);

	for (int i = 0; i < n; i++) {
		putchar(ch[i]);
	}
}
```

这一份是利用C语言的排序函数qsort进行排序，这里要引入头文件
```c
#include<stdlib.h>
```

同时要注意qsort的四个参数
`qsort(a[], num, sizeof(数据类型), cmp)`
*参数：*
	1.数组名
	2.元素个数（从前往后计算）
	3.数组元素所占字节（int，double，char等所占字节）
	4.排序原则（递增，递减，奇偶交叉等）
排序原则：
```c
int cmp(const void *a,const void *b) {
	return *(int*)a-*(int*)b;
}
qsort(num, n, sizeof(int), cmp);
```

我们通过定义一个函数cmp，通过cmp返回的参数来确定排序规则，需要注意的是：cmp函数的参数需要以`const void *a,const void *b`的形式来定义，表示*a和b的类型是未确定*的，在return中进行强制类型转换为int型。`*(int*)a-*(int*)b` 表示以*递增*顺序，若想以递减只需将a和b换位。

具体可参照[qsort函数详解](https://blog.csdn.net/Cooler_z/article/details/122384559)

方法二：快速排序
```c++
#include <stdio.h>
void swap(char &x, char &y){
    char temp = x;
    x = y;
    y = temp;
}
void quick_sort(char a[], int l, int r) 
{
    if (l >= r) return; // 递归出口

    char pivot = a[l + r >> 1];
    int i = l, j = r; //以中点作为参考点

    //划分为左右两半
    while (i <= j) {
        while(a[i] < pivot) i++; // a[i] 不需要移动
        while(a[j] > pivot) j--; // a[j] 不需要移动
        if (i <= j) 
            swap(a[i++], a[j--]); // a[i] > pivot, a[j] < pivot, 左右交互
    }

    quick_sort(a, l, j); // 左边排序
    quick_sort(a, i, r); // 右边排序
}

int main(void) {
	int n;
	scanf("%d", &n);
	char ch[n];
	getchar();
	for (int i = 0; i < n; i++) {
		ch[i] = getchar();
		if (ch[i] >= 'A' && ch[i] <= 'Z')
			ch[i] += 32;
	}
	quick_sort(ch, 0, n - 1);
	for (int i = 0; i < n; i++) {
		putchar(ch[i]);
	}
}
```

方法三：哈希表
构造26个字母的数组，逐个读入数据，每次+1，最后再用循环遍历数组，逐个输出

# 03
## 1.01 点赞
![[微信截图_20230913194229.png]]
这个想不出有什么特别好的办法，感觉直接用数组统计下次数然后再找出最大值就可以了，但是不要忘了怎么找出一维数组的最大值，整体步骤是先让max下标为0，从头开始遍历，如果遇到了比它大的就更改下标，此题因为限制条件是留下最大编号，所以条件设为了大于等于
```c
#include<stdio.h>
int main(void){
    int N, K, code;
    scanf("%d", &N);
    int feature[1001] = {0}; // 设置全0数组
    for(int i = 0; i < N; i++){
        scanf("%d", &K); 
        for(int j = 0; j < K; j++){
            scanf("%d", &code);
            feature[code - 1]++;  // 对应的编码位置+1，因为数组从0开始，所以要-1
            // if(a[x] >= a[max] && x > max) x = max; 这样就可以在循环内部进行查找最大值，后面就不需要再用循环查找
        }
    }
    int max = 0;
    for(int i = 0; i < 1000; i ++){
        if (feature[max] <= feature[i]){
            max = i; 
        }
    }
    printf("%d %d", max+1, feature[max]); // 最后要+1回到原来的编号
}
```


## 1.02 数组后移
![[微信截图_20230913194304.png]]
这个地方能想到的有两种思路，第一种是构建中间变量temp，然后找到头和尾的数学表达关系，逐个进行替换，这样应该效率最高，但是不好操作；第二种是把要平移的数组给单独挑出来，再放回去(或者直接存在另外一个数组就好)，这样最简单，但要浪费空间

方法二：
```c
#include<stdio.h>
int main(void){
    int n, m;
    scanf("%d%d", &n, &m);
    m %= n;
    int a[n], b[m];
    for(int i = 0 ; i < n; i++){
        scanf("%d", &a[i]);;
    }
    if(m == 0){
        printf("%d", a[0]);
        for(int i = 1; i < n; i++){
            printf(" %d", a[i]);
        }
    }else{
        for(int i = n - m, j = 0; i < n; i++){
            b[j++] = a[i];
        }
        // 实现数组后移
        int k = n;
        for(int i = n-m-1; i >= 0; i--, k--){
            a[k-1] = a[i];
        }
        // 填回去
        for(int i = 0; i < m; i++){
            a[i] = b[i];
        }
        printf("%d", a[0]);
        for(int i = 1; i < n; i++){
            printf(" %d", a[i]);
        }
    }
}
```
简化版：
```c++
#include<stdio.h>
int main(void){
    int n, m;
    scanf("%d%d", &n, &m);
    int a[n], b[n];
    for(int i = 0 ; i < n; i++){
        scanf("%d", &a[i]);;
    }

	for(int j = 0; j < n; j++){
		int item = j + m % n;
		if (item < n){
			b[item] = a[j];
		}else{
			item -= n;
			b[item] = a[j];
		}
	}
	for(int j = 0; j < n; j++){
		printf("%d", b[j]);
	}
}
```
或者可以让数组不动，改变打印顺序

# 04
## 1.02 小明打字
![[微信截图_20230924170214.png]]![[微信截图_20230924170234.png]]

实现的话因为强调了向左和向右移动一位，所以能想到用双向链表进行解决，但是这里老师还没有讲，所以先去CSDN上查了查，好像和课本差不多？这里我忘记了一个很重要的读入语句`while((ch = getchar()) != '\n')`，需要引起重视。

CSDN上面的解答：
```c++
#include <algorithm> 
#include <cstring>
#include <iostream>
using namespace std;

typedef struct LNode {
    char ch;
    LNode* next;
    LNode* prev;
} * List;

int main() {
    char ch;
    List start, end, tmp;  //带空头节点链表, 每次插入tmp后面
    List L = new LNode();
    start = L;
    end = L;
    tmp = L;

    bool isInsert = true;

    List ins;
    while (scanf("%c", &ch) && ch != '\n') {
        if (ch == '[') {
            tmp = start;
        } else if (ch == ']') {
            tmp = end;
        } else if (ch == '{') {
            if (tmp->prev) tmp = tmp->prev;
        } else if (ch == '}') {
            if (tmp->next) tmp = tmp->next;
        } else if (ch == '-') {
            isInsert = !isInsert;
        } else if (ch == '=') {  //删除tmp
            if (tmp->prev) {
                List t = tmp;
                tmp->prev->next = tmp->next;
                if (tmp->next) {
                    tmp->next->prev = tmp->prev;
                    tmp = tmp->prev;
                } else {
                    tmp = tmp->prev;
                    tmp->next = NULL;
                }
                delete t;
                if (tmp->next == NULL) end = tmp;  //如果是删除最后的, 更新end
            }
        } else {  // tmp后面添加
            ins = new LNode();
            ins->ch = ch;
            ins->next = tmp->next;
            ins->prev = tmp;
            tmp->next = ins;
            tmp = ins;
            if (tmp->next == NULL) end = tmp;  //如果插入在最后, 更新end
            if (!isInsert && tmp->next) {  //如果是替换, 且tmp下一个存在, 再删除tmp下一个
                List t = tmp->next;
                if (t->next) {
                    tmp->next = t->next;
                    t->next->prev = tmp;
                    delete t;
                } else {	//删除元素在末尾
                    delete t;
                    end = tmp;  //更新end
                    tmp->next = NULL;
                }
            }
        }
        // end->next = NULL;	//保险, 但没必要
    }

    tmp = start->next;
    while (tmp) {
        printf("%c", tmp->ch);
        tmp = tmp->next;
    }
    // 注意清理内存, 这里节省运行时间不清理

    return 0;
}
```

这个题目整体还是比较坑的（针对还没学双向链表的小白来说），一开始照着书打的时候还犯了段错误...唔段错误的原因是给tmp分配了内存空间？
>gpt的回复：
>我查阅了一些相关资料，发现可能的原因是这样的：
>- 您的代码中，tmp是一个指向双向链表节点的指针，它的初始值是first->lLink，也就是指向双向链表的末尾节点。
>- 当您给tmp分配内存时，相当于创建了一个新的节点，并让tmp指向它。但是这个新节点并*没有插入到双向链表中*，它*只是一个孤立的节点*，没有前驱和后继。
>- 当您在后面的代码中对tmp进行操作时，例如tmp->rLink或者tmp->lLink，就会访问到不属于当前进程地址空间中的地址，导致段错误。
>所以，我建议您不要给tmp分配内存，而是让它指向双向链表中已经存在的节点。如果您想插入新节点，可以*在else分支中使用s来创建新节点，并插入到合适的位置*。这样就可以避免段错误的发生。

然后这个地方卡了很久的原因是因为当时没有彻底理解双向链表是怎么构造的，指针之间是怎么互相指向的，用笔画一遍感觉好多了，这个地方错了还挺多，一个是关于头结点其实是一直不动的，所以直接让tmp=first就好了，另一个是插入操作的指针指向，当时没弄明白，直接把tmp给替换了，后面调试发现需要替换的是tmp的下一位

**总之还是得多画！！！**

我自己照着书打的：
```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

typedef struct Node{
    char data;
    struct Node * rLink, * lLink;
} DblNode, *DblList;

int main(void) {
    // 初始化双向链表
    // 创建头结点
    DblList first;
    first = (DblList) malloc (sizeof(DblNode));
    first -> rLink = first;
    first -> lLink = first;

    // 光标初始位置为双向链表末尾
    DblList tmp = first -> lLink;
    int insert_flag = 1; // 插入标志

    char ch;
    while((ch = getchar()) != '\n') {
	    //tmp = (DblList)malloc (sizeof(DblNode)); // 会报段错误！
        DblList s, q;
        if (ch == '[') { // 将光标移动到双向链表头
            tmp = first ; // 直接first就好！！不用first -> rLink，这样会有一位在前面
        } else if (ch == ']') { // 将光标移动到双向链表末尾
            tmp = first -> lLink;
        } else if (ch == '{') { // 将光标向左移动一位
            if (tmp -> lLink != first -> lLink) // 注意光标位置，限制一下光标的范围
                tmp = tmp -> lLink;
        } else if (ch == '}') { // 将光标向右移动一位
            if (tmp -> rLink != first)
                tmp = tmp -> rLink;
       } else if (ch == '-') { // 切换插入模式
            insert_flag = -insert_flag;
       } else if (ch == '=') { // 删除当前节点
            if (tmp != first ) {
                DblList t = tmp;
                tmp -> rLink -> lLink = tmp -> lLink;
                tmp -> lLink -> rLink = tmp -> rLink;
                tmp = tmp -> lLink;
                free(t);
            }
        } else { // 插入新节点
            s = (DblList) malloc(sizeof(DblNode)); // 分配内存
            s -> data = ch;
            q = tmp -> rLink;
            if (insert_flag > 0) { 
                s -> lLink = tmp;
                q -> lLink = s;
                tmp -> rLink = s;
                s -> rLink = q;
            } else { // 注意这个地方的插入是替换tmp的下一位，不是tmp本身
                s -> lLink = tmp;
                q -> rLink -> lLink = s;
                tmp -> rLink = s;
                s -> rLink = q -> rLink;
            }
            tmp = s;  // 更新tmp
        }
    }
        
    // 输出双向链表
    DblList p = first -> rLink;
    while(p != first) {
        printf("%c", p -> data);
        p = p -> rLink;
    }
    return 0;
}
```

# 6
## 1.1 栈的基本操作
最简单的写法当然直接用STL库实现：
```c++
#include<stack>
#include<iostream>

using namespace std;

int main(void){
    int n, d;
    stack<int>stkInt;
    cin >> n;
    for(int i = 0 ; i < n; i++){
        int choice;
        cin >> choice;
        if(choice == 1){
            cin >> d;
            stkInt.push(d);
        }else{
            if(stkInt.size() == 0) 
                cout << "invalid" << endl;
            else{
                cout << stkInt.top() << endl;
                stkInt.pop();
            }
        }
    }
    return 0;
}
```



# 7
## 1.1
基础队列操作
STL实现：
```c++
#include<iostream>
#include<queue>

using namespace std;
int N, command, d, output;
queue<int>quInt;

int main(void){
    cin >> N;
    for(int i = 0; i < N; i++){
        cin >> command; 
        if(command == 1){
            cin >> d;
            quInt.push(d);
        }else if(command == 2){
            if(quInt.size() == 0) cout << "no" << endl;
            else{
                output = quInt.front();
                cout << output << endl;;
                quInt.pop();
            }
        }else cout << quInt.size() << endl;
    }
}
```
当然用数组做也很简单：
```c
#include<stdio.h>
int main(void){
    int N, command, m, out;
    int queue[50];
    int front = 0, rear = 0; 
    scanf("%d", &N);
    for(int i = 0; i < N ;i ++){
        scanf("%d", &command);
        if(command == 1) {
            scanf("%d", &m);
            queue[rear++] = m; 
        }else if(command == 2){
            if(rear - front == 0) printf("no\n");
            else{
                out = queue[front++];
                printf("%d\n", out);
            }
        }else{
            printf("%d\n", rear - front);
        }
    }
}
```

## 1.2 有趣的队列
也没有难度，直接STL（绷不住了，CSDN也用STL）：
```c++
#include<iostream>
#include<queue>

using namespace std;
int n, m, command;
queue<int>queInt;

int main(void){
    cin >> n >> m;
    int i = 1;
    for(int j = 0; j < m; j++){
        cin >> command;
        if(command == 0) queInt.push(i++);
        else{
            int out = queInt.front();
            queInt.pop();
            queInt.push(out);
        }
    }
    for(int i = 0; i < n - 1; i++){
        cout << queInt.front() << " " ;
        queInt.pop();
    }
    cout << queInt.front();
}
```

不过不用STL好像会卡内存...不能开大数组，可能用链式队列容易些

# 10
## 构造二叉树
树结构一般都采用递归！！！
林老的代码是层次构造二叉树，注意不要弄混，对于二叉树的构造，一般采用递归
```c++
#include<iostream>
using namespace std;
int count = 0;

typedef struct BTNode{
    char data;
    struct BTNode *lchild, *rchild;
}BTNode, *pBTNode;

pBTNode createBTree(pBTNode &root){  // 递归构造二叉树
    char ch;
    scanf("%c", &ch);
    if(ch == '#'){
        root = NULL;
    }else{
        root = (pBTNode)malloc(sizeof(BTNode));
        root -> data = ch;
        root -> lchild = createBTree(root -> lchild);//构造左子树
        root -> rchild = createBTree(root -> rchild);
    }
    return root;  // 不要忘记返回值！！！
}

void PreOrder(pBTNode &T){
    if(T != NULL){
        printf("%c", T -> data);
        PreOrder(T -> lchild);   // 这里三个遍历方式内部递归函数名与递归方式一致
        PreOrder(T -> rchild);
    }
}

void InOrder(pBTNode &T){
    if(T != NULL){
        InOrder(T -> lchild);
        printf("%c", T -> data);
        InOrder(T -> rchild);
    }
}

void PostOrder(pBTNode &T){
    if(T != NULL){
        PostOrder(T -> lchild);
        PostOrder(T -> rchild);
        printf("%c", T -> data);
    }
}

void left(pBTNode &T){
    if(T == NULL) return;
    // 寻找叶节点的方法
    if(T -> lchild == NULL && T -> rchild == NULL) count ++;
    left(T -> lchild);
    left(T -> rchild);
}

int main(void){
    pBTNode root;
    createBTree(root);
    if(root != NULL){
        PreOrder(root);
        printf("\n");
        InOrder(root);
        printf("\n");
        PostOrder(root);
        printf("\n");
    }
    left(root);
    printf("%d", count);
}
```

另外一种递归方法，没有区别，只不过一个是一个一个读入，另一个是一次读入整个数组：
```c++
#include<iostream>
using namespace std;
int count = 0;

typedef struct BTNode{
	//...//
}BTNode, *pBTNode;

void createBTree(pBTNode &T, char pre[], int &n) {
	//以递归方式建立二叉树,pre[]是输入序列,
	//以';'结束,空结点的标识为'#'
	//引用参数n初始调用前赋值0,退出后n是输入统计
	char ch = pre[n++]; //读入一个结点的数据
	if (ch == '\0') return; //处理结束,返回
	if (ch != '#') { //建立非空子树
		T = (BTNode *)malloc(sizeof(BTNode)); //建立根结点
		T -> data = ch;
		createBTree(T->lchild, pre, n); //递归建立左子树
		createBTree(T->rchild, pre, n); //递归建立右子树
	} else T = NULL; //否则建立空子树
}
//...中间内容一致//

int main(void){
    char s[100010];
    int n = 0;
    cin >> s; // 读入方式要记住，不能读给指针
    pBTNode root;
    createBTree(root, s, n); 
     // 这里因为传递的是引用变量，所以不能直接填0，要有个变量表示
    //.../
}
```


# 11 Windows消息队列
本质上是构造小根堆，但这里的堆还包含了`string`的额外信息，所以最好用结构体实现，或者可以用STL的优先队列实现，但这里必须要注意优先队列的写法！！
```c++
#include<bits/stdc++.h>

using namespace std;

struct Compare {  
    bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) {  
        return lhs.first > rhs.first; // 根据整数进行排序  
    }
};

string s1, s2;
priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q;  

int main(void){
    int n, p;
    scanf("%d", &n);
    while(n--){
        cin >> s1;
        if(s1 == "PUT") {
            cin >> s2 >> p;
            q.push({p, s2});
        }
        if(s1 == "GET"){
            if(q.empty()) cout << "EMPTY QUEUE!" << endl;
            else{
                cout << q.top().second << endl;
                q.pop();
            }
        }
    }
}
```

# 12
采用哈希表
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 300010;
int n, mindis;
char ch[19];
unsigned long long int num, k, null = 0x3f3f3f3f3f3f3f3f, head[N], dis[N];

unsigned long long int find(unsigned long long int x) { // 如果x存在，则返回它的位置，如果不在，则返回它应该在的位置
	unsigned long int k = (x % N + N) % N;
	// 将x映射到数组范围内
	while (head[k] != null && head[k] != x) {
		k++;
		if (k == N) k = 0;
	}
	return k;
}

int main(void) {
	int distance;
	memset(head, 0x3f, sizeof head);
	memset(dis, 0, sizeof dis);

	scanf("%d%d", &n, &mindis);
	while (n--) {
		scanf("%s%d", ch, &distance);
		num = 0;
		for (int i = 0; i < 17 ; i++) {
			num = num * 10 + (ch[i] - '0');
		}
		if ('0' <= ch[17] && ch[17] <= '9') num = num * 100 + (ch[17] - '0');
		else num = (num * 10 + 1) * 10;

		k = find(num);
		head[k] = num;
		if (distance < mindis) dis[k] += mindis;
		else dis[k] += distance;
	}
	scanf("%d", &n);
	while (n--) {
		scanf("%s", ch);
		num = 0;
		for (int i = 0; i < 17 ; i++) {
			num = num * 10 + ch[i] - '0';
		}
		if ('0' <= ch[17] && ch[17] <= '9') num = num * 100 + (ch[17] - '0');
		else num = (num * 10 + 1) * 10;

		k = find(num);
		if (dis[k] == 0) printf("No Info\n");
		else {
			printf("%lld\n", dis[k]);
		}
	}
}
```

`map`实现
```c++
#include <bits/stdc++.h>
using namespace std;
map<string ,int> vip;
int main()
{
	char id[17];
	int m,n,k,i,y;
	cin>>n>>k;
	for(i=0;i<n;i++)
	{	
		scanf("%s%d",id,&y);
		if(y<k) 
			y=k;
		vip[id]+=y;
	}
	scanf("%d",&m);
	for(i=0;i<m;i++)
	{
		scanf("%s",id);
		if(vip.find(id)!=vip.end())
			printf("%d\n",vip[id]);
		else 
			printf("No Info\n");
	}	
}
```

# 15 统计时间并按从大到小输出
- 这里需要用结构体噜，不然不好，不过之前都没怎么用过emm，还报过几次错，这里比较了`time`以后交换的是结构体变量！！不是结构体变量对应的`time`！！！
- 注意结构体的`id`一定要先初始化，不然会报错！！因为后面是按照`id`来记录`time`
- 这里的归并排序同样需要用一个`student`类的结构体数组作为辅助数组，用来迁移数据，注意，归并排序因为是稳定的，所以这个地方不能直接改变最后输出的开端进行逆序打印，而是直接改变归并排序的大小符号
- 这里还要注意下前导0怎么输出
```c++
#include <bits/stdc++.h>
using namespace std;

int n, m, hour, minute, second, start, ending, id;
const int N = 1010;

typedef struct {
	int idx;
	int time;
} student;

student stu[N], tmp[N]; // 辅助数组

void merge_sort(student a[], int l, int r) {
	if (l >= r) return;   // 递归出口

	int mid = (l + r) >> 1; // 二分
	merge_sort(a, l, mid);  // 左边排序
	merge_sort(a, mid + 1, r); // 右边排序

	// 合并 左[l, mid] 和 右[mid+1, r]两边有序数组
	int k = 0, i = l, j = mid + 1;
	while (i <= mid && j <= r)
		if (a[i].time >= a[j].time) tmp[k++] = a[i++];
		else              tmp[k++] = a[j++];

	while (i <= mid)      tmp[k++] = a[i++];
	while (j <= r)        tmp[k++] = a[j++];

	// 辅助数组复制到原数组
	k = 0;
	while (l <= r) a[l++] = tmp[k++];
}

int main(void) {
	scanf("%d%d", &n, &m);
    // 注意要给结构体初始化，尤其是对应的id，因为如果在后面填入的话可能会顺序颠倒
    for(int i = 0; i < n; i++){
        stu[i].idx = i;
        stu[i].time = 0;
    }
    
	for (int i = 0; i < m; i++) {
		scanf("%d", &id);
		scanf("%d:%d:%d", &hour, &minute, &second);
		start = hour * 3600 + minute * 60 + second;
		scanf("%d:%d:%d", &hour, &minute, &second);
		ending = hour * 3600 + minute * 60 + second;
		stu[id].time += ending - start;
	}
	merge_sort(stu, 0, n - 1);
	for (int i = 0; i < n; i++) {
		hour = stu[i].time / 3600;
		minute = (stu[i].time - hour * 3600) / 60;
		second = stu[i].time - hour * 3600 - minute * 60;
		printf("%03d %02d:%02d:%02d\n", stu[i].idx, hour, minute, second);
	}
}
```
也可以用系统内置的`sort`函数进行排序，这里要对`cmp`函数进行重写
```c++
#include<bits/stdc++.h>
using namespace std;
struct no
{
	int h,m,s,t;//所看的时间，t是看的总时间，单位是秒。
	int id;//学号
}p[10001];
bool cmp(no x,no y)//排序方式
{
	if(x.t==y.t)
	{
		return x.id<y.id;
	}
	else
		return x.t>y.t;
}
bool b[1010];//记录是否看过快手的同学，我刚开始用map记录的，但是超时了
int main()
{
	int i;
	memset(b,false,sizeof(b));//对b数组初始化
	for(i=0;i<1001;i++)
	{
		p[i].h=p[i].m=p[i].s=p[i].t=0;//对每个人所看的时间初始化
		p[i].id=i; //学号是从000开始的
	}
	int n,m_,num;
    int h1,m1,s1,h2,m2,s2;//开始时间和结束时间
	int t,t1,t2;
	cin>>n>>m_;
	for(i=0;i<m_;i++)
	{
		scanf("%d %d:%d:%d %d:%d:%d",&num,&h1,&m1,&s1,&h2,&m2,&s2);
		b[num]=true;//记录看过快手的同学
		p[num].id=num;
		t1=h1*3600+m1*60+s1;
		t2=h2*3600+m2*60+s2;//把开始时间和结束时间都化作秒
		p[num].t+=t2-t1;//所看的时间差
	}
	sort(p,p+n,cmp);//对所有人排序
	for(num=0;num<n;num++)
	{
		t=p[num].t;
		p[num].h+=t/3600;//所看的小时
		t-=t/3600*3600;
		p[num].m+=t/60;//分钟
		t-=t/60*60;
		p[num].s+=t;//秒
		if(p[num].s>=60)//处理秒超过60
		{
			p[num].m+=p[num].s/60;
			p[num].s=p[num].s%60;
		}
		if(p[num].m>=60)//处理分钟超过60
		{
			p[num].h+=p[num].m/60;
			p[num].m=p[num].m%60;
		}
	}
	for(i=0;i<n;i++)
	{
		if(b[p[i].id]==false)//对没有看过快手的同学输出
		printf("%03d 00:00:00\n",p[i].id);
		else
		printf("%03d %02d:%02d:%02d\n",p[i].id,p[i].h,p[i].m,p[i].s);//输出看过快手的同学
	}
	return 0;
}
```