# 实验目的
1. 掌握 IEEE754 浮点数在机器中的表示；
2. 掌握高级语言中数据类型的转换和移位操作结果。

# 实验内容
## float 和 double 类型比较
### 程序实现：
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
int main(void){  
    float a = (100 + 1.0/3) - 100, b = 1.0 / 3;  
	printf("a = %f, b = %f\n", a, b);  
	
	if(a == b) cout << "true" << endl;  
    else cout << "false" << endl;  
    
	double a1 = (100 + 1.0/3) - 100, b1 = 1.0 / 3;  
	printf("a1 = %lf, b1 = %lf\n", a1, b1);  
	
	if(a1 == b1) cout << "true" << endl;  
    else cout << "false" << endl;  
}
```
### 输出结果：
![[微信截图_20240316095426.png]]
### 结果说明
当我们对浮点数进行计算时，计算机内部使用的是二进制表示，而不是十进制。虽然我们使用十进制表示的数值，但是在计算机内部它们被转换成了二进制。因此，某些十进制小数可能无法准确地表示为有限的二进制小数。

考虑到这一点，当我们进行浮点数的计算时，可能会产生舍入误差。这是因为计算机内部表示的浮点数精度是有限的，它无法准确地表示一些十进制小数，尤其是无限循环小数。

在给定的例子中， `(100 + 1.0/3) - 100` 的计算结果实际上并不是精确的 1/3，而是一个非常接近 1/3 的浮点数。当我们将这个值赋给变量 `a` 和 `a1`（分别为 float 和 double 类型）时，它们的存储精度不同。

在第一个比较中，`a` 和 `b` 都是 float 类型，因此它们的精度较低，可能无法准确表示 `(100 + 1.0/3) - 100` 的计算结果。这导致了在比较 `a` 和 `b` 时，它们的值被认为是相等的，即 `a == b` 为 true。

在第二个比较中，`a1` 和 `b1` 都是 double 类型，因此它们的精度更高，可以更接近地表示 `(100 + 1.0/3) - 100` 的计算结果。这可能导致 `a1` 和 `b1` 的值在二进制表示中略有不同，超出了浮点数精度所能表示的误差范围。因此，当比较 `a1` 和 `b1` 时，它们的值被认为是不相等的，即 `a1 == b1` 为 false。

## 实现类型转换与移位操作
### 程序实现
#### 1
程序实现
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
int main(void){  
    short sa = -12345;  
    cout << "sa = " << sa << endl;  
    printf("16 进制表示为: %hx\n", sa);  
        
    int isa = (int)sa;  
    cout << "isa = " << isa << endl;  
    printf("16 进制表示为: %x\n", isa);  
        
	unsigned short usa = (unsigned short) sa;  
    cout << "usa = " << usa << endl;  
    printf("16 进制表示为: %hx\n", usa);  
        
	unsigned int uisa = (unsigned int)sa;  
    cout << "uisa = " << uisa << endl;  
    printf("16 进制表示为: %x\n", uisa);  
        
	float fsa = (float)sa;  
    printf("fsa = %f\n", fsa); 
    printf("16 进制表示为: %a\n", fsa);  
}
```
输出结果:
![[微信截图_20240316102558.png]]

#### 2
程序实现
```c++
#include<bits/stdc++.h>  
  
using namespace std;  
  
int main(void){  
	int b = 2147483647;  
    cout << "b = " << b << endl;  
    printf("16 进制表示为: %x\n", b);  
    
	short sb = (short)b;  
    cout << "sb = " << sb << endl;  
    printf("16 进制表示为: %hx\n", sb);  
    
	unsigned short usb = (unsigned short) b;  
    cout << "usb = " << usb << endl;  
    printf("16 进制表示为: %hx\n", usb);  
    
	unsigned int ub = (unsigned)b;  
    cout << "ub = " << ub << endl;  
    printf("16 进制表示为: %x\n", ub);  
    
	float fb = (float)b;  
    printf("fb = %f\n", fb);
    printf("16 进制表示为: %a\n", fb); }
```
输出结果：
![[微信截图_20240316102700.png]]

#### 3 & 4
```c++
#include<bits/stdc++.h>

using namespace std;

int main(void){
	// 3
	float c = 123456.789e5;
	printf("c = %f\n", c);
	printf("16进制表示为: %a\n", c);
	
	double dc = (double)c;
	printf("dc = %lf\n", dc);
	printf("16进制表示为: %a\n", dc);
	
	// 4
	double d = 123456.789e5;
	printf("d = %lf\n", d);
	printf("16进制表示为: %a\n", d);
	
	float fd = (float)d;
	printf("fd = %f\n", fd);
	printf("16进制表示为: %a\n", fd);
}
```
输出结果：![[微信截图_20240316102415.png]]
#### 5
```c++
#include<bits/stdc++.h>
using namespace std;

int main(void){
	short e = -12345;
	printf("e =  %hd\n", e);
	printf("16进制表示为: %hx\n", e);
	
	short le = e << 2;
	printf("le =  %hd\n", le);
	printf("16进制表示为: %hx\n", le);
	
	short re = e >> 2;
	printf("re =  %hd\n", re);
	printf("16进制表示为: %hx\n", re);
	
	unsigned short f = (unsigned short)-12345;
	printf("f =  %hu\n", f);
	printf("16进制表示为: %hx\n", f);
	
	unsigned lf = f << 2;
	printf("lf =  %hu\n", lf);
	printf("16进制表示为: %hx\n", lf);
	
	unsigned rf = f >> 2;
	printf("rf =  %hu\n", rf);
	printf("16进制表示为: %hx\n", rf);
}
```
输出结果：
![[微信截图_20240316104244.png]]

### 问题回答
1. `float` 型数据是否总能转换成等值的 `double` 型数据？为什么？
	1. 是的，`float`类型的数据可以转换为等值的`double`类型数据。这是因为`double`类型的表示范围比`float`类型更广，可以容纳更大范围的值以及更高的精度。在转换时，`float`类型的数据会被精确地转换为`double`类型的数据，因为`double`类型可以更精确地表示小数，可见测试3结果；
	2. 但是反过来，`double`转化为`float`类型时，由于精度差异，导致会出现溢出，使得`float`不能精确表示`double`类型数据，可见*测试4*结果，`double`类型为12345678900.00000，但转换为`float`后变为了12345678848.00000。
	
2. 长数被截断成短数后可能发生什么现象？为什么？
	1. 当长数被截断成短数时，可能会发生**溢出**现象。这是因为短数的表示范围比长数的表示范围更小，可能无法容纳长数的所有值。因此，如果长数的值超出了短数可以表示的范围，那么在截断操作时，超出部分的值将被丢弃，可能导致数据丢失和不准确的结果。
	2. 在*测试2*中，可以看到在长数(`int`)转换成短数(`short`)时，前面的多余位数会被截断。可能会使得**结果正负发生改变**
	
3. C 语言中移位操作规则与操作对象的数据类型有关吗？
	1. 在C语言中，移位操作的规则与操作对象的数据类型相关。对于**有符号整数**，右移操作会将最高位（符号位）进行扩展，即**算数右移**。对于**无符号整数**，移位操作会在最高位（最左边）插入0，即**逻辑右移**。在*测试5*中，可看到，同样是16进制cfc7，在进行右移时，有符号整数变为了f3f1，但无符号数变为了33f1；
	2. 但对于左移操作，均在右边补0。因此，移位操作的行为取决于操作对象的数据类型。
	
4. 左移 2 位和右移 2 位操作分别相当于扩大和缩小几倍？
	1. 左移2位操作相当于**将操作数乘以2的2次方**（即扩大4倍），而右移2位操作相当于**将操作数除以2的2次方**（即缩小4倍）。这是因为左移操作将二进制表示向左移动，相当于在二进制数末尾添加两个零，而右移操作则相反。
	2. 但是对于**有符号整数**，在左移或右移操作中可能会使得**符号位发生改变**，使得结果正负改变。可见*测试5*，有符号整数-12345在经过左移2位操作后变为了16156。

# 实验总结
本实验讨论了不同类型浮点数的精度问题，对`float`类型与`double`类型的转换与精度区别进行了分析；此外，本实验还完成了不同类型、不同长度的整数截断、移位操作，区分了算术移位与逻辑移位，并对位截断、移位中出现的问题进行了分析与说明。