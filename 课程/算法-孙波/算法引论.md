## 算法概念
### 算法定义
**算法的基本含义**：求解一确定问题的任意一种方法。
**非形式化的描述**：算法是有穷的合式规则集合，它规定了解决某一特定类型问题的一系列合式（well-formed，良定义）操作。即算法是满足下述性质的指令序列:
- 输  入：有零个或多个外部量作为算法的输入。 
- 输  出：算法产生至少一个量作为输出。 
- 确定性：组成算法的每条指令清晰、无歧义。 
- 有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限。

**1. 确定的有穷自动机DFA是一个五元组$M=( Q ，∑，δ，q_0，F)$**
- $Q$ ：有穷状态集，它的每一元素表示自动机的一个状态；
- $Σ$：有穷字母表，它的每一个元素表示一种输入字符；
- $δ$ ：$Q×Σ$ 到 $Q$ 的单值映射，$δ(s,a)=s’$表示在当前状态 $s$下，读入字符$a$，将转换到状态 $s’$;
- $q_0$ ：初始状态，$q0 ∈ Q$ ;
- $F$： 终止状态集，$F$是 $Q$ 的一个子集。
	**DFA可以接受“正则语言”**

**2. 下推自动机（PDA）是一个七元组**
	PDA是在DFA基础上，增加一个长度不受限制的存取栈。
	**非确定下推自动机可以接受“上下文无关语言”**

**3. 图灵机是一个七元组$M=(Q, τ, b, Σ, δ, q_0, F)$**，其中：
- $Q$ 是控制器的有限非空状态集；
- $τ$ 是磁带上有限非空的字母符号表；
- $b ∈ τ$ 是唯一的空白符号，可以在磁带上任意出现；
- $Σ ⊆ τ \backslash\{b\}$ 是输入字母表；
- $δ$为转移函数：$\{Q \ F\}× τ → Q x τ x \{L, R\}$；
- $q_0∈Q$ 是控制器的初始状态；
- $F$ 为$Q$ 的子集，是控制器的终态或接受状态集。
	**图灵机接受“递归可枚举语言”**

图灵机（Turing Machine）是由英国数学家艾伦·图灵（Alan Turing）于1936年提出的一种理论模型，用于描述计算过程和可计算性理论。图灵机被认为是计算理论的基础，是计算机科学的基石之一。

区别：
1. **有限自动机（DFA - Deterministic Finite Automaton）：**
   - 是一种抽象的计算模型，适用于处理正则语言。
   - 具有有限个状态和输入字母表，以及状态转移函数，可以接受或拒绝输入字符串。
   - 不具备内存，只能处理具有固定长度的输入。

2. **下推自动机（PDA - Pushdown Automaton）：**
   - 是一种介于有限自动机和图灵机之间的模型，适用于上下文无关文法描述的上下文无关语言。
   - 在有限自动机的基础上增加了栈（stack）作为附加内存，可以存储和检索信息。
   - 使用状态、输入和栈上的符号来进行状态转移。

3.  #图灵机（TuringMachine） ：
   - 是最通用的计算模型，能够模拟任何可计算的过程。
   - 包含一个无限长的纸带，上面可以写入和读取符号；一个读写头，可以在纸带上移动。
   - 具有一组状态和状态转移规则，可以根据当前状态和读取的符号来决定下一步的动作。
   - 能够模拟有限自动机和下推自动机。
![[图片13.png|500]]
**为什么要有这些东西？**
- **有限自动机（DFA）** 适用于描述正则语言，用于简单的模式匹配和字符串处理，例如词法分析。
- **下推自动机（PDA）** 扩展了对上下文无关语言的处理，对于一些语法分析和编译器的实现具有重要作用。
- **图灵机** 是一种理论上的计算模型，它可以用来研究可计算性理论和算法的性质。图灵机的概念帮助人们理解什么是可计算的，什么是不可计算的，以及在计算上存在的一些局限。

### 算法研究范畴
**数值计算**（求解数值问题，如求解：（非）线性方程、插值、积分、微分等）
**非数值计算**（求解非数值问题，如：排序、优化、着色、路径、遍历等）
### 算法特征
1. 输入
2. 确定性
3. 终止性
4. 输出
5. 能行性
### 评价准则
**1、正确性**
如果对任给的一个有效输入，算法总在<u>有限时间内</u>给出问题的正确答案，则称解算该问题的算法是正确的。这里主要指<u>算法的数学正确性</u>。因为数学正确性是程序正确性的基础。在编制算法时，要给出正确性的数学证明。 
**2、工作量**
工作量是指算法的执行时间，因为执行时间是与具体“执行机器”相关的，故存在一个如何度量工作量的问题。该度量必须反映出不同算法的有效性。“基本操作”常作为这种度量，指定的基本操作必须满足下列关系：
   设基本操作为$t(i)$次，$i$为输入规模
   则操作总数$≤C×t(i)$次，执行时间$≤C_1×t(i)$。
   这里$C，C_1$是常数。 
**3、空间用量**
指除去程序和输入数据的存贮空间以外要用的额外空间 
<u>算法就地工作</u>:额外空间用量是关于输入规模的常函数 (work in place) 
**4、简单性** 
算法应直观，清晰易读，一个简单的算法易于证明其正确性，也易于分析其工作量。
**5、最佳性**
设解某问题P，有一特定算法类$Ψ$(一般由基本操作而定)，对任一算法$A∈Ψ$，其时间复杂性为$T_A(n)$(最坏或平均)。定义$Cp(n)$如下：
$$C_{p}(n)＝\min_{ A∈Ψ} \{T_A(n)\}$$
 $C_p(n)$称问题P关于算法类Ψ的计算复杂性(找到最好的)。一个问题的计算复杂性是这个问题(在限制算法类)固有的。故常称为问题P的固有计算复杂性。 
## 表达算法的抽象机制
### 机器语言->高级语言
### 抽象数据类型(ADT)
抽象数据类型是算法的一个**数据模型**连同定义在该模型上并作为**算法构件**的一组**运算**
>好处：
（1）算法顶层设计与底层实现分离；
（2）算法设计与数据结构设计隔开，允许数据结构自由选择；
（3）数据模型和该模型上的运算统一在ADT中，便于空间和时间耗费的折衷；
（4）用抽象数据类型表述的算法具有很好的可维护性；
（5）算法自然呈现模块化；
（6）为自顶向下逐步求精和模块化提供有效途径和工具；
（7）算法结构清晰，层次分明，便于算法正确性的证明和复杂性的分析。 

## 算法设计的步骤
### 问题求解的艺术
![[图片14.jpg|500]]
### 基本步骤
1．问题陈述
2．模型拟制
	1、最适合这个问题的**数学模型**是什么?
    2、在已经解决的其它问题中有没有与此**类似的问题**? 
3．算法设计
	伪代码
4．算法正确性证明
	数学归纳法
	① 假定依据一系列的步骤(如步骤0到步骤m)给出了一个算法，则应对每一步提供证明，尤其是可能要**证明在这一步执行前后所存在的条件和引理**。
	②  应提供依据，**证明该算法将终止**。
5．算法实现
6．算法复杂性分析
7．实验测试
8．文件编制
## 算法复杂性分析
用 $T(N,I)$表示算法A在一台抽象计算机上的时间复杂度。其中
- $N$: 待求解问题的规模
- $D_N$: 所有可能的输入规模为N的输入构成的集合
- $P(D_N)$: $D_N$ 的概率分布;
- $I$: 算法的输入$I \in DN$
![[微信截图_20240312191809.png|500]]
则算法A的时间复杂度为：$$T(N,I)=\sum_{i=1}^k t_i e_i(N,I)$$这公式的意思就是每种运算次数 * 各自的执行时间，得到其时间复杂度

最坏情况下的时间复杂性：
$$T_{max}(N) = \max_{I \in D_N}T(N,I) = \max_{I\in D_N} \sum_{i=1}^k t_i e_i (N,I) = \sum_{i=1}^k t_ie_i(N, I^*)=T(N,I^*)$$
最好情况下的时间复杂性：
$$T_{min}(N) = \min_{I \in D_N}T(N,I) = \min_{I\in D_N} \sum_{i=1}^k t_i e_i (N,I) = \sum_{i=1}^k t_ie_i(N, \widetilde I)=T(N,\widetilde I)$$
平均情况下的时间复杂性：
$$T_{avg}(N)=\sum_{I \in D_N}P(I)T(N,I) = \sum_{I \in D_N}P(I)\sum_{i=1}^kt_ie_i(N,I)$$
其中$D_N$是规模为$N$的合法输入的集合；$I^*$是$D_N$中使$T(N, I^*)$达到$T_{max}(N)$的合法输入；$\widetilde I$是$D_N$中使$T(N,\widetilde I)$达到$T_{min}(N)$的合法输入；而$P(I)$是在算法的应用中出现输入$I$的概率。

算法复杂性在渐近意义下的阶和记号：$O、Ω、θ、o$![[图片1.png|500]]![[图片2.png|500]]![[图片3.png|500]]![[图片4.png|500]]![[图片5.png|500]]![[图片6.png|500]]![[图片7.png|500]]![[图片8.png|500]]![[图片9.png|500]]![[图片9.png|500]]![[图片10.png|500]]![[图片11.png|500]]![[图片12.png|500]]
总结：$O$表示高阶超不过的，$\Omega$表示低阶仍能超过的，$\theta$表示被限制在同一多项式内的