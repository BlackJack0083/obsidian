# 递归的概念
递归是事物的一种性质，如果一个事物的定义或处理过程中又引用到它自己，就称为该事物具有递归性质。如：直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。
## 举例
### 阶乘函数
$$
\begin{equation}
	n!=\left\{ 
		\begin{aligned} 
			& \quad 1, \quad &n = 0\\
			&\quad n(n-1)!, \quad &n > 0
		\end{aligned} 
	\right.
\end{equation}
$$
**边界条件与递归方程**是递归函数的二个要素，递归函数只有具备了这两个要素，才能在有限次计算后得出结果。
```c++
int factorial(int n){
	if(n <= 1) return 1;  // 边界条件
	else return n * factorial(n-1);  // 递归方程
}
```
>[!note] 递归 $\not=$ 递推
> **递推：** 从初值出发反复进行某一运算得到所需结果。-----从**已知到未知**，从小到大
> **递归：** 从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果----从**未知到已知**，从大到小，再从小到大
> 
> 相对于递归算法,递推算法免除了数据进出栈的过程，也就是说,不需要函数不断的向边界值靠拢,而直接从边界出发,直到求出函数值。
### 斐波那契数列
$$
\begin{equation}
	F(n)=\left\{ 
		\begin{aligned} 
			& \quad 1, \quad &n = 0\\
			& \quad 1, \quad &n = 1\\
			&\quad F(n-1) + F(n-2) &n > 1
		\end{aligned} 
	\right.
\end{equation}
$$
```c++
int fabonacci(int n){
	if(n == 0 || n == 1) return 1;
	else return fabonacci(n-1) + fabonacci(n-2);
}
```

>[!note]
>有意思的是，对于阶乘函数和斐波那契数列，我们均可以找到其的非递归表示法
>**阶乘**：$$n! = \prod_{k=1}^n k$$
>**斐波那契**(可以用离散数学的化为差分方程方法求解)：$$F(n) = \frac{1}{\sqrt 5}((\frac{1 + \sqrt 5}{2})^{n+1} - (\frac{1-\sqrt 5}{2})^{n+1})$$
>但是并不是所有递归都能化为非递归形式
### Ackerman函数
当一个函数及它的一个变量是由函数自身定义时，称这个函数是**双递归函数**
Ackerman函数A(n，m)定义如下：
$$\left\{ 
		\begin{aligned} 
			&A(1,0) = 2\\
			&A(0,m) = 1, \ &m \ge 0\\
			&A(n,0) = n + 2, \ &n \ge 2\\
			&A(n, m) = A(A(n-1,m), m-1), \ &n,m \ge1
		\end{aligned} 
\right.$$

1、M=0时
      $A(n,0)=n+2$
2、M=1时
     $A(n,1) = A(A(n-1,1), 0) = A(n-1,1)+2 = A(A(n-2,1), 0)+2*2 =….= A(1,1)+2(n-1)$
    $∵ A(1,1) =  A(A(0,1),0)=A(1,0)=2$
    $⸫ \ A(n,1)=2*n$
3、M=2时
     $A(n,2)=A(A(n-1,2),1)= 2*A(n-1,2) =…= 2^{n-1} * A(1,2)$（引用上一步M=1得出的结论）
    $∵ A(1,2)=A(A(0,2),1)=A(1,1)=2$
    $⸫ A(n,2)= 2^n$
4、M=3时，可以推出 
     $A(n, 3) = A(A(n − 1, m), 2) = 2^{A(n−1,3)}  = 2^{A(n−2,3)}  = 𝟐^{𝟐^{𝟐^{…^𝟐 } } }$
5、M=4时，A(n,4)的增长速度非常快，以至于没有适当的数学式子来表示这一函数。
	  $A(n,4)= A(A(n-1,4),3)=…= 𝟐^{𝟐^{𝟐^{…^𝟐}}} A(n-1,4)$
### 递归的优缺点
- 优点:结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序带来很大方便。
- 缺点:递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多
#### 解决方法
在递归算法中消除递归调用，使其转化为非递归算法。
1. 采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归，只不过人工做了本来由编译器做的事情优化效果不明显
2. 用迭代来实现递归函数。
3. 通过**Cooper变换**、**反演变换**能将一些递归转化为**尾递归**，从而迭代求出结果
后两种方法在时空复杂度上均有较大改善，但其适用范围有限
### 尾递归
以$f(n) = n!$为例：
普通递归：同上
尾递归：
```c++
int facttail(int n, int a) {
	if (n < 0) return (0);
	else if (n == 0) return (1);
    else if (n == 1) return (a);
    else  return facttail (n - 1, n * a);
}
```
尾递归是一种特殊的递归形式，指的是在递归调用中，递归函数的最后一步操作是调用自身。这意味着在递归调用后没有其他操作，直接返回调用结果。尾递归有一个特殊的性质，可以被一些编译器优化为迭代形式，从而减少堆栈空间的使用。

对于给定的代码，这是一个计算阶乘的函数，采用了尾递归形式。函数 `facttail` 接受两个参数 `n` 和 `a`，其中 `n` 是当前计算的阶乘数，而 `a` 是当前的累积结果。这个函数的逻辑如下：
1. 如果 `n` 小于 0，返回 0。
2. 如果 `n` 等于 0，返回 1。
3. 如果 `n` 等于 1，返回 `a`。
4. 对于其他情况，调用自身，传递参数 `n - 1` 和 `n * a`。
这个设计使得**函数调用发生在最后一步**，符合尾递归的定义。尾递归优化可以**在编译时将这种递归形式转化为迭代形式**，提高性能并减少堆栈空间的使用。在这个例子中，函数的尾递归形式使得递归深度对性能没有太大的负面影响。


# 分治法基本思想
将难以直接解决的大问题分割为小的问题，分别求解各个小问题的解， 然后再从小问题的解得到大问题的解。
**掌握分治方法的关键：**
1) 自顶向下分解问题
2) 自底向上合成答案

基本步骤：
```c
divide-and-conquer(P)
  {
    if (|P|<= n0) adhoc(P);   //解决小规模的问题
    divide P into smaller subinstances P1,P2,...,Pk；//分解问题
    for (i=1,i<=k,i++)
      yi=divide-and-conquer(Pi);  //递归的解各子问题
    return merge(y1,...,yk);  //将各子问题的解合并为原问题的解
  }
```
在用分治法设计算法时，最好使**子问题的规模大致相同**。即将一个问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种平衡(balancing)子问题的思想，它几乎总是比子问题规模不等的做法要好。
## 二者关系
由分治法产生的子问题往往是原问题的“缩小版”，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。
分治(divide and conquer)与递归(recursion)像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

