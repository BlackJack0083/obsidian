# 泛型
*在前些课程中，我们初步接触过泛型，主要是介绍数组的ArrayList泛型方法*
![[方法重载与静态成员#泛型]]
![[微信截图_20231022202959.png]]
JDK1.5后，引入了泛型技术，可以指定集合中对象的类型，编译器自动检测不合规范的类（不用`instanceof`判断），减少了类型转换的次数

### 泛型声明
**泛型声明的时候常用字母代表类型参数：字母是随意指定，但通常用有意义的字母**
- \<E>:element(集合)
- \<T>:type(常用于类或接口)
- \<K,V>:key(常用于集合键),value(常用于集合值)
- \<N>:number(常用于数值类型)
在给泛型指定具体类型后，
- 实际应用中可以传入该类型或者其子类类型
- 类型形参可以用字母表示，但类型实参必须是**类名**，不**能是基本数据类型**
![[微信截图_20240102085642.png]]
```java
public class Couple<T>{
	private T groom, bride;
	public Couple(T first, T second){
		groom = first; bride = second;
	}
	public T getFirst(){return groom;}
	public T getSecond(){return bride;}
}

public Couple<String> couple = new Couple("Tom", "Eve");
```

### 应用场景：泛型集合
泛型集合：保证集合中元素类型安全
```java
import java.util.*;
public class CollectionDemo{
	public static void main(String[] args){
		List <String> list = new ArrayList();
		list.add("Hello");
		// list.add(100);
		String str = list.get(0);
		System.out.println("first element in list:" + str);

		Set<Integer> set = new HashSet<>();
		set.add(200); set.add(1000);
		Iterator<Integer> iterSet = set.iterator();
		while(iterSet.hasNext()){
			Integer n = iterSet.next();
			System.out.println("next value:" + n);
		}
		Map<String, Integer> map = new HashMap();
		map.put("Tom", 20);
		map.put("Bob", 21);
		Set<String> keys = map.keySet();
		for(String o:keys){
			Integer n = map.get(o);
			System.out.println("value for key:" + o + ":" + n);
		}
	} 
}
```

这段代码是一个Java程序，用于演示Java集合框架中的泛型以及如何使用List、Set和Map接口。
1. **泛型（Generics）**：泛型是Java提供的一种机制，允许在类、接口和方法中使用类型参数。这使得代码更加灵活，可以适用于不同的数据类型，同时保持类型安全。
2. **List部分的代码**：
	* 创建一个ArrayList实例，并将其引用赋值给一个List\<String>类型的变量。这样，这个list就只能存储String类型的对象。
	* 使用`add`方法向list中添加一个字符串对象"Hello"。
	* 由于list被声明为String类型，因此不能添加非String类型的对象，例如`list.add(100);`这行代码被注释掉。
	* 使用`get`方法获取list中的第一个元素，并打印出来。
3. **Set部分的代码**：
	* 创建一个HashSet实例，用于存储Integer类型的对象。
	* 使用`add`方法向set中添加两个整数。
	* 获取一个Iterator，用于遍历set中的元素。
	* 使用while循环和Iterator的`hasNext`和`next`方法来遍历并打印set中的每一个元素。
4. **Map部分的代码**：
	* 创建一个HashMap实例，用于存储键为String类型、值为Integer类型的键值对。
	* 使用`put`方法向map中添加两个键值对。
	* 使用`keySet`方法获取map中的所有键，并存储在一个Set\<String>类型的变量中。
	* 使用for-each循环遍历keys中的每一个键，并使用map的`get`方法获取相应的值，然后打印出来。

以下是`ArrayList`, `HashSet`和`HashMap`中使用的具体方法的说明：
1. **ArrayList**：
	* `add(E e)`: 将指定的元素添加到此列表的尾部。
	* `get(int index)`: 返回此列表中指定位置上的元素。
2. **HashSet**：
	* `add(E e)`: 将指定的元素添加到此集合中（可选操作）。
	* `iterator()`: 返回一个迭代器，用于遍历此集合中的元素。
	* 注意：`HashSet`利用了`HashMap`来实现其功能。在`HashSet`中，元素是作为`HashMap`的键存储的，而所有的值都是一个静态的`Object`实例。
3. **HashMap**：
	* `put(K key, V value)`: 将指定的值与此映射中的指定键相关联（可选操作）。
	* `get(Object key)`: 返回此映射中映射到指定键的值，如果映射中没有这个键的映射关系，则返回`null`。
	* `keySet()`: 返回此映射中包含的键的`Set`视图。
在上面的代码中，这些方法是用来对集合进行操作的核心方法。例如，在`ArrayList`的示例中，`add`方法用于添加元素到列表中，而`get`方法用于从列表中检索元素。

同样，在`HashSet`的示例中，`add`方法用于将元素添加到集合中，然后使用迭代器（通过`iterator`方法获取）来遍历集合中的元素。

最后，在`HashMap`的示例中，`put`方法用于添加键值对到映射中，`get`方法用于根据键从映射中检索值，而`keySet`方法用于获取映射中所有键的集合，然后可以用这个键集来遍历映射中的所有键值对。

**总结**：这段代码展示了Java集合框架的三种基本结构：List、Set和Map，以及如何使用泛型来确保类型安全。同时，它也展示了如何添加、检索和遍历集合中的元素。

*关于第一句`List <String> list = new ArrayList();`的解释：*
>这里使用了**泛型**和**多态**的概念。
>首先，看这段代码：`List<String> list = new ArrayList();`
>* `List<String>` 是一个接口类型，它表示这是一个字符串列表。
>* `new ArrayList()` 创建了一个新的 `ArrayList` 实例。

>在Java中，接口和实现类之间存在多态关系。这意味着你可以用接口类型来引用一个实现类的对象。`ArrayList` 是 `List` 接口的一个实现类，因此你可以用 `List` 类型的引用来引用一个 `ArrayList` 对象。

>为什么这样做？有几个好处：
>1. **代码复用**：如果你决定以后更改实现（比如从 `ArrayList` 改为 `LinkedList`），你只需要更改创建对象的代码，其他使用 `list` 引用的代码不需要更改。
>2. **编程到接口，而不是实现**：这是一个通用的最佳实践。这样你的代码更灵活，不依赖于特定的实现。
>3. **类型安全**：使用泛型来指定列表中的元素类型为 `String`，这样你就可以确保只添加字符串到列表中，并在检索时得到字符串。这避免了在运行时出现类型转换错误。

>因此，`List<String> list = new ArrayList();` 这行代码创建了一个新的 `ArrayList` 对象，但其引用被视为 `List<String>` 类型，这样你可以享受上面提到的好处。

*关于`iterator`的用法*
>这部分代码是使用迭代器（Iterator）来遍历一个集合（Set）并将其元素打印到控制台。我们一步一步来看：
```java
Iterator<Integer> iterSet = set.iterator();
```
1. `Iterator<Integer> iterSet`: 这声明了一个`Iterator`接口的引用，其元素类型为`Integer`。`Iterator`是一个用于遍历集合元素的接口。
2. `set.iterator()`: `set`是一个`Set<Integer>`类型的对象，它存储了整数类型的元素。`set.iterator()`调用了`Set`接口的`iterator()`方法，该方法返回一个`Iterator<Integer>`类型的对象，用于遍历`set`中的元素。
```java
while(iterSet.hasNext()){
    Integer n = iterSet.next();
    System.out.println("next value:" + n);
}
```
3. `while(iterSet.hasNext())`: 这使用了一个while循环来遍历集合中的所有元素。`hasNext()`是`Iterator`接口中的一个方法，它检查是否还有更多的元素可以迭代。如果有，它返回`true`，否则返回`false`。
4. `Integer n = iterSet.next();`: `next()`是`Iterator`接口中的另一个方法，它返回迭代中的下一个元素，并将迭代器的位置向前移动一个元素。在此例中，我们将返回的元素赋值给一个名为`n`的`Integer`类型的变量。
5. `System.out.println("next value:" + n);`: 这将打印出当前迭代到的元素的值，即`n`的值，并带有前缀"next value:"。
整个代码段创建了一个迭代器来遍历整数集合，并使用while循环逐个访问集合中的每个元素，然后将每个元素打印到控制台。这是一种常用的方法来遍历Java集合框架中的集合，并处理或打印集合中的每个元素。
#### 泛型类
![[微信截图_20240102090010.png]]
### 泛型方法
方法返回类型或参数类型预留
`[修饰符]<T,S> 返回值类型 方法名([形参列表]){}`
**泛型不能做构造器**
**静态方法不能用泛型**
```java
public class Trade{
	public <S, B> void introduce(S producer, B consumer, int n) {
		System.out.println(producer + " and " + consumer + " for " + n +" times");
	}
	public <T> T getFirst(T[] products) {
		if (products.length>0) return products[0];
		else return null;
	}
	public static void main(String[] args) {
		Producer Sam = new Producer("cake");
		Consumer Joy = new Consumer("cake");
		Trade trade = new Trade();
		trade.introduce(Sam, Joy, 10);
		Producer Ben = new Producer("pizza");
		Producer workers[] = {Sam, Ben};
		System.out.println(trade.getFirst(workers));
		Integer[] n = {10, 13, 15};
		System.out.println(trade.getFirst(n));
		String[] s = {"Sam", "Joy", "Ben"};
		System.out.println(trade.getFirst(s));
	}
}
class Producer {
	private String something;
	public Producer(String something){
	this.something = something;
	}
	public String toString() {
		return ("producing: " + something);
	}
}
class Consumer {
	private String something;
	public Consumer(String something) {
		this.something = something;
	}
	public String toString() {
		return ("consuming: " + something);
	}
}
```
#### 方法前面的泛型一定条件可以省略不写
- Trade方法中的类型形参都在类声明中已经预留，所以可以直接当作正常类型使用
- 方法只要没有引入新的类型参数，该方法可以不用泛型
```java
public class Store<S, B>{
	public <S, B> void trade(S producer, B consumer, int n) { //public void trade(S producer, B consumer, int n) {
		System.out.println(producer + " and " + consumer + " for "+ n +" times");
	}
	public static void main(String[] args) {
		Sender Sam = new Sender("email");
		Receiver Joy = new Receiver("email");
		Store<Sender, Receiver> mailbox = new Store();
		mailbox.trade(Sam, Joy, 10);
	}
}
class Sender {
	private String something;
	public Sender(String something) {this.something = something;}
	public String toString() {return ("writing: " + something);}
}
class Receiver {
	private String something;
	public Receiver(String something) {this.something = something;}
	public String toString() { return ("reading: " + something);}
}
```
注意：
![[微信截图_20240102090846.png]]
### 匿名类实现接口泛型
- 这里定义了一个泛型接口`IComputable<M,N>`
- 然后直接利用匿名内部类的写法实现了接口
	- 注意匿名类实现中是用父类或接口名来代替类名，所以`new IComputable<Integer,Integer>() `中的`<Integer,Integer>`不可省略
	- `class Anonymous implements IComputable<Integer,Integer>`中不可省略一样
```java
interface IComputable<M, N>{
	public M add(M m, N n);
}
public class InterfaceDemo {
	public static void main(String args[]) {
		IComputable<Integer,Integer> computer = new IComputable<Integer,Integer>() {  // 匿名内部类
			public Integer add(Integer m, Integer n) {return m+n;
			}
		};
		Integer result = computer.add(100,200);
		System.out.println("Results is: " + result);
	}
}
```
#### 实现接口泛型的两种方法
![[微信截图_20240102090906.png]]


# 类的设计
![[微信截图_20240102081412.png|475]]
**类的设计思路：** 
1. 类间低耦合
	- 每个类应当建模一个单一的实体，类中所有操作逻辑上结合在一起完成类内紧耦合
	- 如果一个实体承担太多责任与功能，可划分为多个类分解责任功能
		- `String`类承担不可更改的字符串功能
		- `StringBuilder`承担可更改的字符串功能
	- 类的使用尽量不受约束，用户可以随时随地使用类
2. 注意方法覆盖
	- 每个类不要忘了保证这个类有空参数的构造器
	- 覆盖`Object`类继承来的方法
		- `equals()`与`toString`方法重写
	- 遵循Java编程规范
	- 在类的使用者与功能扩展者中间折中选择访问修饰符
		- 使用者：`private`
		- 扩展者：`protected`
3. 隐藏
	- 注意`static`关键字
		- 执行效率高
		- 使用时需确认其不依赖于对象属性
	- 使用`private`隐藏数据
	- 将问题分解为越具体越容易实现的问题
		- **工厂设计范式**
		- 抽象类与接口
		- ...
		- ...
4. 注意区分*属性*与*子类*
	- 子类最好比父类有增加量，不然当作属性可能会比较好

*思考：书店的设计*
直接用一个`type`字符串记录的话无法判断某个小子类属于的类别，所以需要改进
`child`作为集合，内部的元素也是`Category`类，类似递归树的结构
```java
import java.util.Set
import java.util.HashSet

public class Category{
	private String name;
	private Category parent;
	private Set<Category> childs = new HashSet<>();

	public Category(String name){this.name = name;}
	public String getName(){return name;}
	public void setName(String name){this.name = name;}
	public Category getParent(){return parent;}
	public void setParent(Category c)d{parent = c;}
	public Set<Category> getChilds(){return childs;}
	public addChild(Category c){
		child.add(c);
		c.setParent(this);
	}
}

public class Book {
	private String bookName;
	private Category category;
	public Book(String name) {bookName = name;}
	public String getName() {return bookName;}
	public void setCategory(Category c) {category = c;}
	public Category getCategory() {return category;}
}

public class BookTest {
	private static Category head = new Category("General");
	private static Category science = new Category("Science");
	private static Category history = new Category("History");
	private static Category computer = new Category("Computer");
	private static Category geometry = new Category("Geometry");
	private static Category program = new Category("Program");
	private static Category operation = new Category("Operation");
	public void create() {
		head.addChild(history); 
		head.addChild(science);
		science.addChild(geometry); 
		science.addChild(computer);
		computer.addChild(operation); 
		computer.addChild(program);
	}
	public static void main(String args[]) {
		BookTest bookstore = new BookTest();
		bookstore.create();
		Book math = new Book("Culculus Basis");
		math.setCategory(science);
		System.out.println(math.getCategory().getName());
		Book java = new Book("Thinking in Java");
		java.setCategory(program);
		System.out.println(java.getCategory().getName());
		Category parent = java.getCategory().getParent();
		System.out.print("Belong to:" + parent.getName());
	}
}
```
### 继承与组合比较
*之前的课程中，对这两个关系进行了初步比较，本次进行加深*
![[类的设计与方法重写#继承与组合比较二：]]
#### 总结
![[微信截图_20240102082107.png]]

### 例子：扩展Set
![[微信截图_20240102082244.png|500]]
### 用继承来扩展
![[微信截图_20240102082411.png]]
```java
public interface IntSet{
	public boolean add(int a);
	public boolean remove(int a);
}

import java.util.TreeSet;
public class IntTreeSet extends
TreeSet implements IntSet{
	public boolean add(int a){
		return add(new Integer(a));
	}
	public boolean remove(int a){
		return remove(new Integer(a));
	}
}

import java.util.HashSet;
public class IntHashSet extends
HashSet implements IntSet{
	public boolean add(int a){
		return add(new Integer(a));
	}
	public boolean remove(int a){
		return remove(new Integer(a));
	}
}
```
### 用组合来扩展
![[微信截图_20240102082655.png]]
```java
import java.util.Set;
public class IntSet{  // 这里没有实现接口，而是创建了一个接口类
	private Set<Integer> set;
	public IntSet(Set<Integer> set){this.set = set; }
	public boolean add(int a){return set.add(new Integer(a));}
	public boolean remove(int a){return set.remove(new Integer(a));}
}

IntSet set = new IntSet(new HashSet());
Set.add(1);
IntSet set = new IntSet(new TreeSet());
Set.add(1);
```
### 适配器范式
- 使得不兼容而不能工作的那些物体一起工作
- 将一个类的接口转换成客户端所希望的另一个接口

**适配器模式（Adapter Pattern）** 是一种设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口，从而使得原本由于接口不兼容而无法一起工作的类能够一起工作。

适配器模式的实现主要有两种方式，分别是**类适配器模式**和**对象适配器模式**。这两种方式的主要区别在于实现方式的不同。
#### 类适配器模式
类适配器模式主要是通过**继承**来实现适配功能。在这个模式中，适配器类继承源类（需要被适配的类），并且实现目标接口（客户端期望的接口）。由于适配器类继承了源类，因此可以在适配器类中访问源类的所有方法和属性，这使得适配器类*可以将源类的功能转换成目标接口所期望的功能*。

假设我们有一个源类 `Source` 和目标接口 `Target`，我们希望将 `Source` 类的接口适配成 `Target` 接口
```java
public class Source { 
	public void specificRequest() { 
		// 源类特有的方法实现 
	} 
} 
public interface Target { 
	public void request(); 
} 
public class Adapter extends Source implements Target { 
	@Override 
	public void request() { 
		// 调用源类的方法实现目标接口的方法 
		specificRequest(); 
	} 
}
```
#### 对象适配器模式
与类适配器模式不同，对象适配器模式主要通过**组合**来实现适配功能。在这个模式中，适配器类包含源类的实例，并且实现目标接口。适配器类通过调用源类的实例的方法来实现目标接口所期望的功能。与类适配器模式相比，对象适配器模式*更加灵活*，因为它不需要继承源类，而是通过组合来实现适配功能。

同一个例子：
```java
public class Source {  
    public void specificRequest() {  
        // 源类特有的方法实现  
    }  
}  
  
public interface Target {  
    public void request();  
}  
  
public class Adapter implements Target {  
    private Source source;  
      
    public Adapter(Source source) {  
        this.source = source;  
    }  
      
    @Override  
    public void request() {  
        // 调用源类的方法实现目标接口的方法  
        source.specificRequest();  
    }  
}
```

![[微信截图_20240102104716.png]]