## 类间关系
### 依赖关系: use a
- 对于两个**相对独立**的系统
	- 当一个系统*负责构造另一个系统B的实例*，或系统B*依赖系统A的服务*
- 这两个系统就表示为依赖关系
	- eg. 充电器和充电电池
- 在UML语言中**虚线箭头**表示依赖关系
![[微信截图_20231016220059.png]]
#### 例：Bicycle类与Pump类的依赖关系
- 在`Bicycle`类中无需定义`Pump`类型的变量。
- 在现实生活中，通常不会为某一辆自行车配备专门的打气筒，而是在需要充气的时候，从附近某个修车棚里借个打气筒打气。
- 程序代码中，表现为Bicycle类的`expand()`方法有个Pump类型的参数
```java
public class Bicycle{
/*给轮胎充气*/
	public void expand(Pump pump){
		pump.blow()；
	}
}
...
myBicycle.expand(pumpFromRepairShed1); // 到第一个修车棚充气
myBicycle.expand(pumpFromRepairShed1); // 到第二个修车棚充气
```
### 关联关系
关联：*一一对应*(这点与依赖不同，依赖不一定一一对应)
	eg. 客户和订单，每个订单对于特定的用户，每个客户对于特定的订单

UML语言中用**实线箭头**表示关联关系
*Person类与Bicycle类的关联关系：*
![[微信截图_20231016220537.png]]

#### 与依赖关系的区别
- 关联关系：聚合类中成员**包含关联的对象**
```java
public class Person{
	private Bicycle bicycle;
	public Bicycle getBicycle(){return bicycle;}

	public void setBicycle(Bicycle bicycle){
		this.bicycle = bicycle;
	}
	public void goToWork(){bicycle.run();}
}
```
- 依赖关系：**方法中有参数**，这个就是要依赖的对象
```java
public void goToWork(Bicycle bicycle){
	bicycle.run();
}
```
**局部变量放置在栈区，对象放置在堆区**

#### 例：狗和主人
```java
class Owner{
	private Dog dog;
	public Dog getDog(){return dog;}
	public void setDog(Dog dog){
		this.dog = dog;
	}
}

class Dog{
	private Owner owner;
	public Owner getOwner(){return owner;}
	public void setOwner(Owner owner){
		if (this.owner != null) this.owner.setDog(null);
		this.owner = owner;
		owner.setDog(this);
	}

	public static void main(String args[]){
		Owner owner1 = new Owner();
		Owner owner2 = new Owner();
		Dog dog = new Dog();
		dog.setOwner(owner1);
		dog.setOwner(owner2);
	}
}
```
### 组合/聚合关系 has a
- 当系统A被加入到系统B中，称为系统B的组成部分时，系统B和系统A之间为组合关系
- 根据语义来区分关联关系和组合关系
![[微信截图_20231017095044.png]]
UML中用空心菱形表示聚合关系
![[微信截图_20231016221310.png]]
*组合和关联统称为关联，* UML语言直接用实线表示
![[微信截图_20231017095141.png]]

例子：
![[微信截图_20231017104202.png]]
```java
public class Employee {
	private String name, dept;
	private int salary, subcount;
	private Employee[] subordinates;
	public Employee(String name, String dept, int sal) {
	this.name = name;
	this.dept = dept;
	this.salary = sal;
	subordinates = new Employee[10];
	}

	public void add(Employee e) {
		if(subcount < subordinates.length) {
			subordinates[subcount] = e;
			subcount ++;
		}
	}
	
	public void remove(Employee e) {
		if(subcount > 0)
		subcount --;
	}
	
	public Employee[] getSubordinates() {
		return subordinates;
	}
	
	public String toString() { // 将输出结果以字符串输出
		return ("Employee: [Name: " +name + "dept : "+dept + ", salary: " + salary + "]");
	}
}

public class CompositePatternDemo {
	public static void main(String[] args) {
		Employee CEO = new Employee("John", "CEO", 30000);
		Employee headSales = new Employee("Robert", "Head Sales", 20000);
		Employee headMarketing = new Employee("Michel", "Head Marketing", 20000);
		Employee clerk1 = new Employee("Laura", "Marketing", 10000);
		Employee clerk2 = new Employee("Boc", "Marketing", 10000);
		Employee salesExecutive1 = new Employee("Richard", "Sales", 10000);
		Employee salesExecutive2 = new Employee("Rob", "Sales", 10000);
		
		CEO.add(headSales);
		CEO.add(headMarketing);
		headMarketing.add(clerk2);
		headMarketing.add(clerk1);
		headSales.add(salesExecutive1);
		headSales.add(salesExecutive2);
		
		for(Employee headEmployee : CEO.getSubordinates()) {
			/* 相当于
			* Employee staff[] = CEO.getSubordinates();
			* for(int i = 0; i < staff.length; i++){
			*
			*/
			
			System.out.println(headEmployee);
			for(Employee employee : headEmployee.getSubordinates()) {
				System.out.println(employee);
			}
		}
	}
}
```
**注：** 在Java中，`toString()` 方法是 `Object` 类的一个方法，用于返回对象的字符串表示形式。在上面的代码示例中，`toString()` 方法被重写以在输出时显示 `Employee` 对象的有关信息。

假设 `Employee` 类已经重写了 `toString()` 方法，那么这个方法可能会返回包含员工姓名、职位和薪水的字符串。这样，当你调用 `System.out.println(employee)` 时，实际上是在调用 `System.out.println(employee.toString())`，从而打印出员工的详细信息。

#### 关联关系的多重性
![[微信截图_20231017095351.png]]
**期末考点：通过UML语言写出对应代码**

### 继承关系 is a
Java中的 `extends`关键词声明了继承关系，相当于UML中的“泛化”
- 子类只能直接继承一个父类
- 子类可以扮演父类，但是父类不能扮演子类
- UML图形中用实线空心封闭箭头表示子类向超类继承

#### 两种写法比较
![[微信截图_20231017100947.png]]
##### 继承关系描述
```java
public class Person{ 
	String Name; 
	int Age; 
	public Person(String name){…} 
} 
class Employee extends Person{ 
	private double Salary; 
	private String department; 
	public Employee(String name){…} 
} 
class Customer extends Person{ 
	private String OrderID; 
	private String Address; 
	public Customer(String name){…} 
}

Employee employee = new Employee("Tom");
Customer customer = new Customer("Tom");
```
- `Employee`类和`Customer`类都继承了`Person`类的两个属性；
- 如果Tom改名了，那么上面两个引用变量`employee`和`customer`所指的对象都要修改内容，可能带来数据副本间数据不一致的风险。
##### 改用组合关系实现
```java
public class Person{ 
	private String Name; 
	private int Age;
}
class Employee{ 
	private double Salary;
	private String department; 
	private Person person; 
} 
class Customer{ 
	private String OrderID; 
	private String Address; 
	private Person person;
}

Person Tom = new Person("Tom"); 
Employee employee = new Employee(Tom); 
Customer customer = new Customer(Tom);
```

第二种写法的优点：
1. `Employee` 和 `Customer` 类更加独立，不依赖于 `Person` 类的实现。
2. 更灵活地处理和使用 `Person` 对象。
第二种写法的缺点：
1. 需要*更多的代码*来实现相同的功能。
2. 需要手动管理 `Person` 对象与 `Employee` 或 `Customer` 对象之间的关联。
![[微信截图_20231106140528.png]]

#### 继承与组合比较二：
![[微信截图_20231106140828.png]]
![[微信截图_20231106140836.png]]
![[微信截图_20231106140846.png]]
原本使用继承关系，则需要改变`method2`的修饰符，但使用组合关系，则不会改变各方法的范围，保证了封装性

### 实现关系： realization
Java编程语言中接口(Interface)的概念也能够与UML概念匹配。UML中的接口是一种实现继承的形式，但这种继承形式与Java中通过关键字extends实现的方法不同

UML语言用*虚线和空心三角形*表示实现接口
![[微信截图_20231017095757.png]]
### 类间关系总结
![[微信截图_20231017102636.png]]
![[微信截图_20231017102726.png]]
### 继承树
![[微信截图_20231017103754.png]]
### 方法重写
- *新类继承父类*时（且只存在父子类之间），除了能添加成员外，还能改写父类中继承的行为，这就是方法重写或方法覆盖
- 如果子类中的方法名字、返回类型、参数与父类中方法都完全相同，那么新的方法改写（Overriding）了旧的方法。
- `super`用来代表父类，可以指定父类中的属性和方法
- 父类的**静态方法**只能被子类的静态方法重写，不能用子类的非静态方法覆盖
	- 子类隐藏父类的静态方法；与所属的类别绑定
	- 子类覆盖父类的实例方法；与所属的实例绑定
- 父类的**非静态方法**不能被子类重写为静态方法
- 父类的**私有方法**无法被重写
- *变量是静态绑定，由变量所声明的类型绑定*
- *实例方法是动态绑定*
![[微信截图_20231022210056.png]]

例子：
![[微信截图_20231017105259.png]]
#### super关键字
- 在子类中用`super`访问父类的成员
```java
class Base{
	String var = "Base's variable";
	void method(){
		System.out.println("call Base's method");
	}
}
public class Sub extends Base{
	String var = "Sub's variable";
	// 方法重写 
	void method(){
		System.out.println("call Sub's method");
	}
	void test(){
		String var = "Local variable"; // 局部变量
		System.out.println("var is " + var);
		// var is Local variable
		System.out.println("this var is " + this.var);
		// 打印成员变量
		// this var is Sub's variable
		System.out.println("super var is " + super.var);
		// super var is Base's variable

		method(); // 调用Sub实例的method()方法
		this.method(); // 调用Sub实例的method()方法
		super.method();  // 调用在Base类中method()方法
	}
	public static void main(String args[]){
		new Sub.test(); // 这里可以直接new一个对象不用命名哎
	}
}
```
**条件：**
1. 子类继承父类方法
2. 子类和父类都定义了该方法
3. 方法*名字*、*返回类型*、*参数(类型、个数、顺序）* 和父类中方法都完全相同
4. 访问权限可以不同，*子类访问权限不能小于父类方法的访问权限*，不然会导致编译正常但是运行错误

#### 例1
```java
public calss Parent{
	public void doSomething(){} // 父类方法为public
}
public calss Child extends Parent{
	private void doSomething(){} // 子类方法为private
}
public class doBoth{
	public void doOther(){
		Parent p2 = new Child();
		p2.doSomethind(); // 编译出错
	}
}
```

### 多态(Polymorphism)
Java语言中，行为决定于变量的运行类型，而不决定于变量声明的类型，称为*多态*

- Java语言与其他面向对象语言一样，允许将*子类对象的引用赋给父类变量*
- 一个对象只有一种形式，但一个变量却可以有多个形式
	`Employee employee = new Manager()`
	生成一个`Manager`对象，并且将该对象的引用传给一个`Employee`变量
**注意：** `Employee`类的变量虽然*引用的是`Manager`类*的对象，但`employee`变量*只能访问`Manager`对象中原本的`Employee`部分*，而`Manager`类追加的部分将**被隐藏**
	`employee.department = "Sales"`
	这段将报错，因为department属于Manager追加部分

#### 多态格式
1. **父类名称 变量名 = new 子类名称 ()**
2. 将*子类对象的引用*赋给父类变量
3. 引用类型变量可以引用(指向)的实例不一定时是声明的类型，还可能是声明类型的子对象（实例）
*注意：*
	子类转化为父类后，子类自己特有的变量和方法就不能访问了，需要进行**类型强制转化**后才能重新访问原本特有的变量与方法

**类型转换：**
- 向上转换自动完成
- 向下转换：强制类型转换
![[微信截图_20231018000045.png]]

举例：
```java
// 基本类型
int a = 0;
byte b = 0;
a = b; // 合法，byte 向上转化，自动完成
b = a; // 非法，int 类要向下转化
b = (byte)a; // 合法，通过强制类型转化让int类向下转

// 引用类型
Cat = cat;
Animal animal;
Dog dog;
Object object;

cat = animal; // animal需要向下转化，所以非法
cat = (Cat)animal; // 通过强制类型转化让animal向下转化
cat = (Cat)dog; // 不同子类，非法
cat = (Cat)object; // 非法，不能跨父类转化
```

#### 多态导致错误
##### 运行错误
```java
class Creature{}
class Animal extends Creature{}
class Dog extends Animal{}
class Cat extends Animal{}

Animal animal = new Dog();
Cat cat = (Cat)animal; //编译成功(因为有继承关系，但会运行错误)，运行时抛出ClassCastException
```
此处由于Dog 和 Cat是不同的子类，不能通过类型转化，所以会运行报错
##### 编译错误
```java
class Creature{}
class Plant extends Creature{}
class Animal extends Creature{}
class Dog extends Animal{}
class Cat extends Animal{}

Creature creature = new Dog();
Dog dog = creature; //编译错误，向下转换需要强制类型转换
Plant plant = new Cat(); //编译错误，没有继承关系，不是多态
```
### 动态绑定与静态绑定
#### 静态绑定
编译阶段绑定*引用变量所声明的类型*对应的方法
- 编译时进行的绑定，引用类型的变量实际引用的对象类型还没有确定
	编译器只是根据代码的语法和类型信息来静态地分析代码，并确定引用的对象类型。然而，由于实际的对象是在运行时创建的，所以编译器无法准确预知引用变量所引用的对象的具体类型。
- 根据**引用变量所声明的类型**来绑定
- 绑定对象：*实例变量，静态变量，静态方法*
**注：** 静态方法的调用与对象实例无关，只与类名相关。

例子：
```java
class Animal { 
	public void move() { 
		System.out.println("Animal is moving");
	} 
}
class Dog extends Animal {
	@Override 
	public void move() { 
	System.out.println("Dog is running"); 
	} 
} 
public class Main { 
	public static void main(String[] args) { 
		Animal myAnimal = new Animal(); 
		myAnimal.move(); 
		// 这里是静态绑定，编译器在编译时就能确定调用的是Animal类的move()方法 
	} 
}
```
#### 动态绑定
实例方法由JVM运行时根据*引用变量所实际指向的对象*绑定
- 程序运行时进行的绑定
- 根据引用变量所引用的实例来绑定
- 绑定对象：*实例方法*
```java
class Animal { 
	public void makeSound() { 
	System.out.println("The animal makes a sound"); 
	} 
} 
class Cat extends Animal {
	@Override 
	public void makeSound() { 
	System.out.println("Meow"); 
	} 
} 
public class Main {
	public static void main(String[] args) { 
	Animal myAnimal = new Cat(); 
	myAnimal.makeSound(); 
	// 这里是动态绑定，运行时根据实际对象类型（Cat）来执行相应的makeSound()方法 
	} 
}
```
在上面的例子中，`myAnimal.makeSound()`是动态绑定，因为运行时根据实际对象类型（Cat）来执行相应的makeSound()方法。

#### 例子1
```java
class Base{
	String var="BaseVar";
	static String staticVar="StaticBaseVar";
	void method(){
		System.out.println("Base method");
	}
	
	static void staticMethod(){
		System.out.println("Static method");
	}
}
public class Sub extends Base{
	String var="SubVar";
	static String staticVar="StaticSubVar";
	void method(){
		System.out.println("Sub method");
	}
	static void staticMethod(){
		System.out.println("Static Sub method");
	}
	String subVar="Var only belonging to Sub";
	void subMethod(){
		System.out.println("Method only in Sub");
	}
	public static void main(String args[]){
		Base who = new Sub();
		System.out.println("who.var=" + who.var);
		System.out.println("who.staticVar="+who.staticVar);
		who.method();
		who.staticMethod();
	}
}
```
![[微信截图_20231018221503.png]]

这个例子展示了Java中的**多态性和静态绑定**的特性。在这个例子中，有一个基类`Base`和一个子类`Sub`，`Sub`继承了`Base`。在`main`方法中，创建了一个`Sub`对象，并将其引用赋给了`Base`类型的变量`who`。

现在，让我们具体分析这个例子中的各个部分：
1. `who.var`：对于**非静态变量**，它的值**取决于引用变量的声明类型**，而不是实际对象的类型。在这个例子中，`who`是一个`Base`类型的变量，因此它引用的是`Base`类中的`var`变量，输出结果为`BaseVar`。
2. `who.staticVar`：这里访问的是`staticVar`静态变量。静态变量是类级别的，**不属于任何特定的实例**。因此，这里将调用`Base`类中的`staticVar`变量，输出结果为`StaticBaseVar`。
3. `who.method()`：这里调用的是`method`实例方法，实例方法**动态绑定**。由于`who`引用的是`Sub`对象，因此实际调用的将是`Sub`类中的`method`方法，输出结果为`Sub method`。
4. `who.staticMethod()`：这里调用的是`staticMethod`静态方法。静态方法的调用与对象的实际类型无关，只与**引用变量的声明类型**有关。因此，这里将调用`Base`类中的`staticMethod`方法，输出结果为`Static method`。

综上所述，可以看出，对于*实例方法*(`who.method()`)，它的绑定是动态的，与**实际对象的类型**有关；而对于*实例变量*(`who.var`)、*静态变量*(`who.staticVar`)和*静态方法*(`who.staticMethod()`)，它们的绑定是静态的，与**引用变量的声明类型**有关。

##### Question: 如何调用Sub类的staticMethod方法？
`Sub who2 = new Sub(); who2.staticMethod();`
引用变量的声明类型为`Sub`，于是调用`Sub`类中的方法

**类似：**
![[微信截图_20231022213553.png]]

#### 例2
```java
class Base {
	public String showMe() {
		return "Base";
	}
	
	public void print(){
		System.out.println(showMe());
	}
}

public class Sub extends Base {
	public String showMe(){
		return "Sub";
	}
	
	public static void main(String args[]){
		Sub sub = new Sub();
		sub.print(); // 打印Base
	}
}
```
两个`showMe`方法实际上构成了重写关系。
至于在`Sub`类的`main`方法中调用`print`方法会打印"Base"，是因为`print`方法是在`Base`类中定义的，它调用了`Base`类的`showMe`方法，而非`Sub`类的`showMe`方法。这是因为**方法调用是静态绑定**的，而`print`方法是在编译时期确定的，所以绑定到了`Base`类的`showMe`方法。

补充：
![[微信截图_20240101172553.png]]