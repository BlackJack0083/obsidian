**看待问题的方式：**
	1. 里面有什么东西？
	2. 每个东西看上去是什么样的？
	3. 每个东西能做点什么用？
	4. 这些东西待在什么地方？
	5. 这些东西之间有什么关系？
	6. 这些东西是怎么完成任务的？
**事物关系：**
1. 整体-部分的关系(聚集关系)
2. 笼统-具体关系(继承关系)
3. 伙伴关系(关联关系)
## 类
- 把具有*相同数据和相同操作*的一组相似对象归为一"类"
- 在面向对象的软件技术中，把具有相同数据和相同操作的一组相似对象也归为一类
- 实例就是由*某个特定的类*所描述的*具体的对象*(instance = object)

### 类是一类事物的抽象
- 先注意问题的本质与描述，其次是实现过程或细节
- 数据抽象：描述某类对象的属性或状态
- 代码抽象：描述某类对象的共有的行为特征或具有的功能
- 抽象的实现：通过类的声明
### 类是一种封装(encapsulation)
将抽象出的数据成员、代码成员(实现操作的代码)相结合，将它们视为一个整体，放在对象内部
目的是*增强安全性和简化编程*，使用者不必了解具体的实现细节，只需要通过外部接口，以特定的访问权限，来使用类的成员

条件：
	1. 有清晰的边界
	2. 有确定的接口
	3. 受保护的内部实现
![[微信截图_20231015214832.png|500]]

### Java类的定义
类是组成Java程序的基本要素。它封装了一类对象的状态和方法，是这一类对象的原型
![[微信截图_20231015214924.png]]
#### 类的修饰符
访问控制修饰符：`public`,  `default`
抽象类修饰符：`abstract`
最终类修饰：`final`(不能继承)
#### 类名称
- 以字母、字符“-” 或“$”开头
- 只能含有大于十六进制00C0以上的Unicode字符
- 不能使用与Java关键字相同的类名
- 类名通常以大写字母开头，如果类名由多个单词组成，则每一个单词的开头字母也大写
#### 完整类名
![[微信截图_20231015215136.png]]
### 类体
类体中定义了该类所有的变量（属性）和该类所支持的方法，通常变量在方法前定义（不一定要求）
![[微信截图_20231016092604.png]]

#### 域的声明
域，即类的属性或变量
![[微信截图_20231016092742.png]]
#### 变量的作用域
- 作用域首先指的是**变量的存在范围**，只有在这个代码块内的程序能访问到它
- 作用域决定了变量的**生命周期**，即变量什么时候创建并分配空间开始，到变量销毁并清除内存的过程
- 当**变量被定义**时，它的作用域就被确定了，按作用域划分
	- 成员（全局）变量，可以方法在前，声明在后
	- *局部变量*
		- 方法或构造器参数，能且只能在*整个方法或整个构造器*内使用
		- 方法或构造器*内部声明的变量*，能且只能在整个方法或整个构造器内使用
		- 方法或构造器代码块中声明的变量，只能在代码块内部使用，如`for`循环中定义的控制变量
		- 必须**先声明再使用**
	- *变量可以重名，但作用域必须不同*。如成员变量和方法参数同名，不同方法中的参数同名
#### 变量的生命周期
- 方法的**参数**和**局部变量**只有*当方法被调用时才存在*
- 实例变量的生命周期依附于实例变量
- **静态变量**的生命周期依附于**类的生命周期**
#### 变量的类型与缓存区
```java
public class Sample{
	static int v1; // 静态变量
	int v2; // 实例变量

	public void test(int v3){
		int v4 = v3 + 1;
		v1 = v4;
	}
	public static void main(String args[]){
		int v5 = 2;
		Sample s1 = new Sample();
		s1.test(v5); // 调用完test方法后，v3,v4即被释放
		Syatem.out.println(v1 + "," s1.v2); // print后main方法结束，args,s1,v5被释放
	} // 触发垃圾回收机制，v2无访问，被释放
} // JVM卸载Sample类，静态变量v1随之释放
```
![[微信截图_20231016202129.png]]

####  域修饰符
![[微信截图_20231016201532.png|500]]
#### 方法声明
![[微信图片_20231016202646.png|525]]
Java允许相同方法名但参数列表不同的方法存在
##### 声明命名
同名方法要求返回类型一样，但参数类型可以不同
![[微信图片_20231016202646.png]]
##### 方法修饰符
![[微信截图_20231016203739.png|500]]
##### 方法的体
![[微信截图_20231016203925.png|500]]

### 面向对象的封装
![[微信截图_20231016204138.png|500]]
### 面向对象的思维
#### 对象创建
使用`new`方法
![[微信截图_20231016204933.png|500]]
#### UML图
![[微信截图_20231016210407.png|500]]
+表示public，-表示private，上部分放属性，下部分放方法

![[微信截图_20231016210503.png|500]]
`5...60`表示5-60学生选课，且`*`代表至少有1位
`0..3`表示有0-3门课会由1位老师教授
### Random类
- 随机数生成：
	- `Math.random():[0.0 - 1.0)`
	- `java.util.Random`
*随机数实际上是伪随机，给定特定的种子，生成的随机数就是一样的*
```java
import java.util.Random;
public class CreateRandom {
	public static void main(String[] args) {
		int a[] = new int[10];
		
		Random random1 = new Random(3);
		for (int i = 0; i < a.length; i++) {
			a[i] = random1.nextInt(1000); // 生成1000以内的随机数
		}
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + " ");
		}
		System.out.println("");
		
		Random random2 = new Random(3);
		for (int i = 0; i < a.length; i++) {
			a[i] = random2.nextInt(1000);
		}
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + " ");
		}
	}
}
```
### 对象数组
- 对象数组实质上是**引用变量的数组**
- 对象数组至少有两重引用
![[微信截图_20231016211119.png|500]]
```java
Circle[] circleArray = new Circle[10];
circleArray[0] = new Circle();
circleArray[0] = new Circle();
```
- `circleArray`引用整个数组对象，其中存储*10个引用地址*
- 这10个地址`circleArray[0]... circleArray[9]`：初始化为`null`
- `circleArray[0].getArea()`，将会调用一个`Circle`对象的方法
### 创建不被修改的变量
- 有些对象一旦创建就不想修改其属性
### 子类
`class Sub extends Base`
Java语言允许使用`extends`继承一个父类，**不支持继承多个父类**

在UML中**用实线和空心三角形**表示继承关系
![[微信截图_20231016211725.png|500]]
```java
public class Employee{
	public String name = "";
	public double salary;
	public Date birthday;

	public String getDetail(){}
}
public class Manager extends Employee{
	public String department;
}
public class Director estends Manager{
	public double carAllowance = 1000.0;
	...
	public void increaseAllowance(){...}
}
```

### 使用继承
- 子类与父类关系：is a relationship
- 定义方法: `extends`
- **构造器不会继承**
	- 子类构造器中虽然没有继承父类的构造器，但**可以使用**父类中*非private的构造器*，具体语法是构造器第一行使用`super()` 语句
	- 构造器中**首行**中的`super()`*调用父类的构造器*，调用时可以**指定参数**，如果父类中没有参数相同的构造器，则编译错误
	- 如果子类构造器中首行**没有调用**父类的构造器，系统**隐含插入没有参数的`super()`语句**，如果父类中没有空参数的构造器，则编译错误
	- `this()`调同类构造器，`super()` 调父类构造器

>在Java中，子类继承父类的属性和方法。当创建一个子类对象时，该对象包含父类和子类的所有属性和方法。构造函数用于初始化对象的状态。
>如果子类没有显式地调用父类的构造函数，Java编译器会默认尝试**调用父类的无参构造函数**。如果父类**没有无参构造函数**，并且子类的构造函数**没有显式地调用**父类的有参构造函数，那么**编译器会报错**，因为父类的状态没有被正确地初始化。
>通过显式地调用父类的构造函数，你可以确保父类的状态被正确地初始化，从而确保子类对象的正确性和完整性。

错误例子，由于子类构造器会隐式调用父类构造器，而父类没有空构造器，所以会编译错误：
![[微信截图_20231020000441.png|500]]
```java
// 改正后
public class Constructor entends ConstructorBase{
	public static void main(String[] args){
		ConstructorTest ct = new ConstructorTest(2);
	}
	public ConstructorTest(int x){
		// super(); 隐式调用了父类的空构造器
		this.x = x;
		// super(x); 不用this的写法
		System.out.println(this.x);
	}
}

class ConstructorBase{
	int x;
	public ConstructorBase(int x){this.x = x;}
	public COnstructorBase(){} // 创建一个空构造器便于子类调用
}
```
- 方法和变量可以继承，但要看权限，**父类私有成员不继承**
![[微信截图_20231016214004.png|500]]
#### 例子
```java
package test1;

public class InheritanceTest {
	public static void main(String[] args) {
		new SubA(1);
		SubA sa = new SubA();
		sa.print();
		new SubB();
	}
}

class SuperA{
	private int j = 10;
	public SuperA(int i) {
		System.out.println("constructor SuperA(int)");
	}
	public SuperA() {
		System.out.println("constructor SuperA()");
	}
	void print() {
		System.out.println("print() in SuperA");
	}
}

class SubA extends SuperA{
	private int k = 2;
	public SubA(int i) {
		super(i);
		System.out.println("constructor SubA(int)");
	}

	public SubA() {
	// 系统会自动插入super();
		System.out.println("constructor SubA()");
	}

	void print() {
		super.print(); // 方法重写后，可以通过这种方式访问父类的方法
		System.out.println("print() in SubA");
	}
}

class SubB extends SuperB{
	public SubB() {
		super("Hello");
		System.out.println("constructor subB()");
	}
}

class SuperB{
	public SuperB(String s) {
		System.out.println("constructor superB(string):" + s);
	}
}
```
![[微信图片_20231231213944.png]]
### 访问修饰符的控制范围
![[微信截图_20231016211418.png|475]]

**注意：**![[微信截图_20231016213654.png|474]]

