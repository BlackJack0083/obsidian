# 线程(Thread)的概念
## 并发与并行
- **并行(parallel)：** 多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的*多任务同时发生*
- **并发(concurrent)：** 只有一台电脑，通过cpu调度算法，让用户看上去多个任务同时执行，实际上从cpu操作层面还是一个个进行
	- 并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈
![[微信截图_20231204134448.png|375]]
#### 程序、进程与线程的基本介绍
- 程序：**静态的**，存在硬盘上的可执行指令序列
- 进程：**动态的**，运行在内存中的程序的执行实例
	- 程序的执行过程，进程是一次程序的执行，进程执行任务需要依赖线程，进程的最小执行单位是线程
- 线程：更加“节俭”的多任务操作方式
	- **线程之间共享信息**
	- 线程调度或切换要快得多，进程有自己的内存空间数据段，代码段和堆栈段
![[微信截图_20231210222015.png|141]]
- *线程存在于进程，进程基于线程*
#### 进程：单独运行的程序
- 有些程序支持多进程，可以同时多次运行程序，打开多个窗口，互相之间互不影响，如Word
- 有些程序不支持多进程，电脑上同时只能打开一次，如微信
#### 进程与线程
![[微信截图_20231210222202.png|500]]
#### 多线程的基本概念
- 并发现象在现实生活中大量存在
- 许多程序运行时需要“同时”完成多个任务
- Java语言提供了多线程机制，以便支持多任务程序的运行
- 多线程——在一个程序中实现并发
	- 编程语言一般提供了串行程序设计的方法
	- 计算机的并发能力由操作系统提供
	- Java在语言级提供多线程并发的概念

### 计算机怎么工作
![[微信截图_20231210222316.png|500]]
# 多线程的实现
![[微信截图_20231204143945.png|500]]
### Java线程的两种实现方法
- 继承类`Thread`
- 实现接口`Runnable`
![[微信截图_20231210222353.png|500]]
#### 继承方式创建线程
![[微信截图_20231210222818.png|500]]
举例：
```java
public class Machine extends Thread{
	public void run() {  // 重写线程的`run`方法
		for(int i = 0; i < 50; i++)
			System.out.println(i);
	}
	public static void main(String[] args) {
		Machine machine = new Machine();
		machine.start();
	}
}
```
*Q: `Thread`是什么?*
在Java中，`Thread`类代表线程，它是并发编程的基础。并发意味着多个任务可以似乎同时发生。为了实现并发，Java提供了线程这种轻量级的执行单位。每个线程都有其自己的执行路径，可以独立于其他线程运行。这允许程序同时执行多个任务。
*Q：`start`方法是什么?*
`start`方法是`Thread`类中的一个方法，用于启动新线程。当你调用一个线程的`start`方法时，它会安排该线程的`run`方法在未来的某个时间执行。重要的是要调用`start`方法而不是直接调用`run`方法，因为直接调用`run`方法只会在当前线程的上下文中执行该方法，而不会启动新线程。
#### 通过实现接口创建线程
```java
public class TestThread {
	public static void main(String args[]) {
		HelloRunner r = new HelloRunner();
		Thread t = new Thread(r);
		t.start(); // 结果与上面的一样
		/*Thread t1 = new Thread(r);
		Thread t2 = new Thread(r);
		t1.start();
		t2.start();
		*/
	}
}
class HelloRunner implements Runnable{
	int i;
	public void run() {
		i = 0;
		while(true) {
			System.out.println("Hello " + i++);
			if(i == 50) break;
		}
	}
}
```
*Q：如果设置两个进程(即注释内容)，会发生什么？*![[微信截图_20231127140849.png|450]]发现输出字符无序
>老师的解释：在执行`t1.start()`的时候，会执行`run()`程序，`i`先被赋值为0，然后开始循环，但是循环还没有结束，插入了`t2.start()`程序，又开始了`run()`，那么又会触发`i=0`的赋值，又开始循环。循环后由于数据之间共享，即共享`i`，故后面不会出现`i`值相等情况，但是会因为线程相互插入，使得输出乱序

代码等价于：
```java
public class TestThread extends Thread{
	int i;
	 public void run() {
		 i = 0;
		  while(true) {
			  System.out.println("Hello" + i++);
			  if(i == 50) break;
		  }
	 }
	 public static void main(String args[]) {
		 TestThread t1 = new TestThread();
		 TestThread t2 = new TestThread();
		 t1.start();
		 t2.start();
	 }
}
```

展示下线程的运行与转换，再用`try`语句设置`Thread`休眠：
```java
System.out.println(Thread.currentThread() + ": Hello " + i++);
try{
	Thread.sleep(10);
}catch(InterruptedException e){}
```
令人惊讶的事情发生了！有时候程序会陷入死循环！

**原因：**
>当你加入 `try-catch` 语句来让线程休眠时，你可能会引入一个**竞态条件**（Race Condition）。竞态条件是多线程编程中的一个常见问题，它发生在当两个或更多的线程同时访问和修改共享数据时。

>在你的代码中，`i` 是一个共享变量，两个线程 `t1` 和 `t2` 都在尝试增加它的值。当你不使用 `Thread.sleep(10)` 时，线程可能会以非常快的速度交替执行，使得 `i` 的值迅速增加到 50，从而跳出循环。

>但是，当你加入 `Thread.sleep(10)` 时，事情就变得复杂了。考虑以下情况：
>1. 线程 `t1` 执行并增加 `i` 的值。
>2. 在 `t1` 休眠的时候，线程 `t2` 执行并增加 `i` 的值。
>3. 当 `t1` 醒来并继续执行时，它会再次增加 `i` 的值。
>这意味着每次两个线程交替执行时，`i` 的值**可能会增加两次**，而不是一次。这可能导致 `i` 永远不会到达 50，从而使得循环永远不会结束，形成死循环。

>为了避免这种情况，你需要确保对共享变量 `i` 的访问是同步的。这可以通过使用 `synchronized` 关键字或其他同步机制来实现。
### 线程调度
![[微信截图_20231210222958.png|500]]
### 线程阻塞
![[微信截图_20231210223048.png|500]]
![[微信截图_20231210223120.png]]
### 如何终止线程？
![[微信截图_20231210223340.png]]
#### 线程控制
![[微信截图_20231210224713.png|475]]
```java
public class Machine extends Thread{
	public void run(){
		for(int a=0;a<50;a++)
		System.out.println(getName()+":"+a);
	}
	public static void main(String args[])throws Exception{
		Machine machine=new Machine();
		machine.setName("m1");
		machine.start();
		System.out.println("main:join machine");
		machine.join(); //主线程等待machine线程运行结束
		System.out.println("main:end");
	}
}
```
#### 后台线程(感觉不重要)
![[微信截图_20231210224857.png|475]]
#### 定时器
在JDK的`java.util`包中
	- 提供了一个实用类`Timer`，它能够*定时执行特定的任务*
	- 提供一个实用类`TimerTask`类，表示*定时器执行的一项任务*

- `Timer`类的`schedule(TimerTasktask, long delay, long period)`方法可用来*设置定时器需要定时执行的任务*
	- `task`参数表示任务
	- `delay`参数表示延迟执行的时间，以毫秒为单位
	- `period`参数表示每次执行任务的间隔时间，以毫秒为单位
```java
import java.util.Timer;
import java.util.TimerTask;
public class MachineThread extends Thread{
   private int a;

   public void start(){
      super.start();
      Timer timer=new Timer(true) ; //后台线程
      TimerTask task=new TimerTask(){ 
         public void run(){ a=0; }
      };
      timer.schedule(task,2,5); 
   }
   public void run(){
      for(int i=0;i<1000;i++){
         System.out.println(getName()+":"+a++);
         Thread.yield();
      }
   }
   public static void main(String args[]) throws Exception{
        MachineThread machine=new MachineThread();
        machine.start();
   }
}
```
![[微信截图_20231210225239.png|475]]
## 线程引发的问题
#### 并发问题
- 线程间总会或多或少共享数据
- 无法保证线程间的执行顺序，哪个线程先于其他线程抢到CPU
- Java使用同步机制(`synchronized`)解决并发问题
- 如果整个方法需要保护，可以将`synchronized`放到方法头
	- 同一时间内只能一个线程访问共享数据
	- 其它线程必须等访问数据的线程操作完后才能继续访问共享数据
![[微信截图_20240102155041.png|500]]
![[微信截图_20240102155242.png]]
#### Lock Flag
![[微信截图_20231210225656.png]]
![[微信截图_20240102160302.png]]

### 并发中的内存模型
![[微信截图_20240102161208.png]]
![[微信截图_20240102161216.png]]

### 并发编程三个概念
- 原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
- 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
- 有序性：即程序执行的顺序按照代码的先后顺序执行
#### volatile保证可见性
![[微信截图_20240102162415.png]]
#### volatile能保证原子性吗？
不能
```java
public class TestVolatile {
    public volatile int inc = 0;
 
    public void increase() {
        inc++;
    }
 
    public static void main(String[] args) {
        final TestVolatile test = new TestVolatile();
        for(int i=0;i<10;i++){
            new Thread(){  // 创建匿名内部类
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
 
        while(Thread.activeCount()>1)
            Thread.yield();
        System.out.println(test.inc);
    }
}
```
发现代码始终不能按照我们想的到达 $10000$，但是如果在`increase()`方法中增加`synchronized`修饰符则成功实现

**总结：**
- 自增操作不具备原子性的，假如某个时刻变量`inc = 10`

1. 假如`线程1`进行*自增*操作：`线程1`先读取了变量inc的原始值，然后线程1被阻塞了；
2. 然后`线程2`进行*自增*操作，`线程2`也去读取变量inc的原始值，线程1没有对变量进行修改操作，所以线程2会直接去主存读取inc的值10，然后进行加1操作，并把11写入工作内存，最后写入主存
3. 然后`线程1`接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以`线程1`对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存
4. 那么两个线程分别进行了一次自增操作后，inc只增加了1

### 死锁(deadlock)问题
![[微信截图_20231204140538.png|500]]
![[微信截图_20231204141451.png|500]]
**示例：**
```java
package lesson12;

public class SynchBankTest{
	public static final int NACCOUNTS = 10;
	public static final int INITIAL_BALANCE = 10000;
	
	public static void main(String[] args){
		Bank b = new Bank(NACCOUNTS, INITIAL_BALANCE);
		int i;
		for (i = 0; i < NACCOUNTS; i++){
			TransferThread t = new TransferThread(b, i, INITIAL_BALANCE);
			t.setPriority(Thread.NORM_PRIORITY + i % 2);
			t.start();
		}
	}
}

class Bank{ 
	   public static final int NTEST = 10000;
	   private final int[] accounts;
	   private long ntransacts = 0;
	   static final int INITIAL_BALANCE = 10000;
	   
	   public Bank(int n, int initialBalance){  
	      accounts = new int[n];
	      for (int i = 0; i < accounts.length; i++) accounts[i] = initialBalance;
	      ntransacts = 0;
	   }
	   
	   public synchronized void transfer(int from, int to, int amount)throws InterruptedException {  
	      while (accounts[from] < amount)   wait();   // 避免死锁
	      accounts[from] -= amount;  
	      accounts[to] += amount;  
	      ntransacts++; 
	      notifyAll();
	      if (ntransacts % NTEST == 0) test();  // 测试转账次数到10000次后，总额有没有改变
	   }  
	   
	   public synchronized void test() {   // 测试总额会不会改变
	      int sum = 0;
	      for (int i = 0; i < accounts.length; i++)  sum += accounts[i];
	      System.out.println("Transactions:" + ntransacts  + " Sum: " + sum + " and Accounts[0]: " + accounts[0]);
	   }
	   
	   public int size() { return accounts.length; }

	}

class TransferThread extends Thread{  
	private Bank bank;
	private int fromAccount;
	private int maxAmount;
	
	public TransferThread(Bank b, int from, int max) {  
	   bank = b;  
	   fromAccount = from;  
	   maxAmount = max;
	}
	
	public void run(){  
	   try{  
	      while (!interrupted()) {  
	         int toAccount = (int)(bank.size() * Math.random());
	         int amount = (int)(maxAmount * Math.random());
	         bank.transfer(fromAccount, toAccount, amount);
	         sleep(1);
	      }
	   }catch(InterruptedException e) {}
	}
}
```
### 通信问题
产生不同的线程以执行不同的任务，有时候执行同一个任务的不同线程间有某种相关性，这就需要线程间互相通信
![[微信截图_20240102162533.png]]

#### wait 和 notify
![[微信截图_20240102162740.png]]
![[微信截图_20240102162812.png]]
```java
public class WaitTest {
	public static void main(String [] args) {
		ThreadB b = new ThreadB(); b.start();
		System.out.println("Total is: " + b.getTotal());
	}
}
class ThreadB extends Thread {
	int total;
	public void run() {
		synchronized(this) {
			for(int i=0;i<1000;i++) {
				total += 1;
				try{Thread.sleep(5);}catch(Exception e){}
				notify();
			}
		}
	}
	synchronized public int getTotal() {
		try{ wait(); }catch(InterruptedException e) {}
		return total;
	}
}
```

注意：
![[微信截图_20240102163656.png]]
![[微信截图_20240102163758.png]]
