## 典型例题
> 平面上有$n$个矩形，给出每个矩形的坐标。这些矩形可能有重叠。  
> 问这些矩形覆盖的总面积是多少。  
> 数据规模：$1 \leq n \leq 10000$，坐标$0 \leq x1,y1,x2,y2 \leq 10000$

首先给出两种**暴力法**。
1) 先单独求每个矩形的面积，然后把所有矩形的面积加起来，最后减去任意两个矩形的**交集**。求矩形的交集很花时间，需要两两配对，复杂度$O (n^2)$。
2) 另一种更简单的暴力法，是把平面**划成单位边长为$1$（面积也是$1$）的方格**。每读入一个矩形，就把它覆盖的方格标注为已覆盖；对所有矩形都这样处理，最后统计被覆盖的方格数量即可。编码极其简单，但是比上一种方法更慢，且消耗极大的空间。

```c++
#include<bits/stdc++.h>
using namespace std;
bool vis[10001][10001];   //100M内存

int main(){
    int n,sum=0;   //sum：面积
    scanf("%d",&n);
    for(int k=0;k<n;k++){
        int x1,y1,x2,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);  //读一个矩形
        if(x1>x2)  swap(x1,x2);    //坐标排序
        if(y1>y2)  swap(y1,y2);
        for(int i=x1;i<x2;i++)     //统计这个矩形覆盖的面积
            for(int j=y1;j<y2;j++)
                if(!vis[i][j]){    //没有被覆盖过
                    sum++;         //统计面积
                    vis[i][j]=1;   //标注为已经覆盖
                }
    }
    cout<<sum;
    return 0;
}

```

但是对于数据量和坐标值较大的数据，一定会超时，故考虑扫描线法：
