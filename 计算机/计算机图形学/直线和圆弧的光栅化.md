# 光栅化
>[!question] 怎么将连续的矢量在计算机上用离散的像素点成功表示？
   光栅化：Rasterizing objects into pixels
   也称为**扫描转换**
![image.png|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422101352.png)

## 直线光栅化
### DDA(Digital Differential Analyzer，数值微分)算法
设直线的起点为$(x_s, y_s)$,终点为$(x_e,y_e)$,
令$\Delta x = x_e - x_s$，$\Delta y = y_e - y_s$，直线方程是
$$\begin{cases}
x &= &x_s + \Delta x t, \\
y &= &y_s + \Delta y t.
\end{cases}$$其中$0 \leq t \leq 1$

令$\Delta t = \max(|\Delta x|,|\Delta y|)$，取时间步长为$\frac{1}{\Delta t}$得递推公式
$$\begin{cases} x_{i+1} = x_i + \frac{\Delta x}{\Delta t},\\ y_{i+1} = y_i + \frac{\Delta y}{\Delta t}. \end{cases}$$
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422102324.png)
圆黑点表示DDA法生成的直线
```c++
void DDA(int x1, x2, y1, y2){
	int k, i;
	float x, y, xincre, yincre;
	// 计算 delta x 和 delta y 的大值
	k = abs(x2 - x1);
	if(abs(y2 - y1) > k) k = abs(y2 - y1);
	// 进行微分
	xincre = (x2 - x1))/k, yincre = (y2- y1) / k;
	x = x1, y = y1;
	for(int i = 1; i <= k; i++){
		plot(round(x), round(y));
		x += xincre;
		y += yincre;
	}
	// 进行四舍五入
	plot(round(x), round(y));
}
```
含有四舍五入
#### 举例
![e2c4f110bb1c093bcf672ebd50552af.jpg](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/e2c4f110bb1c093bcf672ebd50552af.jpg)
### 生成直线的Bresenham算法
目前**最有效**的线段生成算法
令$m = \frac{\Delta y}{\Delta x}$，考虑$0 \leq m \leq 1$，有$$y = m(x - x_s) + y_s$$
若$x$方向增加1：$x_{i+1} = x_i + 1$
则$y$方向增加$m$：$y_{i+1}=y_i+m(x_{i+1} - x_{i})=y_i + m$
由起点$(x_s, y_s)$可求得直线上的点$(x_i, y_i)$
其中初始值$x_1 = x_s, y_1 = y_s$
用坐标为$(x_i, round(y))$(即$(x_i, y_{i,r})$)的像素来表示直线上的点$(x_i, y_i)$在屏幕上的显示位置

![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422104315.png)
令$\epsilon(x_{i+1}) = y_{i+1}-y_{i,r} - 0.5$, 即理论上的直线的第$i+1$个点的位置减去前一个点在屏幕上的点的位置再减0.5
- 若 $\epsilon(x_{i+1}) \ge 0, \quad y_{i+1,r} = y_{i, r} + 1$
- 若 $\epsilon(x_{i+1}) < 0, \quad y_{i+1,r} = y_{i, r}$

但是计算$y_{i+1}$会比较麻烦，且带有误差，所以要想办法把$y_{i+1}$给消去
注意到$y_{i+2} = y_{i+1} + m$，以此计算$$\epsilon(x_{i+2}) = y_{i+2} - y_{i+1,r}-0.5= y_{i+1}+m - y_{i+1,r}-0.5$$
而$y_{i+1,r}$可以进一步处理：
- 若 $\epsilon(x_{i+1}) \ge 0, \epsilon(x_{i+1}) = y_{i+1}+m-y_{i,r}-1-0.5 = \epsilon(x_{i+1})+m-1$
- 若 $\epsilon(x_{i+1}) < 0, \epsilon(x_{i+1}) = y_{i+1}+m-y_{i,r}-0.5 = \epsilon(x_{i+1})+m$

#### 最终结果
![image.png|475](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422110127.png)
$$\epsilon(x_2)= y_2-y_{1,r}(已知)-0.5 = \frac{y_2-y_1}{1} - 0.5= \frac{\Delta y}{\Delta x} - 0.5=e$$

伪代码：
```c++
x = xs, y = ys;
deltay=ye – ys，deltax = xe –xs;
// 设置 m 
m = deltay / deltax；
// 初始的epsilon
e = m – 0.5；
for(int i=1; i <= deltax; i++){
	plot(x,y)；
	// 满足上面第一个式子
	if(e>=0) {
		y=y+1； e=e–1；
	}；
	// 最后都会+m，所以写在了下面
	x = x + 1；
	e = e + m;
}
plot(x,y);
```
#### 举例
![520bfe512a726f3be340a28eef66d09.jpg|550](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/520bfe512a726f3be340a28eef66d09.jpg)
#### 改进：不用浮点表示，而全部变成int
但目前计算`m`时还是需要用到浮点数，如何不用浮点数，使得整个式子均为整数，提高运算效率？

注意到上面的公式，如果想让式子没有浮点数，那么只需要在两边乘上$2\Delta x$即可
故可用下式表示：$$f = e \times 2\Delta x = 2\Delta y - \Delta x$$
相应的，原本的判断条件也需要改变：$$e \ge 0 \rightarrow f\ge 0$$$$e = e-1 \rightarrow f = f - 2\Delta x$$$$e = e + m \rightarrow f = f + 2\Delta y$$
#### 注意斜率范围与正负问题
![image.png|450](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422134529.png)
伪代码：
```c++
x=x1; y=y1;
deltax = abs(x2–x1);
deltay = abs(y2–y1);
// 判断直线方向
if (x2–x1 >= 0) s1=1;
else s1= –1;

if (y2–y1>=0) s2=1;
else s2= –1;

// 判断哪个的变化大
if (deltay > deltax ){
	temp = deltax;
	deltax = deltay;
	deltay = temp;
	inch = 1;
}
else inch=0;
// 计算f
f = 2 * deltay – deltax;
for (i = 1; i <= deltax; i++){
	plot(x, y);
	if (f >= 0){
		// 如果y的变化大，那么改变x
		if (inch == 1) x = x + s1;
		else y = y + s2;
		f = f – 2 * deltax;
	}
	if (inch==1) y=y+s2;
	else x=x+s1;
	f=f+2*deltay;
}
plot(x,y);
```

### 进一步改进：一次画两个点
![image.png|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422135121.png)
![image.png|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422135126.png)
![image.png|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422135134.png)
![image.png|500](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240422135146.png)

## 圆弧光栅化

假设圆心$(x_c, y_c)$为原点
考虑AB弧的画法，显示一个圆时，只要在显示AB上任一点$(x,y)$时，同时显示在圆周上其它**七个对称点**: $(y,x), (y,-x),(x,-y),(-x,-y),(-y,-x),(-y,x),(-x,y)$
![image.png|300](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240425111126.png)

这样便将问题简化为只考虑一段弧怎么画的问题。
### 从A点开始寻找弧AB上要用的点
假设前面的$P_1 \sim P_{i-1}$点已经画好，$P_{i-1}$是已选中的一个表示圆弧上的点，由于像素是整数，所以没办法刚好位于圆弧上，所以下一个点只能从$H_i$(弧外点)或$L_i$(弧内点)中选择一个最适合的。
![image.png|200](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240425111451.png)
设$H_i$和$L_i$两点的坐标分别为$(x_{hi},y_{hi})$和$(x_{li},y_{li})$
令$D（P）=(x^2+y^2)-R^2$，即计算两点离圆弧的距离
$$d_i = D(H_{i})+D(L_i)=((x_{hi}^2+y_{hi}^2)-R^2) + ((x_{li}^2+y_{li}^2)-R^2)$$
- 当$d_i=0$，点$Hi$和$Li$距弧AB的距离相等。
- 当$d_i<0$时，$|D(H_i)|<|D(L_i)|$(弧外点距离圆更近)，取$H_i$来显示弧AB；
- 当$d_i>0$时，$|D(H_i)|>|D(L_i)|(弧内点更近)$，取$L_i$来显示弧AB。

因此可进行**具体计算**：
设已选中的点$P_{i-1}=(x_{i-1},y_{i-1})$，则$H_i$和$L_i$点的坐标分别为$(x_i,y_{i-1})$和$(x_i,y_{i-1}–1)$,$H_{i+1}$和$L_{i+1}$的坐标分别为$(x_{i+1},y_i)$和$(x_{i+1},y_{i}-1$)。
易知初始值：
$x_0=0, y_0=R, x_1=x_0+1=1$

**初值递推：**
$$d_1 = D(H_1) + D(L_1) = (1^2+y^2_0-R^2)+(1^2+(y_0-1)^2-R^2)= 3-2y_0=3-2R$$
$d_I$与$d_{i+1}$**关系**：
$$d_i = (x^2_i+y^2_{i-1}-R^2)+(x^2_i+(y_{i-1}-1)^2-R^2)=2x^2_i+2y^2_{i-1}-2y_{i-1}-2R^2+1$$
$$d_{i+1} = (x^2_{i+1}+y^2_{i}-R^2)+(x^2_i+(y_{i-1}-1)^2-R^2)=2x^2_i+2y^2_{i-1}-2y_{i-1}-2R^2+1$$

伪代码：
```c++
arc(int R)
{
	int x, y, d;
	x=0, y=R, d=3–2*R;
	// 只考虑AB弧段，当xa = ya时说明刚好重合，此时不考虑，所以循环条件是x<y
	while(x < y){
		plot(x,y);
		if (d < 0) d = d+4*x+6;
		else{
			d = d+4*(x-y)+10；y=y-1;
		}
		x = x+l;
	}
	if (x==y) plot(x,y);
}
```