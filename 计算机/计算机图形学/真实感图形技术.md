# 真实感图形分析
## 计算机生成真实感图形的基本任务
Modeling-建模，场景造型
Transformation-图形变换
Depth Detection-可见面判断
Rendering-渲染，根据光照模型，计算场景中的颜色，达到视觉上的最佳效果
## 真实感图形的生成
计算机图形学真实感取决于2个主要因素:
- 物体表面的精确表示
- 场景中光照效果的物理描述
## 图形绘制的两种基本策略
- 基于对象空间的绘制-逐个渲染每个物体
- 基于图像空间的绘制-遍历像素赋值颜色
# 消隐算法
真实感图形绘制过程中，由于投影变换失去了深度信息，往往导致图形的二义性。
使用消隐算法可以避免此问题
## 分类
1. 按消隐对象分类
- 线消隐
- 面消隐
2. 按消隐空间分类
- 物体空间的消隐算法 
- 图像空间的消隐算法
- 物体空间和图像空间的消隐算法 (画家算法) 
## 深度缓冲算法(Depth-Buffer /Z-Buffer)
一种常用的判定对象表面可见性的图像空间消隐算法
它在投影面上的每一像素位置比较场景中所有面的深度。
由于通常沿着观察系统的z轴来计算各对象距观察平面的深度，该算法也称为z缓存(z-buffer)算法。
![image.png](https://cdn.jsdelivr.net/gh/BlackJack0083/image@main/img/20240516082956.png)
### 算法流程
1. 将深度缓存与帧缓存中的所有单元(x,y)初始化，使得 depthBuff(x,y)=1.0， frameBuff(x,y)=backgroundColor
2. 处理场景中的每一个多边形，每次一个。计算多边形面上各点(x,y)处的深度值z（如果不是已知）
若z<depthBuff(x,y)，则计算该位置的表面颜色并设定 depthBuff(x,y)=z, frameBuff(x,y)=surfaceColor
3. 当处理完所有多边形面后，深度缓存中保存的是可见面的深度值，而帧缓存保存了这些表面的对应属性值。
### OpenGL消隐算法的实现
OpenGL中的深度测试是采用深度缓存器算法。
OpenGL启用深度检测效果需要三个步骤：
1. 在主函数中指定一个32位深度缓冲区：`glutInitDisplayMode(GLUT_RGB|GLUT_DOUBLE|GLUT_DEPTH);`
2. 在初始化设置中启用深度检测： `glEnable(GL_DEPTH_TEST);` 
3. 在绘制函数中清除上一次的深度缓存`glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);`

