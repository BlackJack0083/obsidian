相关链接：[如何在图中思考：图论及其应用的说明性介绍 (freecodecamp.org)](https://www.freecodecamp.org/news/i-dont-understand-graph-theory-1c96572a1401)
python代码介绍：[Python 中的图形 - 理论与实现 - 在代码中表示图形 (stackabuse.com)](https://stackabuse.com/courses/graphs-in-python-theory-and-implementation/lessons/representing-graphs-in-code/)
在线作图：[Graph Editor (csacademy.com)](https://csacademy.com/app/graph_editor/)

**起源：**
七桥问题
![[7ec28fa27fc989308a3983896cb9e46.png]]

# 基本概念

## 图的定义
由多个**点**以及连接这些点的**线**所构成的对象（组成的集合）
eg. ![[微信截图_20230705122131.png]]

### 节点(node)/顶点(vertex) 
Set of vertics:
$$ V = \{v_1,v_2,...,v_7\}$$
#### 孤立顶点
顶点与图中的其他顶点均不相连

### 边(edges)/(links)
Set of edges:
$$E = \{e_{1,2},e_{1,3},...,e_{6,7}\}$$
#### 平行边
同一对顶点之间的多条边

#### 自环边
从同一个顶点连接到自己的边

### 图(graph)

通常用 $n$ 表示图的顶点数，用 $m$ 表示图的边数，即对于图 $G=(V,E), 有 n=|V| 及 m = |E|$
没有**平行边**也没有**自环边**的图称为**简单图**，以下均为简单图

#### 无向图(undirected graph)
![[微信截图_20230705122804.png]]

$$G = \{V, E\}$$

#### 有向图(directed graph)
![[微信截图_20230705122815.png]]

$$D=\{V,A\}$$

#### 无权图(unweighed graph)
![[微信截图_20230705122840.png]]

各边的权重相同

#### 有权图(weighed graph)
![[微信截图_20230705122847.png]]
$$N=(V,E,W)$$
其中$W$为权重的邻接矩阵

**权重的物理含义（不唯一）：**
1. 代表两节点之间的距离
	两节点间无边，对应这两个节点没有直接联通的路，此时定义该不存在的边权重为无穷大

2. 代表两节点之间道路的宽度
	两节点间无边，代表无直接联通的路，此时定义该边权重为0

## 图的数据结构（表示图的主要方式）

>如果两个顶点之间有边相连，则称这两个顶点是相邻的(adjacent)。对边来说，我们说边和它一段的顶点关联(incident)

eg. 这是一张无向无权图
![[微信截图_20230705124603.png]]

### 邻接表(adjacency list)
一种数据结构（链表）,它以图的顶点为起点，将与该顶点关联的边以任意顺序链接起来
![[微信截图_20230705124529.png]]

### 邻接矩阵(adjacency matrix)
有 $n$ 个顶点的图 $G$，其邻接矩阵是 $n \times n$ 矩阵，各行各列对应图的顶点，在图 $G$ 中，如果顶点 $i$ 与顶点 $j$ 相邻，则邻接矩阵的元素 $(i,j)$ 为 $1$；若不相邻，则为 $0$ 
![[微信截图_20230705124730.png]]
易发现，对于无向图，其邻接矩阵是对称的

### 有向图的邻接表与邻接矩阵

#### 有向无权图
![[微信截图_20230705130021.png]]

**邻接表**：
![[微信截图_20230705130118.png]]

**邻接矩阵：**
![[微信截图_20230705130128.png]]
有向图的邻接矩阵一般不对称，因为只能单向

#### 有向有权图（见后面）
[[图论入门#有向有权图]]

### 有权图的邻接表与邻接矩阵

#### 无向有权图
![[微信截图_20230705130428.png]]

**邻接矩阵：**
![[微信截图_20230705130438.png]]
有时候会把没有边的权重记为无穷

#### 有向有权图
![[微信截图_20230705130558.png]]

**邻接矩阵：**
![[微信截图_20230705130605.png]]

## 其他专业术语

### 度
与顶点 $v$ 关联的边的条数称为顶点 $v$ 的度，记为 $d(v)$(网络科学中常记为 $k$ )

图 $G$ 中所有节点的度的最大值称为图 $G$ 的（最大）度，记为$\Delta (G)$ 
对于任意的图，*所有顶点的度的总和*一定是*偶数*
	证明：边$(u,v)$ 的贡献在于给顶点 $u$ 的度 +1，给顶点 $v$ 的度+1， 把所有顶点的度相加，得到的值正好为边数的2倍，必为偶数。

*对于有向网络，其还分为出度、入度（可不看）*
![[微信截图_20230705132416.png]]

#### 平均度（可不看）
![[微信截图_20230705133635.png]]

### 通路
指**图的顶点和边交错排列**的序列，其中首尾为顶点，前后连续出现的顶点和边之间关联（有时候描述时为了简略会把边省略，直接描述顶点序列，如通路$v_1v_2v_3v_5$）

注意：通路允许多次通过同一条边或者同一个顶点（这里这么定义是为了与后面的迹、路做区分）

通路的**长度**定义为通路中所含的边的条数，多次经过则累计（无quantitie权图）

对于有权图，通路的长度由边的“权值总和”来确定，把边的权值看作通过**边需要花费的时间**，则通路的长度即为**沿着该通路移动需要花费的总时间**

### 迹、回路、路、圈（有点绕）

#### 迹
边不重复的通路，但顶点允许重复出现

#### 回路
首尾顶点相同的迹

#### 路（路径）
顶点不重复出现的迹（允许首尾顶点相同）
![[微信截图_20230705145845.png]]

#### 圈
首尾顶点相同的路

*如果图G中所有顶点的度都大于等于2，则G中存在圈（证明略）*

关系：![[Drawing 2023-06-19 18.23.13.excalidraw]]

### 连通与非连通
在图G中，如果对于任意一组顶点 $u、v$，都存在以这两个顶点为端点的路，则称G是连通的，反之，则称G非连通。
矩阵表示：![[微信截图_20230705150044.png]]

最大程度保持连通性的部分称为**连通分支**

### 距离
顶点 u,  v 之间的距离，是指在以 u, v 为端点的路中最短的路的**长度**，记为$d(u,v)$。
在非连通图中，如果不存在从 u 到 v 的路，那么 u, v 之间的距离会被定义为无穷大
![[微信截图_20230705145928.png]]

## 邻接矩阵乘幂定理
设图G的邻接矩阵为 $A$，则 $A^k$ 的 $(i, j)$ 元素等于在图G中从顶点 $v_i$ 到顶点 $v_j$ 之间长度为 $k$ 的不同通路的条数

## 子图

对于图$G=(V,E)和图G'=(V',E')$，如果 $V \subseteq V' 且 E\subseteq E'$ ，则称$G'$ 为 $G$ 的子图。也就是说，$G'$ 可以通过从 $G$ **中删除某些顶点和某些边得到**，但是需要**保证 $G'$ 也是图**，不允许出现只有边$(v_i,v_j)$在$E'$ 中，而顶点$v_i$ 不在$V'$ 中的情况（但是点在图$G'$中，边不在也可以为图（孤立点））。 

此时，定义$E'=\{(u,v)| (u,v) \in E, u\in V', v \in V' \}$。换句话说，$E'$ 为两端点都在 $V'$ 中的边的集合（既包含**充分**：$(u, \ v) \ \subseteq E', \ \forall  u,\ v \subseteq V'$，**也包含必要**：$若\exists u, \ v \in V'，且u,\ v 间有边(u,\ v)，那么这条边(u,\ v) \subseteq V'$ )

此时，$V'$ 在$G$ 中导出的$G'=(V',E')$ 称为 $G$ 的**导出子图**，记为$G' = G[V']$

### 代码实现
`Python`中有一个专门的库`NetworkX`可利用它以标准化和非标准化的数据格式存储网络、生成多种随机网络和经典网络、分析网络结构、建立网络模型、设计新的网络算法、进行网络绘制等

1. **图的生成**
	```python
	import networkx as nx
	
	G = nx.Graph()  # 创建无向图 
	G = nx.DiGraph()  # 创建有向图
	G = nx.MultiGraph()  # 创建多重无向图
	G = nx.MultiDigraph()  # 创建多重有向图
```

eg. 画出一个8个顶点的3正则图（每个顶点的度均为3）
```python
import networkx as nx  
import pylab as plt  
  
G = nx.cubical_graph() # 生成一个3正则图  
plt.subplot(121)       # 激活1号子窗口  
nx.draw(G, with_labels=True)  
plt.subplot(122)  
s = ['v'+str(i) for i in range(1,9)]  
s = dict(zip(range(8), s))  #构造顶点标注的字符字典  
nx.draw(G,pos=nx.circular_layout(G), labels=s,  
        node_color='y', node_shape='s', edge_color='b')  
plt.show()
```
![[微信截图_20230810170619.png]]

`draw`函数：
```python
nx.draw(G, pos=None, ax = None, **kwds)
```
*参数：*
- G: 一个networkx图对象，表示图的节点和边。
- pos: 一个字典，将节点映射到绘图上的位置。如果没有指定，将使用一个弹簧布局算法来自动计算位置。
	图形布局形式：
	- circular_layout：顶点在一个圆环上均匀分布
	- random_layout：顶点在一个单位正方形内随机分布
	- shell_layout：顶点在多个同心圆上分布
- ax: 一个Matplotlib轴对象，指定在哪里绘制图。如果没有指定，将使用当前的轴。
- kwds: 额外的关键字参数，可以用来自定义图的外观，比如节点大小、颜色、形状、边宽度、样式等。

也可以由邻接矩阵直积创建无向图和有向图：
```python
G = nx.Graph(W)  # 由邻接矩阵W创建无向图G
G = nx.DiGraph(W)  # 由邻接矩阵W创建有向图G
```

2. **数据存储结构**
`NetworkX`存储网络的相关数据时，使用了`Python`的三层字典结构，有利于在存储大规模稀疏网络时提高存取速度

eg. 添加图的顶点和边示例
```python
import networkx as nx  
import pylab as plt  
  
G = nx.Graph()  
G.add_node(1)    #添加标号为1的一个顶点  
G.add_nodes_from(['A', 'B'])  #从列表中添加多个顶点  
G.add_edge('A', 'B')   #添加顶点A和B之间的一条边  
G.add_edge(1, 2, weight=0.5)   #添加顶点1和2之间权重为0.4的一条边  
e = [('A','B',0.3),('B','C',0.9),('A','C',0.5),('C','D',1.2)]  
G.add_weighted_edges_from(e)  #从列表中添加多条赋权边  
print(G.adj)      #显示图的邻接表的字典数据  
print(list(G.adjacency()))  #显示图的邻接表的列表数据
```
输出
```python
{1: {2: {'weight': 0.5}}, 'A': {'B': {'weight': 0.3}, 'C': {'weight': 0.5}}, 'B': {'A': {'weight': 0.3}, 'C': {'weight': 0.9}}, 2: {1: {'weight': 0.5}}, 'C': {'B': {'weight': 0.9}, 'A': {'weight': 0.5}, 'D': {'weight': 1.2}}, 'D': {'C': {'weight': 1.2}}}


[(1, {2: {'weight': 0.5}}), ('A', {'B': {'weight': 0.3}, 'C': {'weight': 0.5}}), ('B', {'A': {'weight': 0.3}, 'C': {'weight': 0.9}}), (2, {1: {'weight': 0.5}}), ('C', {'B': {'weight': 0.9}, 'A': {'weight': 0.5}, 'D': {'weight': 1.2}}), ('D', {'C': {'weight': 1.2}})]

```

eg. 画出一个非赋权有向图
```python
import networkx as nx  
import pylab as plt  
  
G=nx.DiGraph()  
List=[(1,2),(1,3),(2,3),(3,2),(3,5),(4,2),(4,6),  
      (5,2),(5,4),(6,5)]  
G.add_nodes_from(range(1,7))  #必须显式地对顶点赋值  
G.add_edges_from(List)  
plt.rc('font',size=16)  
pos=nx.shell_layout(G)   
nx.draw(G,pos,with_labels=True, font_weight='bold', node_color='y')  
W = nx.to_numpy_array(G)   #从图G导出数组  
print(W); plt.show()
```
![[微信截图_20230810172808.png]]
```python
[[0. 1. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0.]
 [0. 1. 0. 0. 1. 0.]
 [0. 1. 0. 0. 0. 1.]
 [0. 1. 0. 1. 0. 0.]
 [0. 0. 0. 0. 1. 0.]]
```

3. **图数据的导出**
eg. 导出赋权图的邻接矩阵和邻接表，并画图
```python
import networkx as nx  
import pylab as plt  
import numpy as np  
  
G=nx.Graph()  
List=[(1, 3, 10), (1, 4, 60), (2, 3, 5),  
      (2, 4, 20), (3, 4, 1)]  
G.add_nodes_from(range(1,5))  
G.add_weighted_edges_from(List)  
W1 = nx.to_numpy_array(G)   # 从图G导出权重邻接矩阵  
W2 = nx.get_edge_attributes(G, 'weight')  # 导出赋权边的字典数据  
pos = nx.spring_layout(G)   
nx.draw(G,pos,with_labels=True, font_weight='bold')  
nx.draw_networkx_edge_labels(G,pos, font_size=13, edge_labels=W2)  
print('邻接矩阵为：\n', W1); print('邻接表字典为：\n', G.adj)  
print('邻接表列表为：\n', list(G.adjacency()))  
print('列表字典为：\n', nx.to_dict_of_lists(G))  
np.savetxt('data6_6.txt', W1, fmt='%d')  # 邻接矩阵保存到文本文件  
plt.show()
```
*输出：*
```python
邻接矩阵为：
 [[ 0.  0. 10. 60.]
 [ 0.  0.  5. 20.]
 [10.  5.  0.  1.]
 [60. 20.  1.  0.]]
邻接表字典为：
 {1: {3: {'weight': 10}, 4: {'weight': 60}}, 2: {3: {'weight': 5}, 4: {'weight': 20}}, 3: {1: {'weight': 10}, 2: {'weight': 5}, 4: {'weight': 1}}, 4: {1: {'weight': 60}, 2: {'weight': 20}, 3: {'weight': 1}}}
邻接表列表为：
 [(1, {3: {'weight': 10}, 4: {'weight': 60}}), (2, {3: {'weight': 5}, 4: {'weight': 20}}), (3, {1: {'weight': 10}, 2: {'weight': 5}, 4: {'weight': 1}}), (4, {1: {'weight': 60}, 2: {'weight': 20}, 3: {'weight': 1}})]
列表字典为：
 {1: [3, 4], 2: [3, 4], 3: [1, 2, 4], 4: [1, 2, 3]}
```
![[微信截图_20230810192621.png]]


# 典型问题与算法

## 最短路问题
定义：设图$G$是赋权图（有向无向均可），$\Gamma$ 为$G$中的一条路，则称 $\Gamma$ 的**各边权之和**为路 $\Gamma$ 的**长度**
对于连通的赋权图$G$中的两个顶点$u_0,v_0$，从$u_0$到$v_0$的路一般不止一条，其中最短的一条称为从$u_0$ 到$v_0$的最短路；最短路的长称为从$u_0$到$v_0$的距离，记为$d(u_0,v_0)$

### Dijkstra算法
当所有 $w_{ij} \ge 0$ 时，Dijkstra算法（1959）是用来求给定点$v_{s}$ 到顶点 $v_t$ 的最佳最短路算法

重要依据：**最短路的子路也是最短路**
![[微信截图_20230810195054.png]]
![[微信截图_20230810195954.png]]

算法思路：**标号作业法**
按据固定起点$u_0$从近到远为顺序，依次求得$u_0$到图$G$各顶点的最短路和距离，直至某个顶点$v_0$（或直至图$G$的所有顶点
*迭代*
```Cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=510;
int g[N][N];    //稠密图用邻接矩阵存储比较节省空间
int dist[N];    //dist[i] i结点到起始点(1号结点)的距离
bool st[N] ;    //st[i] 用于标记i结点的最短路是否确定，若确定st[i]=true;
int n,m;
int Dijkstra()   //套用模板
{
	memset(dist,0x3f,sizeof dist);//除1号结点外，其他均初始为无穷大
	dist[1]=0;
	for(int i=0;i<n;i++) //n次迭代，每次寻找不在s中距离最近的点t
	{
		int t=-1;// 便于更新第一个点
		for(int j=1;j<=n;j++)
		  if(!st[j]&&(t==-1||dist[j]<dist[t])) t=j;
		st[t]=true;  //将t加到s中
		for(int j=1;j<=n;j++)  //用t更新其他点的距离
		  dist[j]=min(dist[j],dist[t]+g[t][j]);
	}
	if(dist[n]==0x3f3f3f3f) return -1; //路径不存在
	else return dist[n];
}
int main()
{
	scanf("%d%d",&n,&m);
	memset(g,0x3f,sizeof g);   //邻接矩阵的初始化，由于求的是最小值，因此初始为无穷大
	while(m--)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		g[x][y]=min(g[x][y],z); //重边中去取最小值
	}
	printf("%d\n",Dijkstra());
	return 0;
}
```

`python`实现：
eg. 旅游路线规划
![[微信截图_20230810204621.png]]
```python
import networkx as nx  
import pylab as plt  

G = nx.DiGraph()  
List = [(1,2,6), (1,3,3), (1,4,1), (2,5,1), (3,2,2), (3,4,2), (4,6,10), (5,4,6),  
        (5,6,4), (5,7,3), (5,8,6), (6,5,10), (6,7,2), (7,8,4), (9,5,2), (9,8,3)]  
G.add_nodes_from(range(1,10))  
G.add_weighted_edges_from(List)  
path = nx.dijkstra_path(G, 1, 8, weight='weight')  #求最短路径  
d = nx.dijkstra_path_length(G, 1, 8, weight='weight')  
plt.rc('font', size=16)  
pos=nx.shell_layout(G)  
# 绘制图  
nx.draw(G, pos, with_labels=True, font_weight='bold', node_color='y')  
# 获取边的权重属性  
edge_labels = nx.get_edge_attributes(G, "weight")  
# 绘制边的标签  
nx.draw_networkx_edge_labels(G, pos, edge_labels)  
plt.show()  
print('最短路径为：', path)  
print('最小费用为：', d)
```
*输出：*
```python
最短路径为： [1, 3, 2, 5, 8]
最小费用为： 12
```

缺陷：不能用于负权重图
![[微信截图_20230810202417.png]]
### Floyd算法

![[微信截图_20230810215116.png]]

![[微信截图_20230810215127.png]]

动态规划问题
关键：求距离算法、求路径算法、最短路查找算法
![[微信截图_20230810213432.png]]

该算法的时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$

#### 代码实现
```python
import networkx as nx  
import numpy as np  
  
G = nx.Graph()  
List = [(1, 3, 10), (1, 4, 60), (2, 3, 5), (2, 4, 20), (3, 4, 1)]  
G.add_nodes_from(range(1,5))  
G.add_weighted_edges_from(List)  
d = nx.floyd_warshall_numpy(G)  
print('最短距离矩阵为：\n', d)  
path = nx.shortest_path(G, weight='weight', method='bellman-ford')  
for i in range(1,len(d)):  
    for j in range(i+1, len(d)+1):  
        print('顶点{}到顶点{}的最短路径为：'.format(i,j), path[i][j])
```
*输出：*
```python
最短距离矩阵为：
 [[ 0. 15. 10. 11.]
 [15.  0.  5.  6.]
 [10.  5.  0.  1.]
 [11.  6.  1.  0.]]
顶点1到顶点2的最短路径为： [1, 3, 2]
顶点1到顶点3的最短路径为： [1, 3]
顶点1到顶点4的最短路径为： [1, 3, 4]
顶点2到顶点3的最短路径为： [2, 3]
顶点2到顶点4的最短路径为： [2, 3, 4]
顶点3到顶点4的最短路径为： [3, 4]

```

1. `shortest_path`函数：求所有顶点对之间的最短路径
```python
shortest_path(G, source=None, target=None, weight = None, method = 'dijkstra')
```
*参数：*
- G: 一个networkx图对象，表示图的节点和边。
- source: 一个节点，表示路径的起点。如果没有指定，计算每个可能的起点的最短路径。
- target: 一个节点，表示路径的终点。如果没有指定，计算每个可能的终点的最短路径。
- weight: None, 字符串或者函数，表示边的权重。如果是None，每条边的权重都是1。如果是字符串，使用这个边属性作为边的权重。如果是函数，这个函数应该接受三个位置参数：边的两个端点和边的属性字典，并返回一个数字作为权重。
- method: 字符串，表示计算路径的算法。支持的选项有：*‘dijkstra’, ‘bellman-ford’*。其他输入会产生一个ValueError。如果weight是None，无权图方法会被使用，这个建议会被忽略。

*返回值：*
- path: 列表或者字典（通常为3层字典），表示最短路径中的节点。
    - 如果source和target都指定了，返回一个列表，表示从source到target的最短路径中的节点。这个列表包括source和target本身。
    - 如果只指定了source，返回一个以target为键、以列表为值的字典，表示从source到每个target的最短路径中的节点。
    - 如果只指定了target，返回一个以source为键、以列表为值的字典，表示从每个source到target的最短路径中的节点。
    - 如果source和target都没有指定，返回一个以source为键、以字典为值的字典，其中path\[source]\[target]表示从source到target的最短路径中的节点。

2. `shortest_path_length`函数：求所有顶点对之间最短距离
```python
shortest_path_length(G, source=None, weight = None, method = 'dijkstra')
```
返回值为可迭代类型

3. `floyd_warshall_numpy`函数
```python
floyd_warshall_numpy(G, nodelist=None, weight='weight')
```
返回所有顶点对之间的最短距离矩阵

#### eg. 设备更新问题
将问题转化成最短路问题


### 寻找范围内的所有点
```python
import networkx as nx
nx.ego_graph(G, node, radius)
```

该函数用于从 networkx 图生成自我网络。自我网络是一个子图，包括一个中心节点(称为自我)和它的邻居(称为改变)在一个给定的半径。

*参数:*
- G: 一个 networkx 图形对象，表示图形的节点和边。
- N: 代表自我网络的自我的单个节点。
- radius: 一个数字，指定与自我的最大距离，以包括自我网络中的其他节点。
- center: 一个布尔值，指示是否将自我节点包含在自我网络中。默认值为 True，这意味着将包括 ego 节点。
- undirected: 一个布尔值，指示是否将图视为无向的。默认值为 False，这意味着图将被视为有向的。如果为真，则图将在生成自我网络之前转换为无向图。
- distance: 指定如何测量图中节点之间的距离的字符串或函数。默认值为“False”，这意味着距离将*通过最短路径中的边数*来衡量。如果给定了一个字符串，它应该是存储距离值的 edge 属性的名称。如果给定一个函数，它应该接受两个节点作为输入，并返回一个数字作为输出。

*返回*: 
一个 networkx 图形对象，该对象表示给定节点的自我网络。自我网络的节点和边是原始图的副本，因此对它们的任何改变都不会影响原始图。

```python 
import networkx as nx  
import matplotlib.pyplot as plt  
  
# Create a directed graph with some nodes and edges  
G = nx.DiGraph()  
G.add_nodes_from([1, 2, 3, 4, 5])  
G.add_edges_from([(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)])  
  
# Generate an ego network of node 1 with radius 2  
E = nx.ego_graph(G, 1, radius=2)  
  
# Draw the original graph and the ego network  
plt.subplot(121)  
nx.draw(G, with_labels=True)  
plt.title("Original graph")  
plt.subplot(122)  
nx.draw(E, with_labels=True)  
plt.title("Ego network of node 1")  
plt.show()
```

![[微信截图_20230810212958.png]]

## 最大流问题

**关键问题：** 找增广链
增广链：前向弧为非饱和弧，后向弧为非零弧
```Matlab
clear;clc;close all
s = [1,1,2,2,2,3,3,4,5,5];
t = [2,3,3,4,5,4,5,6,4,6];
w = [10,88,4,5,3,5,6,11,3,17];
G = digraph(s,t,w); %弧和图不一样，弧有向
[mf,GF] = maxflow(G,1,6);
```

## 最小生成树问题

树：没有圈的**连通图**

#### 避圈法
开始选一条最小权的边，

#### 破圈法
找到一个圈，

```Matlab
W = [0 2 3 5 4 
	 2 0 1 0 4
	 3 1 0 4 0
	 5 0 4 0 2
	 4 4 0 2 0];
G = graph(W,{'A','B','C','D','E'});
[T, pred] = minspantree(G);
T.Edges
```

# 典型例题

### 2011B 交巡警服务平台（优化问题）
宽容分层序列法
