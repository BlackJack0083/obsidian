层次分析法（Analytic Hierarchy Process，简称 AHP）是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。

在确定影响某因素的诸因子在该因素中所占的比重时，遇到的主要困难是这些比重常常**不易定量化**。此外，当影响某因素的**因子较多**时，直接考虑各因子对该因素有多大程度的影响时，常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据，甚至有可能提出一组隐含矛盾的数据。

## 构造判断矩阵
**分而治之的思想**
两两指标进行比较，最终根据两两比较结果推算权重

### 标度

| 标度       |                                                                                          含义 |
| :----------: | :---------------------------------------------------------------------------------------------:|
| 1          |                                                              表示两个因素相比，具有相同重要性 |
| 3          |                                                          表示两个因素相比，前者比后者稍微重要 |
| 5          |                                                          表示两个因素相比，前者比后者明显重要 |
| 7          |                                                          表示两个因素相比，前者比后者强烈重要 |
| 9          |                                                          表示两个因素相比，前者比后者极端重要 |
| 2，4，6，8 |                                                                      表示上述相邻判断的中间值 |
| 倒数       | 若因素i与因素j的重要性之比为$a_{ij}$，那么因素j与因素i的重要性之比为$a_{ji}=\frac{a}{a_{ij}}$ |                                                                                       |

### 判断矩阵
eg. ![](C:\Users\何嘉凯\Desktop\数学建模\新建文件夹\微信图片_20230702184032.png)
层次分析法的<font color ='red'>判断矩阵</font>
**特点：**
1. $a_{ij}$ 表示与指标 $j$ 相比，$i$ 的重要程度
2. 当 $i=j$ 时，两个指标相同，因此同等重要记为1
3. $a_{ij}>0且满足a_{ij}\times a_{ji}=1$ （称满足这一条件的矩阵为<font color='red'>正互反矩阵</font>）

**注意：**
由于各行作为判断的主元不同，可能会导致**矛盾**情况

这个判断矩阵在形成的过程中，有可能出现某种不一致的现象。例如假设你觉得居住比饮食重要，又觉得饮食比交通重要，但是在居住和交通比较时，又觉得交通比居住重要，这就出现了重要程度的不一致现象。由于重要程度可以用数字量化，因此在比较的过程中也会出现传递性。上述的判断即是不满足传递性。

eg.![[79846436e44a1bf29694eb25e13e06a.png]]

### 一致矩阵：
定义：若正互反矩阵满足$a_{ij}\times a_{jk}=a_{ik}$， 则称其为一致矩阵
特点：一致矩阵的**各行和各列成比例**（常用此判断是否为一致矩阵）

<font color ='red'>在使用判断矩阵求权重之前，必须对其进行一致性检验</font>

虽然各层次均已经过层次单排序的一致性检验，各成对比较判断矩阵都已具有较为满意的一致性。但当综合考察时，各层次的**非一致性**仍有可能**积累**起来，引起最终分析结果较严重的非一致性。

如果我们的判断矩阵刚好是一致矩阵，那我们对重要程度的衡量在形式上是十分准确的。但如果我们的判断矩阵最终和一致矩阵*不同*，那就说明我们在判断的过程中，心理预期方面存在一定的偏差。因为我们的心理预期应该并不满足上述的乘法关系，我们往往凭感觉而不是数据进行判断。所以对于判断矩阵，我们也需要进行一定的检验——一致性检验。

## 一致性检验
**原理：** 检验我们构造的判断矩阵和一致矩阵是否有太大的差别
$\begin{equation}\begin{bmatrix}a_{11} & \cdots & a_{1n} \\ \vdots & \cdots & \vdots \\ a_{n1} & \cdots & a_{nn} \end{bmatrix}\end{equation}$ 为一致矩阵的充要条件：
$$\left\{\begin{aligned}
	&a_{ij}>0\\
	 &a_{11}=a_{22}=...=a_{nn}=1\\
	 &[a_{i1},a_{i2},...,a_{in}]=k_{i}[a_{11},a_{12},...,a_{1n}]
	 \end{aligned} \right.$$
**引理1**：$A$ 为 $n$ 阶方阵，且$r(A)=1$，则$A$ 有一个特征值为$tr(A)$，其余特征值均为$0$。因为一致矩阵的各行成比例，所以一致矩阵的秩一定为$1$
由引理1得：**一致矩阵有一个特征值为$n$**，其余特征值均为 $0$ 
另外，特征值为$n$ 时，对应的特征向量刚好为$k[\frac{1}{a_{11}}, \frac{1}{a_{12}}, ... , \frac{1}{a_{1n}}]^T(k \not = 0)$

**引理2**：$n$ 阶正互反矩阵 $A$ 为一致矩阵时当且仅当最大特征值$\lambda_{max} =n$，且当正互反矩阵 $A$ 非一致时，一定满足$\lambda_{max} > n$
判断矩阵越不一致时，最大特征值与 $n$ 相差就越大

### 步骤
#### 计算一致性指标CI
$$CI =\frac{\lambda_{max}-n}{n-1}$$
#### 查找对应的平均随机一致性指标RI

| n   | 1   | 2   | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| RI  | 0   | 0   | 0.58 | 0.90 | 1.12 | 1.24 | 1.32 | 1.41 | 1.45 |
|     |     |     |      |      |      |      |      |      |      |
注：在实际运用中，n很少超过10. 如果指标的个数大于10，则可考虑建立二级指标体系

### 计算一致性比例CR
$$CR=\frac{CI}{RI}$$
如果$CR <0.1$，则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正

## 计算权重
### 方法一：算术平均法求权重
![[微信图片编辑_20230702212346.jpg]]
#### Step1: 将判断矩阵按照列归一化（每个元素除以其所在列的和）
![[微信图片编辑_20230702212414.jpg]]
#### Step2: 将归一化的各列相加（按行求和）
![[微信图片编辑_20230702212446.jpg]]
#### Step3: 将相加后得到的向量中每个元素除以n即可得到权重向量
![[微信图片编辑_20230702212458.jpg]]

*数学语言：*
假设判断矩阵$A=\begin{equation}\begin{bmatrix}a_{11} & \cdots & a_{1n} \\ \vdots & \cdots & \vdots \\ a_{n1} & \cdots & a_{nn} \end{bmatrix}\end{equation}$ ，那么算术平均法求得的权重向量$\omega_i = \frac{1}{n} \sum_{j=1}^n \frac{a_{ij}}{\sum_{k=1}^n a_{kj}},\ (i = 1,2,...,n)$

### 几何平均法求权重（了解即可）![[微信截图_20230702213419.png]]

### 特征值法求权重（使用最多）
#### Step1: 求出矩阵A的最大特征值以及其对应的特征向量
#### Step2: 对求出的特征向量进行归一化

### 得出权重后计算方式：Excel
F4可以锁定单元格

## 层次分析法整体步骤（重点）
![[流程图.png]]

#### Step1: 分析系统中各因素之间的关系，建立系统的递阶层次结构
 应用 AHP 分析决策问题时，首先要把问题**条理化、层次化**，构造出一个有层次的结构模型。在这个模型下，复杂问题被分解为元素的组成部分。这些元素又按其属性及关系形成若干层次。上一层次的元素作为准则对下一层次有关元素起支配作用。这些层次可以分为三类：  
1. 最高层：这一层次中只有一个元素，一般它是分析问题的预定目标或理想结  果，因此也称为**目标层**。  
2. 中间层：这一层次中包含了为实现目标所涉及的中间环节，它可以由若干个层次组成，包括所需考虑的准则、子准则，因此也称为**准则层**。  
3. 最底层：这一层次包括了为实现目标可供选择的各种措施、决策方案等，因此也称为**措施层或方案层**。

![[微信截图_20230702224053.png]]
注意：如果用到了层次分析法，层次结构图一定要放在论文当中

制作方法：亿图脑图（非常简单地设置一下就好了）
![[微信截图_20230702225123.png]]
（随便做的一个效果，感觉还行）

#### Step2: 对于同一层次的各元素关于上一层次中某一准则的重要性进行两两比较，构造两两比较矩阵（判断矩阵）
目标层到准则层的判断矩阵![[微信截图_20230702225437.png]]
准则层到方案层的判断矩阵（注意，由于准则层指标有多个，要针对每个指标做一个判断矩阵）![[微信截图_20230702230521.png]]
准则层——方案层的判断矩阵的数值要**结合实际**来填写，如果题目中有其他数据，可以考虑利用这些数据进行计算

#### Step3: 由判断矩阵计算被比较元素对于该准则的相对权重，并进行一致性检验（检验通过权重才能用）（论文写作中必须先做一致性检验才能获得权重向量）

**注意：** 一致性检验要做多次，其中在目标层到准则层要做，准则层到方案层也要做
![[微信图片_20230703204546.png]]

**三种方法：**
	1. 算术平均法
	2. 几何平均法
	3. 特征值法

比赛时可以三种方法都使用（水字数大法）：
	以往的论文利用层次分析法解决实际问题时，都是采用其中某一种方法求权重，而不同的计算方法可能会导致结果有所偏差。为了保证结果的**稳健性**，本文采用了三种方法分别求出了权重，再根据得到的权重矩阵计算个方案的得分，并进行排序和综合分析，这样避免了采用单一方法所产生的偏差，得出的结论将更全面、更有效。

![[层次分析法（AHP）#一致性检验]]

*Q: CR>0.1如何调整？*
	往一致矩阵上调整，尽量使得每行/列成倍数关系

#### Step4: 计算各层元素对系统目标的合成权重，并进行排序
![[微信截图_20230703002212.png]]
最终结果（eg):
![[微信图片_20230703204808.png]]

## 局限性
1. 评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大（一般n最多为15）
2. 如果决策层中指标是已知的，那么如何利用这些数据使得评价更加准确呢？
3. 它在很大程度上依赖于人们的经验，主观因素的影响很大，它至多只能排除思维  过程中的严重非一致性，却无法排除决策者个人可能存在的严重片面性。 
4. 比较、判断过程较为粗糙，不能用于精度要求较高的决策问题。

## 代码实现部分(注意：国赛还会对代码进行查重）

### 特征根法

```Python
import numpy as np
# 传入判断矩阵
A = np.array([[1, 2, 3],
   [1/2, 1, 2],
   [1/3, 1/2, 1]])
r = len(A)                                  # 获取指标个数
c = len(A[0])
RI = [0, 0, 0.58, 0.90, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49, 1.51]
V, D = np.linalg.eig(A)                     # 求判断矩阵的特征值和特征向量，V特征值，D特征向量；
list_V = list(V)
lambda_max = np.max(list_V)                 # 最大特征值
i = list_V.index(lambda_max)
eigenvector = D[:, i]                                 # 对应特征向量
CI = (lambda_max - c) / (c - 1)             # 计算一致性检验指标CI
CR = CI / RI[c - 1]
if CR < 0.10:
    # print("CI=", CI)
    # print("CR=", CR)
    print('通过一致性检验，各向量权重向量Q为：')
    sum = np.sum(eigenvector)
    eigenvector_norm = eigenvector/sum                   # 特征向量标准化
    print(eigenvector_norm)                                # 输出权重向量
else:
    print("未通过一致性检验，需重新构造对比矩阵A")
```

### 算数平均法

```Python
import numpy as np  
# 传入判断矩阵  
A = np.array([[1, 2, 3],  
   [1/2, 1, 2],  
   [1/3, 1/2, 1]])  
r = len(A)                            # 获取指标个数,r为行数，x为列数  
c = len(A[0])  
sum = np.sum(A, axis=0)               # 获得每列总和  
Q = np.zeros(r)                       # 构造全零数组  
  
"""  
for i in range(n):  
    # 对各列归一化  
    sum_inside=0    for j in A[i, :]:        j = j/sum[sum_inside]              # 对第i行的元素归一化  
        sum_inside += 1        # 把各列加起来  
        Q[i] += j"""  
  
'''  
# 换种写法，先让每列都归一化，然后直接每列加起来  
A_T = A.T  #直接操作很难对列向量进行更改，这里选择转置后再修改  
sum_inside=0  
for j in A_T:  
    j = j/sum[sum_inside]              # 对第i列的元素归一化  
    sum_inside += 1    # 把各列加起来  
    Q += j'''  
  
# 还可以用两个矩阵各元素相除来计算  
SUM = np.tile(sum,(len(A[0]), 1))  #这里将原本一行的sum扩展为与A大小一样的矩阵  
A /= SUM   # 标准化  
Q = np.sum(A, axis=1)  # 列求和  
  
# 相加后除以列数  
Q_norm = Q / c  
RI = [0, 0.001, 0.58, 0.90, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49, 1.51]   # 注意，原本n=2时，RI=0，但是分母不能为0，故在此进行修改，设置为0.001  
V, D = np.linalg.eig(A)           # 求判断矩阵的特征值和特征向量，V特征值，D特征向量；  
list_V = list(V)                  # 将所有特征值存储在列表中  
lambda_max = np.max(list_V)       # 最大特征值  
CI = (lambda_max - c)/(c - 1)     # 计算一致性检验指标CI  
CR = CI / RI[c - 1]  
if CR < 0.10:  
    # print("CI=", CI)  
    # print("CR=", CR)    print('通过一致性检验，各向量权重向量Q为：')  
    print(Q_norm)  
else:  
    print("未通过一致性检验，需重新构造对比矩阵A")
```

### 几何平均法
```Python
import numpy as np
# 传入判断矩阵
A = np.array([[1, 2, 3],
   [1/2, 1, 2],
   [1/3, 1/2, 1]])
r = len(A)                            # 获取指标个数,r为行数，x为列数
c = len(A[0])
Q = np.ones(r)                       # 构造全一数组

for i in range(c):  # 将各个行向量的元素横着相乘
    Q *= A.T[i, :]

# 对各个元素开n次方
Q = Q ** (1/c)

# 相乘后除以sum
sum = np.sum(Q)
Q_norm = Q / sum
RI = [0, 0, 0.58, 0.90, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49, 1.51]
V, D = np.linalg.eig(A)           # 求判断矩阵的特征值和特征向量，V特征值，D特征向量；
list_V = list(V)                  # 将所有特征值存储在列表中
lambda_max = np.max(list_V)       # 最大特征值
CI = (lambda_max - c)/(c - 1)     # 计算一致性检验指标CI
CR = CI / RI[c - 1]
if CR < 0.10:
    # print("CI=", CI)
    # print("CR=", CR)
    print('通过一致性检验，各向量权重向量Q为：')
    print(Q_norm)
else:
    print("未通过一致性检验，需重新构造对比矩阵A")
```