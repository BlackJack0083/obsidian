![[微信截图_20230726091644.png]]

一般灰色预测的思路是通过对原始数据序列进行**累加、均值、微分**等运算，建立一个一阶**线性微分方程**模型，然后利用**最小二乘法估计模型参数**，求解微分方程得到**预测值**，再通过**累减运算**还原数据序列，最后进行误差分析和后验检验。

# GM(1,1) 模型: Grey Model
GM(1,1)是使用原始的离散非负数据列，通过一次**累加**生成**削弱随机性**的比较有规律的离散数据列，然后通过建立微分方程模型，得到在离散点处的解经过累减生成的原始数据的近似估计值，从而预测原始数据的后续发展
GM(1,1)表示模型是**一阶微分方程**，且只含有一个变量的灰色模型
![[微信截图_20230726092122.png]]

## 原理介绍

设$x^{(0)}=(x^{(0)}(1),x^{(0)}(2),...,x^{(0)}(n))$ 是**最初的非负数据列**，我们对其进行一次累加得到新的生成数据列$x^{(1)}$($x^{(0)})$ 的1-AGO序列(**累加生成序列**)：
$$x^{(1)}=(x^{(1)}(1),x^{(1)}(2),...,x^{(1)}(n))$$其中，$x^{(1)}(k)=\sum_{i=1}^k x^{(0)}(i), k=1,2,...,n$

令$z^{(1)}$为数列$x^{(1)}$的**紧邻均值生成数列**，即$$z^{(1)}=(z^{(1)}(2),z^{(1)}(3),...,z^{(1)}(n))$$其中，$z^{(1)}(k)=0.5x^{(1)}(k)+0.5x^{(1)}(k-1),k=2,3,...,n$

建立*灰微分方程*（数据离散，不能预测，需要转化为白化方程）$$x^{(0)}(k)+az^{(1)}(k)=b,\  k=2,3,...,n$$其中，$b$表示*灰作用量*，$-a$表示*发展系数*

引入矩阵形式：
$$u=(a,b)^T,\quad Y=\begin{bmatrix}x^{(0)}(2)\\x^{(0)}(3)\\ \vdots \\ x^{(0)}(n)\end{bmatrix},\quad B=\begin{bmatrix}-z^{(1)}(2) & 1 \\ -z^{(1)}(3) & 1 \\ \vdots & \vdots \\ -z^{(1)}(n) & 1 \end{bmatrix} $$
利用最小二乘法即可得到参数$a,b$的估计值$$\hat u = \begin{bmatrix} \hat a \\ \hat b \end{bmatrix} = (B^TB)^{-1}B^TY$$
求得$a,b$以后，即可进行回归$$x^{(0)}(k)=-az^{(1)}(k)+b \Rightarrow y=kx+b\ (形式上一致)$$
**获得白化方程（将离散转为连续）：**
$$x^{(0)}(k)=-\hat a z^{(1)}(k)+\hat b \Rightarrow x^{(1)}(k)-x^{(1)}(k-1)=-\hat az^{(1)}(k)+\hat b$$
$$x^{(1)}(k)-x^{(1)}(k-1)=\int_{k-1}^{k} \frac{dx^{(1)}(t)}{dt}dt\ (牛顿莱布尼茨公式)$$
$$z^{(1)}(k)=\frac{x^{(1)}(k)+x^{(1)}(k-1)}{2} \approx \int_{k-1}^{k}x^{(1)}(t)dt(定积分几何意义)$$
故得到$$\int_{k-1}^k \frac{dx^{(1)}(t)}{dt}dt \approx -\hat a \int_{k-1}^{k}x^{(1)}(t)dt + \int_{k-1}^{k}\hat b dt=\int_{k-1}^{k}[-\hat a x^{(1)}(t)+\hat b]dt$$
故相应的*白化方程*即为$$\frac{dx^{(1)}(t)}{dt}=-\hat ax^{(1)}(t)+\hat b$$
如果取 初值 $\hat x^{(1)}(t)|_{t=1} = x^{(0)}(1)$ ，则可求出对应解：$$\hat x^{(1)}(k+1)=[x^{(0)}(1)-\frac{\hat b}{\hat a}]e^{-\hat ak}+\frac{\hat b}{\hat a}, \ k=0,1,...,n-1,...$$
得到原参考序列数值：
由$x^{(1)}(k)=\sum_{i=1}^k x^{(0)}(i), \ k=1,2,...,n$，可得到$$\hat x^{(0)}(k+1)=\hat x^{(1)}(k+1)-\hat x^{(1)}(k) = (1-e^{\hat a})[x^{(1)}(1)-\frac{\hat b}{\hat a}]e^{-\hat k},\ k=1,2,...,n-1$$
若要对原始数据进行**预测**，只需要在上式取$k \ge n$即可

**本质：** 有条件的**指数**拟合：$f(x) = C_1e^{C_2(x-1)}$ 。此处指数规律主要针对$x^{(1)}(k)$序列而言，原始序列是作差的结果

## 准指数规律的检验
注：此处采用的是《数学建模算法与应用》给出的级比计算方法，清风的在后面补充
1. 数据具有准指数规律是使用灰色系统建模的理论基础
2. 设参考序列为：$x^{(0)}=(x^{(0)}(1),x^{(0)}(2),...,x^{(0)}(n))$，定义级比$$\lambda(k)=\frac{x^{(0)}(k-1)}{x^{(0)}(k)}, \quad k=2,3,...,n$$
3. 如果 $\forall k,\ s.t.\ \lambda (k) \in \Theta=(e^{-\frac{2}{n+1}},e^{\frac{2}{n+1}})$ ，则序列 $x^{(0)}$ 可以作为模型$GM(1,1)$ 的数据进行灰色预测。
4. 否则需要对序列$x^{(0)}$作必要的**变换处理**，使其落入可容范围内，即取充分大的正常数 $c$ ，做平移变换：$$y^{(0)}(k)=x^{(0)}(k)+c, \ k=1,2,...,n$$使序列 $y^{(0)}=(y^{(0)}(1), y^{(0)}(2),..., y^{(0)}(n))$ 的级比$$\lambda_y(k)=\frac{y^{(0)}(k-1)}{y^{(0)}(k)} \in \Theta, \quad k=2,3,...,n$$

5. 清风的准指数规律检验的过程更加复杂，且级比的定义刚好与教材反过来，这里将他的检验步骤附上：![[微信截图_20230728001652.png]]

PS：其实感觉上来看，清风的级比定义更符合一般的思路，就跟公比一样的定义方法。但是他的关于准指数规律的检验上面相对复杂。而网上大部分做法（包括数学建模教材）没有那么深入，只是对级比做了简单的判断，这一点或许可以作为亮点，为使用灰色预测提供理由

## 发展系数与预测情形的探究
![[微信截图_20230728002509.png]]

## GM(1,1)模型评价与检验
使用GM(1,1)模型对未来的数据进行预测时，我们需要先检验GM(1,1)模型对原数据的拟合程度（对原始数据还原的效果）

### 残差检验（or相对误差检验）

绝对残差：$\epsilon(k)=x^{(0)} (k)-\hat x^{(0)} (k), \ k=2,3,...,n$
相对残差：$\epsilon_r(k)=\frac{|x^{(0)}(k)-\hat x^{(0)}(k)|}{x^{(0)}(k)}\times 100\% k=2,3,...,n$
*平均相对残差*：$\bar \epsilon_r=\frac{1}{n-1}\sum_{k=2}^n|\epsilon_r(k)|$
*相对误差*：$\delta(k)=\frac{|x^{(0)}(k)-\hat x^{(0)}(k)|}{x^{(0)}(k)},\  k=2,3,...,n$ （平均相对误差同理）
这里$\hat x^{(0)}(1)=x^{(0)}(1)$。

如果 $\bar \epsilon_r < 20\%(\delta (k)<0.2)$，则认为GM(1,1)对原数据的拟合达到一般要求
如果 $\bar \epsilon_r < 10\%(\delta(k)<0.1)$，则认为GM(1,1)对原数据的拟合效果非常不错

### 级比偏差检验(后验差比检验系数)
首先由参考序列算出级比$\lambda(k) / \sigma(k)$，再用发展系数 $\hat a$ 求出相应的级比偏差（后验差比检验系数）
**计算级比：**
$$\lambda(k)=\frac{x^{(0)}(k -1)}{x^{(0)}(k)},\quad k=2,3,...,n$$
根据预测的发展系数($-\hat a$)计算得出相应的级比偏差与平均级比偏差：
$$\rho(k)=|1-\frac{1-0.5 \hat a}{1+0.5 \hat a}\lambda(k)|,\quad \bar\rho=\sum_{k=2}^n \frac{\rho(k)}{n-1}$$
如果$\bar \rho<0.2$，则认为GM(1,1)对原数据的拟合达到一般要求
如果$\bar \rho<0.1$，则认为GM(1,1)对原数据的拟合效果非常不错

注：清风在这里的级比偏差定义：
![[微信截图_20230728102057.png]]

#### 例子：预测城市交通噪声[\dB(A)]\(选自教材)

| 序号 | 年份 | $L_{eq}$ |
| ---- | ---- | -------- |
| 1    | 1986 | 71.1     |
| 2    | 1987 | 72.4     |
| 3    | 1988 | 72.4     |
| 4    | 1989 | 72.1     |
| 5    | 1990 | 71.4     |
| 6    | 1991 | 72.0     |
| 7    | 1992 | 71.6     |
解：
1. **级比检验**：
	建立时间序列：
	$x^{(0)}=(x^{(0)}(1), x^{(0)}(2), ..., x^{(0)}(7))=(71.1,72.4,72.4,72.1,71.4,72.0,71.6)$
	(1)求*级比*$\lambda(k)$：
		$$\lambda(k)=\frac{x^{(0)}(k -1)}{x^{(0)}(k)},\quad k=2,3,...,7$$
		$\lambda = (\lambda(2),\lambda(3),...,\lambda(7)) = (0.982,1,1.0042,1.0098,0.9917,1.0056)$
	(2)级比判断：
		由于所有的$\lambda(k) \in [e^{-\frac{2}{7+1}}, e^{\frac{2}{7+1}}] = [0.982,1.0098], \quad k=2,...,7$，故可以用$x^{(0)}$作满意的GM(1,1)建模
		PS: 课本的做法明显比清风的简单

2. **GM(1,1)建模**
	(1)对原始数列$x^{(0)}$作一次累加，得到
	$$x^{(1)}=(71.1,143.5,215.9,288,359.4,431.4,503)$$
	(2)构造数据矩阵B以及数据向量Y
	$$Y=\begin{bmatrix}x^{(0)}(2)\\x^{(0)}(3)\\ \vdots \\ x^{(0)}(n)\end{bmatrix},\quad B=\begin{bmatrix}-\frac{1}{2}(x^{(1)}(1)+x^{(1)}(2)) & 1 \\ -\frac{1}{2}(x^{(1)}(2)+x^{(1)}(3)) & 1 \\ \vdots & \vdots \\ -\frac{1}{2}(x^{(1)}(6)+x^{(1)}(7)) & 1 \end{bmatrix}$$
	(3)计算
	$$\hat u = \begin{bmatrix} \hat a \\ \hat b\end{bmatrix} = (B^TB)^{-1}B^TY=\begin{bmatrix} 0.0023\\72.6573\end{bmatrix}$$
	(4)建立模型，取白化微分方程$$\frac{dx^{(1)}(t)}{dt}+\hat a x^{(1)}(t)=\hat b$$
	取初值$x^{(1)}=x^{(0)}(1)$求解，得$$\hat x^{(1)}(k+1)=(x^{(0)}(1)-\frac{\hat b}{\hat a})e^{-\hat a k} +\frac{\hat b}{\hat a} = -30928.8525e^{-0.002344k}+30999.9525$$
	(5)求生成序列预测值$\hat x^{(1)}$及模型还原值$\hat x^{(0)}$
	由上式的时间响应函数可算得$\hat x^{(1)} = (\hat x^{(1)}(1), \hat x^{(1)}(2),...,\hat x^{(1)}(7))$，取$\hat x^{(0)}(1) = x^{(0)}(1)=71.1$，由$\hat x^{(0)}(k+1)=\hat x^{(1)}(k+1)-\hat x^{(1)}(k),k = 1,2,3,4,5,6$得$$\hat x^{(0)}=(\hat x^{(1)}(1), \hat x^{(1)}(2),...,\hat x^{(1)}(7))=(71.1,72.4,72.2,72.1,71.9,71.7,71.6)$$

3. 模型检验与预测

| 序号 | 年份 | 原始值 | 预测值  | 残差    | 相对误差 | 级比偏差 |
| ---- | ---- | ------ | ------- | ------- | -------- | -------- |
| 1    | 1986 | 71.1   | 71.1    | 0       | 0        |          |
| 2    | 1987 | 72.4   | 72.4057 | -0.0057 | 0.01%    | 0.0203   |
| 3    | 1988 | 72.4   | 72.2362 | 0.1638  | 0.23%    | 0.0023   |
| 4    | 1989 | 72.1   | 72.0671 | 0.0329  | 0.05%    | 0.0018   |
| 5    | 1990 | 71.4   | 71.8984 | -0.4984 | 0.70%    | 0.0074   |
| 6    | 1991 | 72.0   | 71.7301 | 0.2699  | 0.37%    | 0.0107   |
| 7     | 1992     | 71.6       |  71.5622       | 0.0378        | 0.05%         | 0.0032         |

平均级比偏差为 $\bar \rho(k) = \frac{1}{7-1} \sum_{k=2}^7 \rho(k) \approx 0.0076 <0.1$, 认为达到较高的要求，精度较高，可用于预测和预报

##### 代码实现
```python
import numpy as np  
import sympy as sp  
import matplotlib.pyplot as plt  
from scipy.stats import pearsonr  
  
x0 = np.array([71.1, 72.4, 72.4, 72.1, 71.4, 72.0, 71.6])  
n = len(x0)  
  
lamda = x0[:-1]/x0[1:]  # 计算级比  
b1 = [min(lamda), max(lamda)]  # 计算级比取值范围  
b2 = [np.exp(-2/(n+1)), np.exp(2/(n+1))]  # 计算级比容许范围  
if b1[0] > b2[0] and b1[1] < b2[1]:  
    print("通过级比检验")  
  
# GM(1,1)建模与计算  
x1 = np.cumsum(x0)  # 求累加序列  
z = np.mean([x1[:-1], x1[1:]], axis=0)  # 求均值生成序列  
B = np.vstack([-z, np.ones(n-1)]).T  # 构造一个矩阵 B，其第一列是构造的均值生成序列 -z，第二列是全 1u = np.linalg.pinv(B) @ x0[1:]  # 最小二乘法拟合参数  
print("最小二乘法拟合得到灰作用量为", u[1], " 发展系数为", u[0])  
  
sp.var('t')  
sp.var('x', cls=sp.Function)  # 定义符号变量和函数  
eq = x(t).diff(t) + u[0] * x(t) - u[1]  # 定义符号微分方程  
xt0 = sp.dsolve(eq, hint='separable', ics={x(0): x0[0]})  # 求解符号微分方程  
xt0 = sp.simplify(xt0.args[1])  # 化简符号解  
xt = sp.lambdify(t, xt0, 'numpy')  # 转换为匿名函数  
t = np.arange(n+1)  
xh = xt(t)  # 求预测值  
x0h = np.hstack([x0[0], np.diff(xh)])  # 还原数据  
  
# 进行预测  
x1993 = x0h[-1]  # 提取1993年的预测值  
cha = x0 - x0h[:-1]  
delta = abs(cha/x0) * 100  # 计算相对误差  
rho = abs(1 - (1-0.5*u[0]) / (1+0.5*u[0]) * lamda)  
rho_mean = np.mean(rho)  
print("相对误差为", delta)  
print("级比偏差为", delta)  
print("平均级比偏差为", rho_mean)  
if rho_mean < 0.1:  
    print("达到较高要求，该模型精度较高")  
elif rho_mean < 0.2:  
    print("达到一般要求")  
  
print('1993年预测值：', round(x1993, 4))  
print('皮尔逊相关系数：', pearsonr(x0, x0h[:-1])[0])  
plt.plot(t[:-1], x0, 'bo-', label='原始数据')  
plt.plot(t[:-1], x0h[:-1], 'ro-', label='还原数据')  
plt.legend(prop={'family': 'Kaiti', 'size': 10})  
plt.xlabel('时间', fontproperties='SimHei', size=15)  
plt.ylabel('数据', fontproperties='SimHei', size=15)  
plt.show()
```
注：
1. `cumsum`用法
```python
numpy.cumsum(a, axis=None, dtype=None, out=None)
```
*参数：*
- a：一个数组或类似数组的对象
- axis：一个整数，表示沿着哪个轴计算累积和，如果不指定，则对整个数组进行累积和
- dtype：一个数据类型，表示输出数组的元素类型，如果不指定，则默认为a的元素类型
- out：一个可选的输出数组，用来存储计算结果，如果不指定，则返回一个新的数组

*返回值：*
该函数的返回值是一个与a形状相同的数组（如果axis不为None）或一个一维数组（如果axis为None），其中每个元素都是a中对应位置之前（包括当前位置）所有元素的和

eg. 
```python
a = numpy.array([[1, 2, 3], [4, 5, 6]])

numpy.cumsum(a) # 对整个数组进行累积和
array([ 1,  3,  6, 10, 15, 21]) # 返回一个一维数组

numpy.cumsum(a, axis=0) # 沿着第0轴（行）进行累积和
array([[ 1,  2,  3],
       [ 5,  7,  9]]) # 返回一个二维数组

numpy.cumsum(a, axis=1) # 沿着第1轴（列）进行累积和
array([[ 1,  3,  6],
       [ 4,  9, 15]]) # 返回一个二维数组

```

2. `sympy`模块
	`sympy`是一个用于符号运算的`Python`模块，它可以用来表示和操作数学表达式，而不是具体的数值。
	
	1. `sp.var` 函数
		它可以用来定义*符号变量*和*符号函数*，它们可以用来表示数学表达式中的未知量，而不是具体的数值。
		符号函数是一种特殊的符号表达式，用来表示一个或多个变量之间的函数关系，例如$f(x) = x^2 + 1$。符号函数可以用来定义和求解微分方程、积分方程、傅里叶变换等数学问题。
		*参数：*
		-  字符串：表示函数的名字，例如 'x'
		-  cls参数：表示函数的类型，必须是sp.Function或其子类，例如sp.Function。
	
	2. `sp.desolve`函数
	```python
sympy.dsolve(eq, func=None, hint='default', simplify=True, ics=None, **kwargs)
```
	该函数是sympy模块提供的功能，它可以用来求解常微分方程、偏微分方程、代数微分方程等数学问题。
	*参数：*
	- eq：一个微分方程或一个微分方程的列表
	- func：一个未知函数或一个未知函数的列表
	- hint：一个字符串，表示求解微分方程的方法
	- simplify：一个布尔值，表示是否对解进行化简
	- ics：一个字典，表示初始条件或边界条件
	- kwargs：一些其他的可选参数
	
	在代码中，使用了以下参数：
	- eq：一个一阶线性微分方程，表示灰色预测模型（GM(1,1)）中的累加生成序列。
	- hint：‘separable’，表示使用可分离变量法来求解微分方程。可分离变量法是一种常用的求解微分方程的方法，它可以将微分方程转化为两个单变量函数的积分方程。
	- ics：{x(0):x0[\0]}，表示初始条件为x(0)等于原始数据序列的第一个元素
	
	*返回值：*
	*一个等式或一个等式的列表*，表示微分方程的解。
	如果没有给出未知函数或初始条件，sp.dsolve函数会自动推断它们。
	如果没有给出求解方法，sp.dsolve函数会尝试所有可能的方法，并返回最优的解。
	
	3. `sp.simplify`函数
	该函数可以用来化简符号表达式，使其更加简洁和易读。它接受一个符号表达式，并返回一个化简后的符号表达式。例如：
	```python
import sympy as sp
sp.var('x')
expr = x**2 + 2*x - 3 # 定义一个符号表达式
expr = sp.simplify(expr) # 化简符号表达式
print(expr)

# 输出：
(x + 3)*(x - 1)
```
	
	使用`xt0.args[1]`来提取方程中的*符号解*，而不是整个等式。这样做可以使符号解更加简洁和易读，也可以方便后续的数值计算。
	
	符号解和整个等式区别：
	```python
# 假设有一个一阶线性微分方程
eq = x(t).diff(t) + u[0] * x(t) - u[1] # 定义一个一阶线性微分方程

# 使用sp.dsolve函数来求解微分方程，并给出初始条件
xt0 = sp.dsolve(eq, hint='separable', ics={x(0):x0[0]}) # 求解微分方程

# 这时，xt0是一个等式，表示微分方程的解，它的形式如下
Eq(x(t), (1.02*exp(0.01*t) + 99.0)/100)

# 等式中包含了未知函数x(t)和自变量t，以及一些常数和运算符。如果想要化简或计算这个表达式，需要对整个等式进行操作，这可能会比较复杂和冗余。

# 使用xt0.args[1]来提取符号解，即等号右边的部分，可得到
(1.02*exp(0.01*t) + 99.0)/100
```
	提取符号解后，只保留了未知函数x(t)的表达式，而不包含等号和自变量t。这样，就可以更加简洁和易读地表示微分方程的解，并且可以方便地进行化简或转换为匿名函数等操作。
	
	4. `sp.lambdify`函数
	该函数可以用来*将符号表达式转换为匿名函数*，以便于进行数值计算。
	匿名函数是一种*没有名字的函数*，可以方便地定义和调用。
	该函数接受一个或多个符号变量、一个符号表达式和一个可选的模块参数，并返回一个匿名函数。例如：
	```python
import sympy as sp
import numpy as np
sp.var('x')
expr = x**2 + 1 # 定义一个符号表达式
f = sp.lambdify(x, expr, 'numpy') # 转换为匿名函数
print(f(2)) # 调用匿名函数

# 输出
5
```
	
	在代码中使用了`sp.lambdify`函数来将微分方程的符号解转换为匿名函数，并使用`numpy`作为参数，表示使用`numpy`模块中的函数来计算数值。这样做可以对任意时间点进行预测，而不需要再进行符号运算。

## 拓展
![[微信截图_20230728104506.png]]

## 什么时候使用灰色预测
1. 数据是以*年份*度量的非负数据（如果是月份或者季度数据一定要用时间序列模型）；  
2. 数据能经过准指数规律(级比检验）的检验~~（除了前两期外，后面至少90%的期数的光滑比要低于0.5）；~~  
3. 数据的期数较短且和其他数据之间的关联性不强（$\leq10$，也不能太短了，比如只有3期数据），要是数据期数较长，一般用传统的时间序列模型比较合适。

## 代码实现
### 思路分析（清风的）
1. 画出原始数据的时间序列图，并判断原始数据中是否有负数或期数是否低于4期，如果是的话则报错，否则执行下一步；（虽然是这么说，但是实际上发现原始数据低于4期后应该就能意识到灰色预测不可用了）
2. 对一次累加后的数据进行准指数规律检验，返回两个指标：  
	*指标1*：光滑比小于0.5的数据占比（一般要大于60%）  
	*指标2*：除去前两个时期外，光滑比小于0.5的数据占比（一般大于90%）  
  并让用户决定数据是否满足准指数规律，满足则输入1，不满足则输入0  
3. 如果上一步用户输入0，则程序停止；如果输入1，则继续下面的步骤。  
4. 让用户输入需要预测的后续期数，并判断原始数据的期数：  
	4.1 数据期数为4：  
		分别计算出*传统*的GM(1,1)模型、*新信息*GM(1,1)模型和*新陈代谢*GM(1,1)模型对于未来期数的预测结果，为了保证结果的稳健性，对三个结果求平均值作为预测值。  
	4.2 数据期数为5,6或7：  
		取最后两期为*试验组*，前面的n-2期为*训练组*；用训练组的数据分别训练三种GM模型，并将训练出来的模型分别用于预测试验组的两期数据；利用试验组两期的真实数据和预测出来的两期数据，可分别计算出三个模型的**SSE**；选择SSE最小的模型作为我们建模的模型。 （这个步骤我觉得还是很关键的，就是预测类问题*不能在建模时就把所有数据都用完了*，要留下部分数据进行预测结果的检验与误差分析）
	4.3 数据期数大于7：  
		取最后三期为试验组，其他的过程和4.2类似。  
5. 输出并绘制图形显示预测结果，并进行残差检验和级比偏差检验。


