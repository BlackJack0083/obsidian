注1：若想深入了解可选修《计算方法（数值分析）》一课
注2：目前只写到一维插值，二维插值待补充
拓展资料：[数学建模笔记——插值拟合模型(一) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/163801915)

**什么是插值？**
>首先插值所要做的事情，大体上来说，就是已知n个数据点，要找一个函数，使得其图像通过所给的n个数据点。当我们在做这件事情的时候，我们实际上**假设所给的n个数据点来源于一个未知的函数**，而找一个函数使其通过这些数据点，其实想要做的是找一个函数逼近那个提供数据点的未知函数。因而插值是属于**数值逼近**的内容。

![[微信截图_20230716005003.png]]
**插值问题：** 对于任意非观测点 $\hat x(\hat x \not = x_i, \ i=0,1,...,n)$，要估计该点的函数值 $f(\hat x)$，就可以用 $\phi (\hat x)$ 的值作为 $f(\hat x)$ 的近似估计值，即 $\phi (\hat x) \approx f(\hat x)$。通常称此类建模问题为插值问题，而构造近似函数的方法称为插值方法。

数模比赛中，常常需要根据已知的函数点进行数据、模型的处理和分析，而有时候现有的数据是极少的，不足以支撑分析的进行，这时就需要使用一些数学的方法，“模拟产生”一些新的但又比较靠谱的值来满足需求，这就是插值的作用。

### 插值法的分类
![[微信截图_20230716005243.png]]

### 一般插值多项式原理
**定理：** 设有 $n+1$ 个互不相同的节点$(x_i, y_i) (i=0,1,2,...,n)$，则存在唯一的多项式：
$$L_n(x) = a_0 + a_1 x + a_2 x^2 +...+a_n x^n$$
使得$L_n(x_j)=y_j, (j= 0,1,2,...,n)$

*证明*：构造方程组
$$\begin{cases} a_0+a_1x_1+a_2x_1^2+...+a_nx_0^n=y_0\\a_0+a_1x_0+a_2x_1^2+...+a_nx_1^n=y_1\\......\\a_0+a_1x_n+a_2x_n^2+...+a_nx_n^n=y_n\\ \end{cases}$$
令$$A=\begin{equation}\begin{bmatrix}1 & x_0 &...& x_0^n \\ 1 & x_1 &...& x_1^n \\ \vdots & \vdots & \cdots & \vdots \\1 & x_n &...& x_n^n \\\end{bmatrix}\end{equation}$$（范德蒙行列式）
$$X=\begin{equation}\begin{bmatrix}a_0\\a_1\\ \vdots\\ a_n\end{bmatrix}\end{equation}, $$
$$Y=\begin{equation}\begin{bmatrix}y_0\\y_1\\ \vdots\\ y_n\end{bmatrix}\end{equation} $$
方程组的矩阵形式如下：$AX=Y$
由于$|A|=\prod_ {i=1}^ {n} \prod_{j=0}^{i-1} (x_i-x_j) \not = 0$，所以方程组有**唯一解**
从而$L_n(x) = a_0 + a_1 x + a_2 x^2 +...+a_n x^n$唯一存在。

*注：*
	1. 只要 $n+1$ 个节点互异，满足上述插值条件的多项式是唯一存在的
	2. 如果**不限制**多项式的次数，插值多项式并不唯一
	3. 记插值多项式 $P_n(x)$ 与被查函数 $f(x)$ 之间的差 $R_n(x)=f(x)-P_n(x)$ 称为截断误差，又称为**插值余项**。当 $f(x)$ 足够光滑时，$$R_n(x)=f(x)-L_n(x)= \frac {f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x), \xi \in (a,b)$$ 式中：$\omega_{n+1}(x) = \prod_{j=0}^n(x-x_j)$
	4. 求解 $X$ 对应系数的方法：**左乘 $A$ 的逆矩阵**
		$$AX=Y \Rightarrow X=A^{-1}Y$$
	5. 解法的弊端：无法直接构造出插值多项式的表达式，插值多项式的次数每提高一次，都要重新求解，从而影响了方法推广

#### 例：已知部分观测点，求插值函数，并求x=1.5,2.6处函数估计值

| $x_i$ | 1   | 2   | 3   | 4   | 5   | 6   |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: |
|  $y_i$  | 16 | 18 | 21 | 17 | 15 | 12 |

##### 通过python代码实现（来自教材）
```python
# 首先，导入numpy和pylab两个模块，分别用于进行数值计算和绘图。
import numpy as np
import pylab as plt

# 然后，定义已知的数据点x0和y0，分别表示自变量和因变量的值。这些数据点可以看作是某个未知函数f(x)的采样结果。
x0 = np.arange(1, 7); y0 = np.array([16, 18, 21, 17, 15, 12])

# 接着，使用numpy.vander()函数生成一个范德蒙德矩阵A，它是一个方阵，每一行是x0中的一个元素的幂次排列。例如，如果x0=[1,2,3]，则A=[[1,1,1],[4,2,1],[9,3,1]]。
A = np.vander(x0)

# 然后，使用numpy.linalg.inv()函数计算A的逆矩阵，并与y0相乘，得到p，它是一个向量，表示插值多项式的系数。例如，如果p=[a,b,c]，则插值多项式为f(x)=ax^2+bx+c。
p = np.linalg.inv(A) @ y0  #求插值多项式的系数

# 接着，打印出p中的系数，并使用numpy.polyval()函数计算给定自变量值（如1.5和2.6）对应的插值函数值yh，并打印出来。
print('从高次幂到低次幂的系数为：', np.round(p,4))
yh = np.polyval(p, [1.5, 2.6])  #计算函数值，返回yh数组
print('预测值为：', np.round(yh,4))

# 最后，使用pylab.plot()函数绘制已知数据点的散点图和插值曲线，并显示出来。
plt.plot(x0, y0, 'o')  #画出已知数据点的散点
xt = np.linspace(1,  6,  100)
plt.plot(xt, np.polyval(p, xt))  #画插值曲线
plt.show()

```

所得图像：![[微信截图_20230718001332.png]]
其中，从高次幂到低次幂的系数为： [  -0.2417    4.3333  -28.9583   87.6667 -115.8      69.    ]
预测值为： [14.918  20.8846]

注：
1. `pylab`是一个方便的模块，它批量导入了`matplotlib.pyplot`（用于绘图）和`numpy`（用于数学和数组操作）到一个单一的命名空间。它的目标是提供一个类似于`matlab`的工作环境，用户无需自己导入所需的功能。
2. `numpy.vander()`函数是用于生成一个**范德蒙德矩阵**的函数。范德蒙德矩阵是一个矩阵，它的每一列都是输入向量的幂次。函数的语法如下：
```python
numpy.vander(x, N=None, increasing=False)
```
参数说明：
- x: 一维的输入数组
- N: 输出矩阵的列数。如果没有指定N，将返回一个方形数组（N = len(x)）
- increasing: 列的幂次的顺序。如果为True，幂次从左到右增加，如果为False（默认），则相反
返回值：
- out: 范德蒙德矩阵。如果increasing为False，第一列是$x^{(n-1)}$，第二列是$x^{(n-2)}$，以此类推。如果increasing为True，列是$x^0, x^1, …, x^{(n-1)}$

3. `numpy.polyval()`函数是用于在特定的值上**评估一个多项式**的函数。如果p是一个长度为N的多项式，那么这个函数返回值为：`p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]`。如果x是一个序列，那么p(x)会对每个元素进行评估。如果x是另一个多项式，那么返回的是两个多项式的复合，即p(x(t))。函数的语法如下：
```python
numpy.polyval(p, x)
```
参数说明：
- p: 一维的多项式系数数组，或者一个poly1d对象。多项式系数按照**幂次的递减顺序**给出。
- x: 一个数，一个数组，或者一个poly1d对象，用于评估p。
返回值：
- values: 多项式的评估值。如果x是一个poly1d对象，结果是两个多项式的复合。如果x是一个数组，结果也是一个数组。


## 一维插值问题
![[微信截图_20230716004911.png]]


### 拉格朗日插值法
在数值分析中，拉格朗日插值法是以法国十八世纪数学家约瑟夫∙路易斯∙拉格朗日命名的一种**多项式插值方法**。在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。

![[微信截图_20230716094448.png]]
![[微信截图_20230716094501.png]]
![[微信截图_20230716094513.png]]

**拉格朗日插值多项式引入**：
$$\omega_{n+1}(x)=(x-x_0)(x-x_1)...(x-x_n)$$
$$\omega'_{n+1}(x_k)=(x_k-x_0)...(x_k-x_{k-1})(x_k-x_{k+1})...(x_k-x_n)$$
$$l_i(x)=\frac{(x-x_0)(x-x_1)...(x-x_n)}{(x-x_i)(x_i-x_0)...(x_i-x_{i-1})(x_i-x_{i+1})...(x_i-x_n)}=\frac{\omega_{n+1}(x)}{(x-x_i)\omega'_{n+1}(x_i)}$$
其中，
$$l_i(x_j)=\begin{cases} 1, & j = i \\ 0, & j \not = i \\  \end{cases}$$
令$$L_n(x)=\sum_{k=0}^n y_kl_k(x)=\sum_{k=0}^n y_k \frac{\omega_{n+1}(x)}{(x-x_k)\omega'_{n+1}(x_k)}$$
该式称为**n次拉格朗日多项式**，由于**解的唯一性**，得到n+1个节点的n次拉格朗日插值多项式存在且唯一

#### 拉格朗日插值再求例题
由于有6个插值节点，拉格朗日插值多项式是5次多项式，利用`python`求得结果与原例一样
##### 代码实现
```python
#程序文件ex7_2.py  
import numpy as np  
from scipy.interpolate import lagrange  
  
x0 = np.arange(1, 7); y0 = np.array([16, 18, 21, 17, 15, 12])  
p = lagrange(x0, y0)  #求拉格朗日插值多项式的系数，返回一个数组  
print('从高次幂到低次幂的系数为：', np.round(p,4))  
yh = np.polyval(p, [1.5, 2.6])  #计算多项式的函数值  
print('预测值为：', np.round(yh,4))
```
`scipy`当中有专门求拉格朗日插值的函数`lagarange`


### 牛顿插值法
#### 差商
设有函数$f(x),\ x_0,x_1,x_2,...$ 为一系列互不相等的点，称$\frac{f(x_i)-f(x_j)}{x_i-x_j}(i \not = j)$ 为$f(x)$ 关于点$x_i,x_j$ 一阶差商（也称均商），记为$f[x_i,x_j]$，即$$f[x_i,x_j]=\frac{f(x_i)-f(x_j)}{x_i-x_j}$$称一阶差商的差商
$$\frac{f[x_i,x_j]-f[x_j,x_k]}{x_i-x_k}$$为$f(x)$关于点$x_i,x_j,x_k$ 的二阶差商，记为 $f[x_i,x_j,x_k]$。一般地，称$$\frac{f[x_0,x_1,...,x_{k-1}]-f[x_1,x_2,...,x_k]}{x_0-x_k}$$为$f(x)$ 关于点$x_0,x_1,...,x_k$ 的$k$ 阶差商，记为$f[x_0,x_1,...,x_k]$

容易证明，差商具有以下性质：
$$f[x_i,x_j]=f[x_j,x_i]$$
$$f[x_i,x_j,x_k]=f[x_i,x_k,x_j]=f[x_j,x_i,x_k]$$

#### 牛顿插值公式
线性插值公式可表示为$$\phi_1(x)=f(x_0)+(x-x_0)f[x_0,x_1]$$称为一次牛顿插值多项式。一般地，由各阶差商的定义，依次可得
$$f(x)=f(x_0)+(x-x_0)f[x,x_0],$$
$$f[x,x_0]=f[x_0,x_1]+(x-x_1)f[x,x_0,x_1],$$
$$f[x,x_0,x_1]=f[x_0,x_1,x_2]+(x-x_2)f[x,x_0,x_1,x_2],$$
$$...$$$$f[x,x_0,...,x_{n-1}]=f[x_0,x_1,...,x_n]+(x-x_n)f[x,x_0,...,x_n]$$
将以上各式分别乘以$1,(x-x_0),(x-x_0)(x-x_1),...,(x-x_0)(x-x_0)...(x-x_{n-1})$，然后相加并消去两边相等的部分，得到
$$f(x)=f(x_0)+(x-x_0)f[x_0,x_1]+...+(x-x_0)(x-x_1)...(x-x_{n-1})f[x_0,x_1,...,x_n]+(x-x_0)(x-x_1)...(x-x_n)f[x,x_0,x_1,...,x_n]$$
记为$N_n(x)$.

$$R_n(x)=(x-x_0)(x-x_1)...(x-x_n)f[x,x_0,x_1,...,x_n]=\omega_{n+1}(x)f[x,x_0,x_1,...,x_n]$$
显然，$N_n(x)$ 是至多n次的多项式，且满足插值条件，因而它是$f(x)$ 的n次插值多项式。这种形式的插值多项式称为牛顿插值多项式。$R_n(x)$ 称为牛顿插值余项。


### 两种插值法评价：  
1. 与拉格朗日插值法相比，牛顿插值法的计算过程具有*继承性*。（牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能够产生新的函数，即$N_{n+1}(x)=N_n(x)+(x-x_0)...(x-x_n)f[x_0,x_1,...,x_{n+1}]$）但是牛顿插值也*存在龙格现象*的问题
2. 由插值多项式的唯一性可知，牛顿插值余项与拉格朗日插值余项也是相等的，即$$R_n(x)=\omega_{n+1}(x)f[x,x_0,x_1,...,x_n]=\frac{f^{(n+1)}(\xi)}{n!}$$其中，$\xi \in (a,b), a=min_{0 \leq i\leq n}\{x_i\}, \ b=max_{0 \leq i\leq n}\{x_i\}$ 
3. 上面讲的两种插值仅仅要求插值多项式在插值节点处与被插函数有相等的函数值，而这种插值多项式却*不能全面反映被插值函数的性态*。然而在许多实际问题中，不仅要求插值函数与被插值函数在所有节点处有相同的函数值，它也需要在一个或全部节点上插值多项式与被插函数有相同的低阶甚至高阶的导数值

### 插值多项式弊端与解决办法
#### 龙格现象（两端明显震荡）
利用多项式对某一函数作近似逼近，计算相应的函数值，一般情况下，多项式的次数越多，需要的数据就越多，而预测也就越准确。然而，插值次数越高，插值结果越偏离原函数的现象称为**龙格振荡**现象
![[微信截图_20230716095746.png]]
![[微信截图_20230716095757.png]]

高次插值会产生*龙格现象*，即在两端处波动极大,产生明显的震荡。在不熟悉曲线运动趋势的前提下，不要轻易使用高次插值。

#### 较好的解决办法：分段线性插值
![[微信截图_20230716103619.png]]

**一次插值**：在*两个点间*插值（多项式为一次式）
将每两个相邻的节点用直线连起来，如此形成的一条折线就是分段一次线性插值函数，记作 $I_n(x)$, 它满足 $I_n(x_i)=y_i$，且 $I_n(x)$ 在每个小区间 $[x_i,x_{i+1}]$ 上是线性函数 $(i=0,1,...,n)$ 
$I_n(x)$ 可以表示为 $I_n(x)=\sum_{i=0}^n y_il_i(x)$
其中，$$l_i(x)=\begin{cases} \frac{x-x_{i-1}}{x_i-x_{i-1}}, & x \in [x_{i-1},x_i] \\ \frac{x-x_{i+1}}{x_i-x_{i+1}}, & x \in [x_{i},x_{i+1}] \\ 0,&其他 \end{cases}$$

**二次插值**：选取与节点 $x$ 最近的*三个节点* $x_{i-1}, x_i, x_{i+1}$ 进行二次插值，即在每一个区间 $[x_{i-1}, x_{i+1}]$ 上，取：
$$f(x)\approx L_2(x)=\sum_{k=i-1}^{i+1}[y_k \prod_{j=i-1,j \not = k}^i+ \frac{(x-x_j)}{(x_k-x_j)}]$$
这种分段的低次插值称为*分段二次插值*，在几何上就是用分段抛物线代替 $y=f(x)$，故分段二次插值又称为*分段抛物插值*

分段插值函数在相邻子区间的端点处（衔接点）光滑程度不高，如分段线性插值函数在插值节点处一阶导数不存在。如要作出一条整体较光滑的曲线，可以考虑埃尔米特插值或样条插值。

### 埃尔米特(Hermite)插值（函数和导数都相等）
保持插值曲线在节点处有切线（光滑），使插值函数和被插函数的密合程度更好
要求：
$$\varphi (x_i)=y_i(i=0,1,2,...,n)$$
$$\varphi' (x_i)=y_i'(i=0,1,2,...,n)$$
![[微信截图_20230716144712.png]]

直接使用Hermite插值得到的多项式次数较高，也存在龙格现象，因此在实际应用中，往往使用*分段三次Hermite插值多项式(PCHIP)*

### 三次样条插值
所谓**样条曲线**，就是把一根具有弹性的细长木条（样条）在几个样点处用压铁压住，其余位置自由弯曲。这样子，由样条形成的曲线就称之为样条曲线。样条曲线实际上是由分段三次曲线连接而成，且在连接点处具有连续的二阶导数，从数学上加以概括就得到三次样条的概念。

数学上将具有一定光滑性的分段多项式称为**样条函数**。具体来说，给定区间$[a,b]$的一个分划：$$\Delta:a=x_0<x_1<...<x_{n-1}<x_n=b$$
若函数$S(x)$ 满足：
1. 在每个小区间$[x_i,x_{i-1}]$上$S(x)$ 为 $k$ 次多项式
2. $S(x)$ 在$[a,b]$ 上具有$k-1$阶导数
则称$S(x)$ 为关于分划$\Delta$ 的k次样条函数，其图形称为k次样条曲线

#### 三次样条插值概念
设$y=f(x)$在点 $x_0,x_1,x_2,...,x_n$ 的值为 $y_0,y_1,y_2,...,y_n$，若函数 $S(x)$ 满足下列条件：
1. $S(x_i)=f(x_i)=y_i, \quad i=0,1,2,...,n$
2. 在每个子区间 $[x_i,x_{i+1}](i=0,1,2,....,n-1)$ 上$S(x)$ 是*三次多项式*
3. $S(x)$在$[a,b]$ 上*二阶连续可微*
4. 满足边界条件（之一即可）：
	1. *固定边界*条件：$S'(x_0)=f'(x_0), \quad S'(x_n)=f'(x_n)$
	2. *自由边界*条件:$S^"(x_0)=f^"(x_0), \quad S^"(x_n)=f^"(x_n)$
	3. *周期边界*条件：当$y=f(x)$是以$b-1=x_n-x_0$为周期的周期函数时，要求$S(x)$ 也是周期函数，故端点要满足$S'(x_n)=f'(x_n) 和 S^"(x_n)=f^"(x_n)$
称满足以上条件的$S(x)$ 为$f(x)$ 的三次样条插值函数

##### 代码实现
对正弦函数进行样条插值
```python
import numpy as np  
from scipy import interpolate  
import pylab as pl  
  
x = np.linspace(0, 10, 11)  
y = np.sin(x)  
  
xnew = np.linspace(0, 10, 101)  
  
pl.plot(x, y, 'ro')  
  
f = interpolate.interp1d(x, y, kind='cubic')  
ynew = f(xnew)  
  
pl.plot(xnew, ynew, label='cubic')  
pl.legend(loc='lower right')  
pl.show()
```

### 实际例子与代码实现

主要运用`scipy.interpolate`模块的一维插值函数`interpld`，调用格式
```python
scipy.interpolate.interp1d （x，y，kind =‘linear’，axis = -1，copy = True，bounds_error = None，fill_value = nan，assume_sorted = False）
```
参数说明:
- x和y是一维实数数组，表示数据点的坐标；
- kind是*指定插值方法*的字符串或整数；
- axis是指定要沿其进行插值的y轴；
- copy是指定是否制作x和y的内部副本；
- bounds_error是指定是否对超出x范围的值进行插值；
- fill_value是指定超出范围的值的填充方式；
- assume_sorted是指定x是否已经按升序排列。

返回值：一个可以用于查找新点的值的*函数*。

#### 例：机床加工
给出数据点，画出曲线，并求$x=0$处斜率和$13\leq x\leq15$范围内$y$的最小值

| $x_i$ | 0 | 3   | 5   | 7   | 9   | 11   | 12   | 13 | 14 | 15| 
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: |:--:|:---:|:--:|:--:|
|  $y_i$  |0| 1.2 | 1.7 | 2.0 | 2.1 | 2.0 | 1.8 | 1.2 | 1.0 | 1.6|

```python
#程序文件ex7_4.py  
import numpy as np  
from scipy.interpolate import interp1d # 导入scipy模块中的interp1d函数，用于进行插值计算  
from scipy.interpolate import lagrange # 导入scipy模块中的lagrange函数，用于进行拉格朗日插值计算  
import pylab as plt # 导入pylab模块，用于绘制图形  
  
a = np.loadtxt('data7_4.txt') # 从data7_4.txt文件中读取数据，存储为数组a  
  
x0 = a[0]; y0 = a[1] # 将a数组的第一行和第二行分别赋值给x0和y0，作为已知的插值节点  
  
x = np.linspace(0,15,151)       # 生成一个从0到15等分为151份的数组x，作为插值点  
yx1 = interp1d(x0, y0)  # 使用interp1d函数对x0和y0进行分段线性插值，返回一个插值函数yx1  
y1 = yx1(x)             # 使用yx1函数计算插值点x对应的函数值y1，存储为数组y1  
p2 = lagrange(x0, y0)   # 使用lagrange函数对x0和y0进行拉格朗日插值，返回一个多项式对象p2  
y2 = np.polyval(p2, x)  # 使用np.polyval函数计算多项式p2在插值点x处的函数值y2，存储为数组y2  
yx3 = interp1d(x0, y0, 'cubic') # 使用interp1d函数对x0和y0进行三次样条插值，返回一个插值函数yx3  
y3 = yx3(x)                     # 使用yx3函数计算插值点x对应的函数值y3，存储为数组y3  
  
dx = np.diff(x); dy = np.diff(y3)     # 使用np.diff函数分别计算数组x和y3的差分，存储为数组dx和dy  
dyx = dy / dx; dyx0 = dyx[0]          # 将dy除以dx得到斜率数组dyx，取其第一个元素作为x=0处的斜率dyx0  
xt = x[130:]; yt = y3[130:]           # 将数组x和y3从第131个元素开始截取，存储为数组xt和yt  
ymin = min(yt)                        # 求yt中的最小值，存储为ymin  
xmin = [xt[ind] for ind, v in enumerate(yt) if v==ymin]  
# 使用列表推导式找出yt中等于最小值的元素对应的xt中的元素，存储为列表xmin  
  
print('x=0处斜率的数值解为：', dyx0)  
print('xmin=', xmin); print('ymin=', ymin) # 打印出最小值及其对应的自变量  
  
plt.rc('font', family='SimHei')        # 设置字体为SimHei，用来正常显示中文标签  
plt.rc('axes', unicode_minus=False)    # 设置坐标轴不使用unicode编码的负号，用来正常显示负号  
plt.rc('font', size=16)                # 设置字体大小为16  
plt.subplot(131); plt.plot(x, y1)      # 在第一行第一列的子图中绘制分段线性插值曲线，横轴为x，纵轴为y1  
plt.title('分段线性插值')                # 设置子图标题为“分段线性插值”  
plt.subplot(132); plt.plot(x, y2)      # 在第一行第二列的子图中绘制拉格朗日插值曲线，横轴为x，纵轴为y2  
plt.title('Lagrange插值')  
plt.subplot(133); plt.plot(x, y3)      # 在第一行第三列的子图中绘制三次样条插值曲线，横轴为x，纵轴为y3  
plt.title('三次样条插值')  
plt.show()
```
![[微信截图_20230718113524.png]]
### 注意
1. 插值方法一般用于插值区间内部点的函数值估计或预测，利用该方法进行趋势外推预测时，可进行短期预测估计，对中长期预测不一定适用


